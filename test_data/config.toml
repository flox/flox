[vars]
[resolve.empty]
# Not actually a resolve response, just have to put it somewhere
skip_if_output_exists = "empty.json"
cmd = '''
    echo "[]" > empty.json
'''
post_cmd = '''
    main_output_dir="$(dirname $(dirname $RESPONSE_FILE))"
    mv empty.json "$main_output_dir/empty.json"
'''

[resolve.failed_resolution]
pre_cmd = '''
    flox init
'''
cmd = "flox install definitely-not-a-package"
ignore_cmd_errors = true

# Install a package that doesn't exist and that doesn't have suggestions
[resolve.badpkg]
pre_cmd = "flox init"
cmd = "flox install badpkg"
ignore_cmd_errors = true

# Install multiple packages that don't exist
[resolve.badpkg1_badpkg2]
pre_cmd = "flox init"
cmd = "flox install badpkg1 badpkg2"
ignore_cmd_errors = true

# Install a package that doesn't exist and a another that does only exist on Linux
[resolve.badpkg_bpftrace]
pre_cmd = "flox init"
cmd = "flox install badpkg bpftrace"
ignore_cmd_errors = true

# Install a package that only exists on Linux
[resolve.bpftrace]
pre_cmd = "flox init"
cmd = "flox install bpftrace"

# Install multiple packages that only exist on Linux
[resolve.bpftrace_systemd]
pre_cmd = "flox init"
cmd = "flox install bpftrace systemd"
ignore_cmd_errors = true

[resolve.curl_hello]
pre_cmd = "flox init"
cmd = "flox install curl hello"

[resolve.emacs]
pre_cmd = "flox init"
cmd = "flox install emacs"

[resolve.emacs_vim]
pre_cmd = "flox init"
cmd = "flox install emacs vim"

[resolve.gzip]
pre_cmd = "flox init"
cmd = "flox install gzip"

[resolve.glibc]
pre_cmd = '''
    flox init
    tomlq --in-place --toml-output '.options.systems = [ "x86_64-linux" ]' .flox/env/manifest.toml
'''
cmd = "flox install glibc"
ignore_cmd_errors = true # build will fail on macos, thats fine

[resolve.glibc_incompatible]
pre_cmd = '''
    flox init
    tomlq --in-place --toml-output '.options.systems = [ "x86_64-linux" ]' .flox/env/manifest.toml
'''
cmd = '''
 tomlq --in-place --toml-output '.options.systems = [ "x86_64-linux", "aarch64-darwin" ]' .flox/env/manifest.toml
 flox install glibc || true
'''
ignore_cmd_errors = true # build will fail on macos, thats fine

[resolve.darwin_ps]
pre_cmd = '''
    flox init
    tomlq --in-place --toml-output '.options.systems = [ "x86_64-darwin" ]' .flox/env/manifest.toml
'''
cmd = "flox install darwin.ps"
ignore_cmd_errors = true # build will fail on linux, thats fine

[resolve.darwin_ps_incompatible]
pre_cmd = '''
    flox init
'''
cmd = '''
    tomlq --in-place --toml-output '.options.systems = [ "x86_64-darwin", "aarch64-linux" ]' .flox/env/manifest.toml
    flox install darwin.ps
'''
ignore_cmd_errors = true # build will fail on linux, thats fine

[resolve.fish_3_2_2]
pre_cmd = "flox init"
cmd = "flox install fish@3.2.2"

[resolve.hello]
pre_cmd = "flox init"
cmd = "flox install hello"

[resolve.hello_unfree]
pre_cmd = "flox init"
cmd = "flox install hello-unfree"

[resolve.go]
pre_cmd = "flox init"
cmd = "flox install go"

[resolve.krb5_after_prereqs_installed]
files = ["envs/krb5_prereqs/manifest.toml"]
pre_cmd = '''
    flox init
    flox edit -f manifest.toml
'''
cmd = "flox install krb5"

[resolve.ld_floxlib]
skip_if_output_exists = "envs/ld_floxlib"
files = ["envs/ld_floxlib/manifest.toml"]
pre_cmd = "flox init"
ignore_cmd_errors = true
cmd = "flox edit -f manifest.toml"

# Attempts an install for a package that doesn't exist but that *does* have suggestions
[resolve.node_suggestions]
pre_cmd = "flox init"
cmd = "flox install node"
ignore_cmd_errors = true

[resolve.old_hello]
pre_cmd = "flox init"
cmd = "flox install hello"
post_cmd = '''
    cat "$RESPONSE_FILE" | jq | sed 's/"derivation": .*$/"derivation": "\/nix\/store\/AAA-hello-2.12.1.drv",/g' > tmp.json
    mv tmp.json "$RESPONSE_FILE"
'''

# Install a specific version of Node that doesn't exist on x86_64-darwin
# so we get "constraints too tight" as a resolution message
[resolve.old_node]
pre_cmd = "flox init"
cmd = "flox install nodejs@14.16.1"
ignore_cmd_errors = true

[resolve.overmind]
pre_cmd = "flox init"
cmd = "flox install overmind"

# Try to install a package that doesn't exist, but that *does* have suggestions
[resolve.package_suggestions]
pre_cmd = "flox init"
cmd = "flox install package"
ignore_cmd_errors = true

[resolve.python3]
pre_cmd = "flox init"
cmd = "flox install python3"

[resolve.python3_pip]
pre_cmd = "flox init"
cmd = "flox install -i pip python311Packages.pip python3"

[resolve."python311Packages.pip"]
pre_cmd = "flox init"
cmd = "flox install python311Packages.pip"

[resolve.redis]
pre_cmd = "flox init"
cmd = "flox install redis netcat"

[resolve."rubyPackages_3_2.rails"]
pre_cmd = "flox init"
cmd = "flox install rubyPackages_3_2.rails"

[resolve.rust-lib-src]
pre_cmd = "flox init"
cmd = "flox install rustPlatform.rustLibSrc"

[resolve.tabula]
pre_cmd = "flox init"
cmd = "flox install tabula"
ignore_cmd_errors = true # tabula is broken

# resolve.tabula_allowed is likely redundant and at least for the time being
# generates the same JSON as resolve.tabula.
# But broken is included in the resolution request,
# so include it here in case the server changes behavior.
[resolve.tabula_allowed]
pre_cmd = '''
    flox init
    tomlq --in-place --toml-output '.options.allow.broken = true' .flox/env/manifest.toml
'''
cmd = "flox install tabula"

[resolve.torchvision-bin]
pre_cmd = "flox init"
cmd = "flox install python311Packages.torchvision-bin"
ignore_cmd_errors = true

[resolve.webmention_ripgrep_rails]
pre_cmd = "flox init"
cmd = "flox install -i foo rubyPackages_3_2.webmention ripgrep -i bar rubyPackages_3_2.rails"

[resolve.vim]
pre_cmd = "flox init"
cmd = "flox install vim"

[resolve.vim-vim-full-conflict]
pre_cmd = "flox init"
cmd = "flox install vim vim-full"
ignore_cmd_errors = true # pacakges conflict


[search.hello]
cmd = "flox search hello"

[search.python]
cmd = "flox search python"

[search.surely_doesnt_exist]
# This command is intended to fail, it still dumps a useful response
cmd = "flox search surely_doesnt_exist || true"

[search.ello_all]
cmd = "flox search ello --all"

[search.exactly_ten]
cmd = "flox search python"
post_cmd = '''
    cat "$RESPONSE_FILE" | jq '[{"count": 10, "results": .[0].results[:10]}]' > tmp.json
    mv tmp.json "$RESPONSE_FILE"
'''

[search.java_suggestions]
cmd = "flox search java"

[show.hello]
cmd = "flox show hello"

[show.flask]
cmd = "flox show python310Packages.flask"

[init.go]
files = ["init/go/common", "init/go/module"]
pre_cmd = '''
    cp -r {common,module}/* .
'''
cmd = "flox init --auto-setup"

[init.node_npm]
files = ["init/node/common", "init/node/npm"]
pre_cmd = '''
    cp -r {common,npm}/* .
'''
cmd = "flox init --auto-setup"

[init.node_yarn]
files = ["init/node/common", "init/node/yarn"]
pre_cmd = '''
    cp -r {common,yarn}/* .
'''
cmd = "flox init --auto-setup"

[init.python_poetry]
files = ["init/python/common", "init/python/poetry"]
pre_cmd = '''
    cp -r {common,poetry}/* .
'''
cmd = "flox init --auto-setup"

[init.python_poetry_zlib]
files = ["init/python/common", "init/python/poetry"]
pre_cmd = '''
    cp -r {common,poetry}/* .
    flox init --auto-setup
'''
cmd = "flox install zlib"

[init.python_pyproject_pip]
files = ["init/python/common", "init/python/pyproject-pip"]
pre_cmd = '''
    cp -r {common,pyproject-pip}/* .
'''
cmd = "flox init --auto-setup"

[init.python_pyproject_pip_zlib]
files = ["init/python/common", "init/python/pyproject-pip"]
pre_cmd = '''
    cp -r {common,pyproject-pip}/* .
    flox init --auto-setup
'''
cmd = "flox install zlib"

[init.python_requirements]
files = ["init/python/common", "init/python/requirements"]
pre_cmd = '''
    cp -r {common,requirements}/* .
'''
cmd = "flox init --auto-setup"

[init.python_requirements_zlib]
files = ["init/python/common", "init/python/requirements"]
pre_cmd = '''
    cp -r {common,requirements}/* .
    flox init --auto-setup
'''
cmd = "flox install zlib"

[init.python_requests]
pre_cmd = '''
    echo requests > requirements.txt
'''
cmd = "flox init --auto-setup"

[envs.kitchen_sink]
skip_if_output_exists = "envs/kitchen_sink"
files = ["envs/kitchen_sink/manifest.toml"]
pre_cmd = "flox init"
cmd = "flox edit -f manifest.toml"
post_cmd = '''
    envs_output_dir="$(dirname $RESPONSE_FILE)"
    env_dir="$envs_output_dir/kitchen_sink"
    mkdir -p "$env_dir"
    cp manifest.toml "$env_dir/manifest.toml"
    cp .flox/env/manifest.lock "$env_dir/manifest.lock"
    mv "$RESPONSE_FILE" "$env_dir/$(basename $RESPONSE_FILE)"
'''

[envs.krb5_prereqs]
skip_if_output_exists = "envs/krb5_prereqs"
files = ["envs/krb5_prereqs/manifest.toml"]
pre_cmd = "flox init"
cmd = "flox edit -f manifest.toml"
post_cmd = '''
    envs_output_dir="$(dirname $RESPONSE_FILE)"
    env_dir="$envs_output_dir/krb5_prereqs"
    mkdir -p "$env_dir"
    cp manifest.toml "$env_dir/manifest.toml"
    cp .flox/env/manifest.lock "$env_dir/manifest.lock"
    mv "$RESPONSE_FILE" "$env_dir/$(basename $RESPONSE_FILE)"
'''

[envs.build-noop]
skip_if_output_exists = "envs/build-noop"
pre_cmd = "flox init"
cmd = '''
echo '
version = 1
[build]
hello.command = "echo hello"
' | flox edit -f -
'''
post_cmd = '''
    envs_output_dir="$(dirname $RESPONSE_FILE)"
    env_dir="$envs_output_dir/build-noop"
    mkdir -p "$env_dir"
    cp .flox/env/manifest.toml "$env_dir/manifest.toml"
    cp .flox/env/manifest.lock "$env_dir/manifest.lock"
'''
