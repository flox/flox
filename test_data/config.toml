[vars]

################################################################################
# Resolve
################################################################################

[resolve]
failed_resolution = { pkgs = [ "definitely-not-a-package" ], ignore_errors = true }
almonds.pkgs = [ "almonds" ]
# Install a package that doesn't exist and that doesn't have suggestions
badpkg = { pkgs = [ "badpkg" ], ignore_errors = true }
# Install multiple packages that don't exist
badpkg1_badpkg2 = { pkgs = [ "badpkg1", "badpkg2" ], ignore_errors = true }
# Install a package that doesn't exist and a another that does only exist on Linux
badpkg_bpftrace = { pkgs = [ "badpkg", "bpftrace" ], ignore_errors = true }
# Install a package that only exists on Linux
bpftrace.pkgs = [ "bpftrace" ]
# Install multiple packages that only exist on Linux
bpftrace_systemd = { pkgs = [ "bpftrace", "systemd" ], ignore_errors = true }
curl_hello.pkgs = [ "curl", "hello" ]
emacs.pkgs = [ "emacs" ]
emacs_vim.pkgs = [ "emacs", "vim" ]
gzip.pkgs = [ "gzip" ]
influxdb2.pkgs = [ "influxdb2" ]
daemonize.pkgs = [ "daemonize" ]
# This is used to trigger the "only install for some systems" code path
darwin_ps_all = { pkgs = [ "darwin.ps" ], ignore_errors = true }
fish_3_2_2.pkgs = [ "fish@3.2.2" ]
hello.pkgs = [ "hello" ]
hello_unfree.pkgs = [ "hello-unfree" ]
jupyterlabs_widgets.pkgs = [ "jupyter", "python312Packages.jupyterlab-widgets"]
jupyterlabs_git.pkgs = [ "jupyter", "python312Packages.jupyterlab-git"]
go.pkgs = [ "go" ]
# Attempts an install for a package that doesn't exist but that *does* have suggestions
node_suggestions = { pkgs = [ "node" ], ignore_errors = true }
old_node = { pkgs = [ "nodejs@14.16.1" ], ignore_errors = true }
package_suggestions = { pkgs = [ "package" ], ignore_errors = true }
python2.pkgs = [ "python2" ]
python3.pkgs = [ "python3" ]
python3_pip.pkgs = [ "-i", "pip", "python311Packages.pip", "python3" ]
"python311Packages.pip".pkgs = [ "python311Packages.pip" ]
redis.pkgs = [ "redis", "netcat" ]
"rubyPackages_3_2.rails".pkgs = [ "rubyPackages_3_2.rails" ]
rust-lib-src.pkgs = [ "rustPlatform.rustLibSrc" ]
tabula = { pkgs = [ "tabula" ], ignore_errors = true } # tabula is broken
torchvision-bin = { pkgs = [ "python311Packages.torchvision-bin" ], ignore_errors = true }
webmention_ripgrep_rails.pkgs = [ "-i", "foo", "rubyPackages_3_2.webmention", "ripgrep", "-i", "bar", "rubyPackages_3_2.rails"]
vim.pkgs = [ "vim" ]
vim-vim-full-conflict = { pkgs = [ "vim", "vim-full" ], ignore_errors = true } # packages conflict

[resolve.curl_hello_bumped_revs]
pkgs = [ "curl", "hello" ]
post_cmd = '''
    yq -r '.then.body' "$RESPONSE_FILE" > body.json
    # Update the page and revision but keep the same derivations.
    # This would fail to rebuild because the revs are faked.
    jq -c '
        .items[].page |= (
            (.page | .+ 123) as $newpage |
            .page = $newpage |
            .packages |= map(
                (.rev | .[0:-8] + "deadbeef") as $newrev |
                .rev_count = $newpage |
                .rev = $newrev |
                .locked_url |= sub("rev=.*"; "rev=" + $newrev)
            )
        )
    ' body.json > patched_body.json
    yq -y \
        --arg body "$(cat patched_body.json)" \
        'del(.then.header[] | select(.name == "content-length")) | .then.body = $body' \
        "$RESPONSE_FILE" > tmp.yaml
    mv tmp.yaml "$RESPONSE_FILE"
'''

[resolve.curl_after_hello]
pre_cmd = "flox install hello"
pkgs = [ "curl" ]

[resolve.glibc]
pre_cmd = '''
    tomlq --in-place --toml-output '.options.systems = [ "x86_64-linux" ]' .flox/env/manifest.toml
'''
pkgs = [ "glibc" ]
ignore_errors = true # build will fail on macos, that's fine

[resolve.glibc_incompatible]
pre_cmd = '''
    tomlq --in-place --toml-output '.options.systems = [ "x86_64-linux", "aarch64-darwin" ]' .flox/env/manifest.toml
'''
pkgs = [ "glibc" ]
ignore_errors = true # build will fail on macos, that's fine

[resolve.darwin_ps]
pre_cmd = '''
    tomlq --in-place --toml-output '.options.systems = [ "x86_64-darwin" ]' .flox/env/manifest.toml
'''
pkgs = [ "darwin.ps" ]
ignore_errors = true # build will fail on linux, that's fine

[resolve.darwin_ps_incompatible]
pre_cmd = '''
    tomlq --in-place --toml-output '.options.systems = [ "x86_64-darwin", "aarch64-linux" ]' .flox/env/manifest.toml
'''
pkgs = [ "darwin.ps" ]
ignore_errors = true # build will fail on linux, that's fine

# Generate a response with an "unkown" type of error.
# Instead of forcing an "unknown" type of error from the catalog server
# we trigger a general error response and then transform the error type
# and message to match to an "unknown" type of error,
# knowing that there is only 1 response.
[resolve.darwin_ps_incompatible_transform_error_to_unknown]
pre_cmd = '''
    tomlq --in-place --toml-output '.options.systems = [ "x86_64-darwin", "aarch64-linux" ]' .flox/env/manifest.toml
'''
pkgs = [ "darwin.ps" ]
post_cmd = '''
    yq -r '.then.body' "$RESPONSE_FILE" | \
        jq -c '
            .items[0].messages[].type |= "unknown" |
            .items[0].messages[].message |= "unknown message"
        ' \
        > patched_body.json
    yq -y \
        --arg body "$(cat patched_body.json)" \
        'del(.then.header[] | select(.name == "content-length")) | .then.body = $body' \
        "$RESPONSE_FILE" > tmp.yaml
    mv tmp.yaml "$RESPONSE_FILE"
'''
ignore_errors = true # build will fail on linux, that's fine

# Generate a response with an "general" type of error.
# Instead of forcing an "general" type of error from the catalog server
# we trigger a general error response and then transform the error type
# and message to match to an "general" type of error,
# knowing that there is only 1 response.
[resolve.darwin_ps_incompatible_transform_error_to_general]
pre_cmd = '''
    tomlq --in-place --toml-output '.options.systems = [ "x86_64-darwin", "aarch64-linux" ]' .flox/env/manifest.toml
'''
pkgs = [ "darwin.ps" ]
post_cmd = '''
    yq -r '.then.body' "$RESPONSE_FILE" | \
        jq -c '
            .items[0].messages[].type |= "general" |
            .items[0].messages[].message |= "general message"
        ' \
        > patched_body.json
    yq -y \
        --arg body "$(cat patched_body.json)" \
        'del(.then.header[] | select(.name == "content-length")) | .then.body = $body' \
        "$RESPONSE_FILE" > tmp.yaml
    mv tmp.yaml "$RESPONSE_FILE"
'''
ignore_errors = true # build will fail on linux, that's fine

[resolve.old_hello]
pkgs = [ "hello" ]
post_cmd = '''
    yq -r '.then.body' "$RESPONSE_FILE" | \
        jq -c '
            .items[].page.packages |= map(
                .derivation = "/nix/store/AAA-hello-2.10.1.drv"
                | .version = "2.10.1"
            )
        ' \
        > patched_body.json
    yq -y \
        --arg body "$(cat patched_body.json)" \
        'del(.then.header[] | select(.name == "content-length")) | .then.body = $body' \
        "$RESPONSE_FILE" > tmp.yaml
    mv tmp.yaml "$RESPONSE_FILE"
'''

[resolve.old_linux_hello]
pkgs = [ "hello" ]
post_cmd = '''
    yq -r '.then.body' "$RESPONSE_FILE" | \
        jq -c '
            .items[].page.packages |= map(if .system | contains("linux")
            then .version = "2.10.1" | .derivation = "/nix/store/AAA-hello-2.10.1.drv"
            else .
            end)
        ' \
        > patched_body.json
    yq -y \
        --arg body "$(cat patched_body.json)" \
        'del(.then.header[] | select(.name == "content-length")) | .then.body = $body' \
        "$RESPONSE_FILE" > tmp.yaml
    mv tmp.yaml "$RESPONSE_FILE"
'''

[resolve.old_darwin_hello]
pkgs = [ "hello" ]
post_cmd = '''
    yq -r '.then.body' "$RESPONSE_FILE" | \
        jq -c '
            .items[].page.packages |= map(if .system | contains("darwin")
            then .version = "2.10.1" | .derivation = "/nix/store/AAA-hello-2.10.1.drv"
            else .
            end)
        ' \
        > patched_body.json
    yq -y \
        --arg body "$(cat patched_body.json)" \
        'del(.then.header[] | select(.name == "content-length")) | .then.body = $body' \
        "$RESPONSE_FILE" > tmp.yaml
    mv tmp.yaml "$RESPONSE_FILE"
'''

[resolve.hello_buggy_unfree_server_response]
pre_cmd = '''
    tomlq --in-place --toml-output '.options.allow.unfree = false' .flox/env/manifest.toml
'''
pkgs = [ "hello" ]
post_cmd = '''
    yq -r '.then.body' "$RESPONSE_FILE" | \
        jq -c '
            .items[].page.packages[].unfree |= true
        ' \
        > patched_body.json
    yq -y \
        --arg body "$(cat patched_body.json)" \
        'del(.then.header[] | select(.name == "content-length")) | .then.body = $body' \
        "$RESPONSE_FILE" > tmp.yaml
    mv tmp.yaml "$RESPONSE_FILE"
'''

# resolve.tabula_allowed is likely redundant and at least for the time being
# generates the same JSON as resolve.tabula.
# But broken is included in the resolution request,
# so include it here in case the server changes behavior.
[resolve.tabula_allowed]
pre_cmd = '''
    tomlq --in-place --toml-output '.options.allow.broken = true' .flox/env/manifest.toml
'''
pkgs = [ "tabula" ]

################################################################################
# Search
################################################################################

[search]
hello.query = "hello"
python.query = "python"
surely_doesnt_exist = { query = "surely_doesnt_exist", ignore_errors = true }
ello_all = { query = "ello", all = true }
java_suggestions.query = "java"

[search.exactly_ten]
query = "python"
post_cmd = '''
    yq -r '.then.body' "$RESPONSE_FILE" | \
        jq -c '
            {"total_count": 10, "items": .items[:10]}
        ' \
        > patched_body.json
    yq -y \
        --arg body "$(cat patched_body.json)" \
        'del(.then.header[] | select(.name == "content-length")) | .then.body = $body' \
        "$RESPONSE_FILE" > tmp.yaml
    mv tmp.yaml "$RESPONSE_FILE"
'''

################################################################################
# Show
################################################################################

[show]
hello.query = "hello"
flask.query = "python310Packages.flask"

################################################################################
# Init
################################################################################

[init.go]
unpack_dir_contents = [ "init/go/common", "init/go/module" ]
auto_setup = true

[init.nodejs_20]
unpack_dir_contents = [ "init/node/nodejs_20" ]
auto_setup = true

[init.nodejs_lt_24]
unpack_dir_contents = [ "init/node/nodejs_lt_24" ]
auto_setup = true

[init.node_npm]
unpack_dir_contents = [ "init/node/npm" ]
auto_setup = true

[init.yarn_1x]
unpack_dir_contents = [ "init/node/yarn_1x" ]
auto_setup = true

[init.yarn_berry]
unpack_dir_contents = [ "init/node/yarn_berry" ]
auto_setup = true

[init.python_poetry]
unpack_dir_contents = ["init/python/common", "init/python/poetry"]
auto_setup = true

[init.python_pyproject_pip]
unpack_dir_contents = ["init/python/common", "init/python/pyproject-pip"]
auto_setup = true

[init.python_requirements]
unpack_dir_contents = ["init/python/common", "init/python/requirements"]
auto_setup = true

[init.python_requests]
pre_cmd = '''
    echo "requests" > requirements.txt
'''
auto_setup = true

################################################################################
# Envs
################################################################################

[env]
go_gcc.manifest = "go_gcc.toml"
gcc_boost.manifest = "gcc_boost.toml"
kitchen_sink.manifest = "kitchen_sink.toml"
krb5_prereqs.manifest = "krb5_prereqs.toml"
hello_other_pkg_group.manifest = "hello_other_pkg_group.toml"
hello_as_greeting.manifest = "hello_as_greeting.toml"
hello_and_htop_for_no_system.manifest = "hello_and_htop_for_no_system.toml"
influxdb2.manifest = "influxdb2.toml"
pip.manifest = "pip.toml"
build-noop.manifest = "build_noop.toml"
publish-simple.manifest = "publish_simple.toml"

################################################################################
# Lock
################################################################################

[lock]
hello-unfree-lock.manifest = "hello_unfree_lock.toml"
vim-vim-full-conflict.manifest = "vim_vim_full_conflict.toml"
vim-vim-full-conflict-resolved.manifest = "vim_vim_full_conflict_resolved.toml"
build-runtime-all-toplevel.manifest = "build_runtime_all_toplevel.toml"
build-runtime-packages-only-hello.manifest = "build_runtime_packages_only_hello.toml"
build-runtime-packages-not-toplevel.manifest = "build_runtime_packages_not_toplevel.toml"
build-runtime-packages-not-found.manifest = "build_runtime_packages_not_found.toml"

################################################################################
# Custom
################################################################################

[custom.empty]
pre_cmd = '''
cat > resp.yaml <<EOF
when:
then:
EOF
'''

[custom.krb5_after_prereqs_installed]
pre_cmd = '''
    flox init
    flox edit -f "$INPUT_DATA/manifests/krb5_prereqs.toml"
'''
record_cmd = '''
    flox install krb5
'''

[custom.ld_floxlib]
pre_cmd = '''
    flox init
'''
record_cmd = '''
    flox edit -f "$INPUT_DATA/manifests/ld_floxlib.toml"
'''
ignore_errors = true # don't know why, it has here before

[custom.python_poetry_zlib]
unpack_dir_contents = [ "init/python/common", "init/python/poetry" ]
pre_cmd = '''
    flox init --auto-setup
'''
record_cmd = '''
    flox install zlib
'''

[custom.python_pyproject_pip_zlib]
unpack_dir_contents = [ "init/python/common", "init/python/pyproject-pip" ]
pre_cmd = '''
    flox init --auto-setup
'''
record_cmd = '''
    flox install zlib
'''

[custom.python_requirements_zlib]
unpack_dir_contents = [ "init/python/common", "init/python/requirements" ]
pre_cmd = '''
    flox init --auto-setup
'''
record_cmd = '''
    flox install zlib
'''

# I think the only way this is different from resolve.hello is that you get
# the manifest and lockfile
[custom.hello]
pre_cmd = '''
    flox init
'''
record_cmd = '''
    flox install hello
'''

[custom.heredocs]
pre_cmd = '''
    flox init
'''
record_cmd = '''
    flox edit -f "$INPUT_DATA/manifests/heredocs.toml"
'''
