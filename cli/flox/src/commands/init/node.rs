use std::fs;
use std::path::Path;

use anyhow::{anyhow, Result};
use flox_rust_sdk::flox::Flox;
use flox_rust_sdk::models::environment::path_environment::InitCustomization;
use flox_rust_sdk::models::manifest::CatalogPackage;
use flox_rust_sdk::utils::traceable_path;
use indoc::{formatdoc, indoc};
use semver::VersionReq;

use super::{
    format_customization,
    get_default_package,
    get_default_package_if_compatible,
    try_find_compatible_version,
    InitHook,
    ProvidedPackage,
    AUTO_SETUP_HINT,
};
use crate::utils::dialog::{Dialog, Select};
use crate::utils::message;

const NPM_HOOK: &str = indoc! {"
                # Install nodejs depedencies
                npm install"};

const YARN_HOOK: &str = indoc! {"
                # Install nodejs depedencies
                yarn"};

/// The general flow of the node hook is:
///
/// - [Self::new]: Calculate a [NodeAction]
/// - [Self::prompt_user]: If the action is [NodeAction::InstallYarnOrNode],
///   set it to one of [NodeAction::InstallNode] or [NodeAction::InstallYarn].
///   Otherwise, just return true or false based on whether the user wants the
///   customization.
/// - [Self::get_init_customization]: Return a customization based on [Self::action]
#[derive(Debug, Clone)]
pub(super) struct Node {
    /// Stores what customization should be generated by
    /// [Self::get_init_customization].
    ///
    /// Initialized in [Self::new] and potentially modified by [Self::prompt_user].
    action: NodeInstallAction,
    /// This is initialized in [Self::new] and currently only used by
    /// [Self::nodejs_message_and_version]
    /// TODO: should this be stored on [NodeAction::InstallNode]?
    ///
    /// Node version as specified in package.json if it exists
    /// If action is set to [NodeAction::InstallYarn], this is left
    /// uninitialized as [None].
    package_json_node_version: Option<PackageJSONVersion>,
    /// This is initialized in [Self::new] and currently only used by
    /// [Self::nodejs_message_and_version]
    /// TODO: should this be stored on [NodeAction::InstallNode]?
    ///
    /// Node version as specified in .nvmrc if it exists
    /// If action is set to [NodeAction::InstallYarn], this is left
    /// uninitialized as [None].
    nvmrc_version: Option<NVMRCVersion>,
}

/// Information about the version specifier found in the `.nvmrc` file
#[derive(Debug, PartialEq)]
enum RequestedNVMRCVersion {
    /// .nvmrc not present or empty
    None,
    /// .nvmrc contains an alias or something we can't parse as a version.
    Unsure,
    /// The version specifier in the .nvmrc file
    Found(String),
}

/// Information about the result of finding a node version compatible with what the `.nvmrc` file
/// requested
#[derive(Debug, Clone)]
enum NVMRCVersion {
    /// .nvmrc contains a version, but flox doesn't provide it.
    Unavailable,
    /// .nvmrc contains an alias or something we can't parse as a version.
    Unsure,
    /// An available version of nodejs that matches the version specifier in the .nvmrc file
    Found(ProvidedPackage),
}

#[derive(Debug, Clone)]
enum PackageJSONVersion {
    /// package.json exists but doesn't specify a version
    Unspecified,
    /// package.json specifies a version, but flox can't provide it
    Unavailable,
    /// package.json specifies a version,
    /// and we found a search result satisfying that version constraint
    Found(ProvidedPackage),
}

/// Which node and yarn versions to install together
#[derive(Clone, Debug, PartialEq)]
struct YarnInstall {
    yarn: ProvidedPackage,
    node: ProvidedPackage,
}

/// Which node version to install if desired
#[derive(Debug, Clone)]
struct NodeInstall {
    node: Option<ProvidedPackage>,
    npm_hook: bool,
}

/// Which node ecosystem packages to install
#[derive(Debug, Clone)]
enum NodeInstallAction {
    Yarn(YarnInstall),
    YarnOrNode(YarnInstall, NodeInstall),
    Node(NodeInstall),
}

struct PackageJSONVersions {
    yarn: Option<String>,
    node: Option<String>,
}

impl Node {
    /// Determine the [NodeAction] that should be taken by the node hook
    ///
    /// This method:
    /// - Returns [NodeAction::InstallYarn] if
    ///   - package.json and yarn.lock exist
    ///   - We can find nodejs and yarn packages compatible with package.json
    ///     engines
    ///   - package-lock.json does not exist
    /// - Returns [NodeAction::InstallNode] if
    ///   - .nvmrc or package.json exists
    ///   - We can find nodejs compatible with package.json engines
    ///     (.nvmrc is respected if possible,
    ///     but we offer an alternative even if we can't satisfy its
    ///     constraints)
    ///   - yarn.lock does not exist
    /// - Returns [NodeAction::InstallYarnOrNode] if
    ///   - Constraints for yarn and constraints for nodejs are met
    /// - Returns [None] if
    ///   - There's no package.json or .nvmrc
    ///   - We can't satisfy constraints in package.json
    pub async fn new(flox: &Flox, path: &Path) -> Result<Option<Self>> {
        // Check for a viable yarn
        // TODO: we should check for npm version as well,
        // but since npm comes bundled with nodejs, we'll probably cover the most
        // cases by just giving the requested node and hoping for the bundled
        // npm to work.
        // We could check if our one version of npm with its harcoded nodejs
        // satisfies all constraints,
        // but that seems unlikely to be as commonly needed.
        let versions = Self::get_package_json_versions(path)?;
        let yarn_lock_path = path.join("yarn.lock");
        let yarn_lock_exists = yarn_lock_path.exists();
        let yarn_install = match versions {
            None => None,
            Some(ref versions) => {
                if yarn_lock_exists {
                    tracing::debug!(path = traceable_path(&yarn_lock_path), "found yarn.lock");
                    Self::try_find_compatible_yarn(flox, versions).await?
                } else {
                    tracing::debug!(
                        path = traceable_path(&yarn_lock_path),
                        "did not find a yarn.lock at this location"
                    );
                    None
                }
            },
        };

        let valid_package_json = versions.is_some();
        let package_json_and_package_lock =
            valid_package_json && path.join("package-lock.json").exists();

        // If there's not both a package.json and a package-lock.json, return
        // early with just yarn
        if let Some(yarn_install) = &yarn_install {
            if !package_json_and_package_lock {
                return Ok(Some(Self {
                    action: NodeInstallAction::Yarn(yarn_install.clone()),
                    package_json_node_version: None,
                    nvmrc_version: None,
                }));
            }
        }

        // Get value for self.package_json_node_version.
        // We only do this if we didn't return early with action [NodeAction::YarnInstall]
        let package_json_node_version = match versions {
            Some(PackageJSONVersions {
                node: Some(ref node_version),
                ..
            }) => match try_find_compatible_version(flox, "nodejs", node_version).await? {
                None => Some(PackageJSONVersion::Unavailable),
                Some(result) => Some(PackageJSONVersion::Found(result)),
            },
            Some(_) => Some(PackageJSONVersion::Unspecified),
            _ => None,
        };

        // Get value for self.nvmrc_version
        // We only do this if we didn't return early with action [NodeAction::YarnInstall]
        let nvmrc_version = match package_json_node_version {
            // package.json is higher priority than .nvmrc,
            // so don't check .nvmrc if we know we'll use the version in
            // package.json or we know we can't provide it
            Some(PackageJSONVersion::Found(_)) | Some(PackageJSONVersion::Unavailable) => None,
            _ => Self::get_nvmrc_version(flox, path).await?,
        };

        let action = match yarn_install {
            Some(yarn_install) => {
                Self::get_node_install(
                    &package_json_node_version,
                    &nvmrc_version,
                    valid_package_json,
                )
                .map_or(
                    Some(NodeInstallAction::Yarn(yarn_install.clone())),
                    |node_install| {
                        // We know at this point that package-lock.json exists,
                        // because otherwise we would have returned above
                        Some(NodeInstallAction::YarnOrNode(yarn_install, node_install))
                    },
                )
            },
            None => {
                Self::get_node_install(
                    &package_json_node_version,
                    &nvmrc_version,
                    valid_package_json,
                )
                .map(|mut node_install| {
                    // If yarn.lock exists but we couldn't find a compatible
                    // yarn, don't offer an npm hook
                    if yarn_lock_exists {
                        node_install.npm_hook = false;
                    }
                    NodeInstallAction::Node(node_install)
                })
            },
        };

        Ok(action.map(|action| Self {
            package_json_node_version,
            nvmrc_version,
            action,
        }))
    }

    /// Look for nodejs, npm, and yarn versions in a (possibly non-existent)
    /// `package.json` file
    fn get_package_json_versions(path: &Path) -> Result<Option<PackageJSONVersions>> {
        let package_json = path.join("package.json");
        if !package_json.exists() {
            tracing::debug!(
                path = traceable_path(&package_json),
                "did not find a package.json at this location"
            );
            return Ok(None);
        }
        tracing::debug!(path = traceable_path(&package_json), "found a package.json");
        let package_json_contents = fs::read_to_string(package_json)?;
        match serde_json::from_str::<serde_json::Value>(&package_json_contents) {
            // Treat a package.json that can't be parsed as JSON the same as it not existing
            Err(_) => Ok(None),
            Ok(package_json_json) => {
                let node = package_json_json["engines"]["node"]
                    .as_str()
                    .map(|s| s.to_string());
                let yarn = package_json_json["engines"]["yarn"]
                    .as_str()
                    .map(|s| s.to_string());
                Ok(Some(PackageJSONVersions { node, yarn }))
            },
        }
    }

    /// Try to find node, npm, and yarn versions that satisfy constraints in
    /// package.json
    async fn try_find_compatible_yarn(
        flox: &Flox,
        versions: &PackageJSONVersions,
    ) -> Result<Option<YarnInstall>> {
        let PackageJSONVersions { yarn, node, .. } = versions;

        let found_node = match node {
            Some(node_version) => {
                match get_default_package_if_compatible(
                    flox,
                    vec!["nodejs".to_string()],
                    Some(node_version.clone()),
                )
                .await?
                {
                    // If the corresponding node isn't compatible, don't install yarn
                    None => return Ok(None),
                    Some(found_node) => found_node,
                }
            },
            None => get_default_package_if_compatible(flox, vec!["nodejs".to_string()], None)
                .await?
                .ok_or(anyhow!("Flox couldn't find nodejs in nixpkgs"))?,
        };

        // We assume that yarn is built with found_node, which is currently true
        // in nixpkgs
        let found_yarn: Option<ProvidedPackage> = match yarn {
            Some(yarn_version) => try_find_compatible_version(flox, "yarn", yarn_version).await?,
            _ => Some(get_default_package(flox, &"yarn".into()).await?),
        };

        Ok(found_yarn.map(|found_yarn| YarnInstall {
            yarn: found_yarn,
            node: found_node,
        }))
    }

    /// Determine appropriate [NVMRCVersion] variant for a (possibly
    /// non-existent) `.nvmrc` file in `path`.
    ///
    /// This will perform a search to determine if a requested version is
    /// available.
    async fn get_nvmrc_version(flox: &Flox, path: &Path) -> Result<Option<NVMRCVersion>> {
        let nvmrc = path.join(".nvmrc");
        if !nvmrc.exists() {
            return Ok(None);
        }

        let nvmrc_contents = fs::read_to_string(&nvmrc)?;
        let nvmrc_version = match Self::parse_nvmrc_version(&nvmrc_contents) {
            RequestedNVMRCVersion::None => None,
            RequestedNVMRCVersion::Unsure => Some(NVMRCVersion::Unsure),
            RequestedNVMRCVersion::Found(version) => {
                match try_find_compatible_version(flox, "nodejs", &version).await? {
                    None => Some(NVMRCVersion::Unavailable),
                    Some(result) => Some(NVMRCVersion::Found(result)),
                }
            },
        };
        Ok(nvmrc_version)
    }

    /// Translate the contents of a `.nvmrc` file into a [RequestedNVMRCVersion]
    fn parse_nvmrc_version(nvmrc_contents: &str) -> RequestedNVMRCVersion {
        // When reading from a file, nvm runs:
        // "$(command head -n 1 "${NVMRC_PATH}" | command tr -d '\r')" || command printf ''
        // https://github.com/nvm-sh/nvm/blob/294ff9e3aa8ce02bbf8d83fa235a363d9560a179/nvm.sh#L481
        let first_line = nvmrc_contents.lines().next();
        // From nvm --help:
        // <version> refers to any version-like string nvm understands. This includes:
        //   - full or partial version numbers, starting with an optional "v" (0.10, v0.1.2, v1)
        //   - default (built-in) aliases: node, stable, unstable, iojs, system
        //   - custom aliases you define with `nvm alias foo`
        match first_line {
            None => RequestedNVMRCVersion::None,
            Some(first_line) => {
                // nvm will fail if there's trailing whitespace,
                // so trimming whitespace is technically inconsistent,
                // but it's still probably a good recommendation from flox.
                let trimmed_first_line = first_line.trim();
                match trimmed_first_line {
                    "" => RequestedNVMRCVersion::None,
                    "node" | "stable" | "unstable" | "iojs" | "system" => {
                        RequestedNVMRCVersion::Unsure
                    },
                    _ if trimmed_first_line.starts_with('v')
                        && VersionReq::parse(&trimmed_first_line[1..]).is_ok() =>
                    {
                        RequestedNVMRCVersion::Found(trimmed_first_line[1..].to_string())
                    },
                    _ if VersionReq::parse(trimmed_first_line).is_ok() => {
                        RequestedNVMRCVersion::Found(trimmed_first_line.to_string())
                    },
                    _ => RequestedNVMRCVersion::Unsure,
                }
            },
        }
    }

    /// Return whether to skip the nodejs hook entirely, install a requested
    /// version of nodejs, or offer to install the Flox default version of
    /// nodejs.
    ///
    /// This is decided based on whether .nvmrc and package.json are present,
    /// and whether Flox can provide versions they request.
    fn get_node_install(
        package_json_node_version: &Option<PackageJSONVersion>,
        nvmrc_version: &Option<NVMRCVersion>,
        npm_hook: bool,
    ) -> Option<NodeInstall> {
        match (package_json_node_version, nvmrc_version) {
            // package.json takes precedence over .nvmrc
            (Some(PackageJSONVersion::Found(package)), _) => Some(NodeInstall {
                node: Some(package.clone()),
                npm_hook,
            }),
            // Treat the version in package.json strictly; if we can't find it, don't suggest something else.
            (Some(PackageJSONVersion::Unavailable), _) => None,
            (_, Some(NVMRCVersion::Found(package))) => Some(NodeInstall {
                node: Some(package.clone()),
                npm_hook,
            }),
            (_, Some(NVMRCVersion::Unsure)) => Some(NodeInstall {
                node: None,
                npm_hook,
            }),
            (_, Some(NVMRCVersion::Unavailable)) => Some(NodeInstall {
                node: None,
                npm_hook,
            }),
            (Some(PackageJSONVersion::Unspecified), None) => Some(NodeInstall {
                node: None,
                npm_hook,
            }),
            (None, None) => None,
        }
    }

    /// Returns:
    /// 1. A message describing what version of nodejs Flox found requested to
    ///    include in the prompt.
    /// 2. The version of nodejs Flox would install
    /// 3. Whether the message says Flox detected package.json (to avoid
    ///    printing that message twice)
    async fn nodejs_message_and_version(
        &self,
        flox: &Flox,
    ) -> Result<(String, Option<String>, bool)> {
        let mut mentions_package_json = false;
        let (message, version) = match (
            &self.package_json_node_version,
            self.nvmrc_version.as_ref(),
        ) {
            // package.json takes precedence over .nvmrc
            (Some(PackageJSONVersion::Found(result)), _) => {
                let message = format!(
                    "Flox detected a package.json compatible with node{}",
                    Self::format_version_or_empty(result.version.as_ref())
                );
                mentions_package_json = true;
                (message, result.version.clone())
            },
            // Treat the version in package.json strictly; if we can't find it, don't suggest something else.
            // get_action() returns NodeAction::Nothing for this case so it's unreachable
            (Some(PackageJSONVersion::Unavailable), _) => unreachable!(),
            (_, Some(NVMRCVersion::Found(result))) => {
                let message = format!(
                    "Flox detected an .nvmrc{}",
                    Self::format_version_or_empty(result.version.as_ref())
                );
                (message, result.version.clone())
            },
            (_, Some(NVMRCVersion::Unsure)) => {
                let result = get_default_package(flox, &"nodejs".into()).await?;
                let message = format!("Flox detected an .nvmrc with a version specifier not understood by Flox, but Flox can provide {}",
                       result.version.as_ref().map(|version|format!("version {version}")).unwrap_or("another version".to_string()));
                (message, result.version)
            },
            (_, Some(NVMRCVersion::Unavailable)) => {
                let result = get_default_package(flox, &"nodejs".into()).await?;
                let message = format!("Flox detected an .nvmrc with a version of nodejs not provided by Flox, but Flox can provide {}",
                result.version.as_ref().map(|version|format!("version {version}")).unwrap_or("another version".to_string()));
                (message, result.version.clone())
            },
            (Some(PackageJSONVersion::Unspecified), None) => {
                let result = get_default_package(flox, &"nodejs".into()).await?;
                mentions_package_json = true;
                ("Flox detected a package.json".to_string(), result.version)
            },
            // get_action() returns NodeAction::Nothing for this case so it's unreachable
            (None, None) => unreachable!(),
        };
        Ok((message, version, mentions_package_json))
    }

    /// Helper function for [Self::prompt_with_node] and [Self::prompt_with_yarn]
    fn single_option_prompt(&self) -> Result<bool> {
        let message = indoc! {
        "Would you like Flox to apply this suggestion?
        You can always change the environment's manifest with 'flox edit'"};

        let dialog = Dialog {
            message,
            help_message: Some(AUTO_SETUP_HINT),
            typed: Select {
                options: ["Yes", "No", "Show suggested modifications"].to_vec(),
            },
        };
        let (mut choice, _) = dialog.clone().raw_prompt()?;

        while choice == 2 {
            message::plain(format_customization(&self.get_init_customization())?);

            (choice, _) = dialog.clone().raw_prompt()?;
        }

        Ok(choice == 0)
    }

    /// Prompt whether to install nodejs (but not npm or yarn)
    async fn prompt_with_node(&self, flox: &Flox, node_install: &NodeInstall) -> Result<bool> {
        let (nodejs_detected, nodejs_version, mentions_package_json) =
            self.nodejs_message_and_version(flox).await?;
        let mut detected = format!("{nodejs_detected}\n");
        if node_install.npm_hook {
            if !mentions_package_json {
                detected.push_str("Flox detected a package.json\n");
            }

            detected.push_str(&formatdoc! {"

                Flox can add the following to your environment:
                * nodejs{} with npm bundled
                * An npm installation hook
            ",
                Self::format_version_or_empty(nodejs_version.as_ref()),
            });
        } else {
            detected.push_str(&formatdoc! {"

                Flox can add the following to your environment:
                * nodejs{}
            ",
                Self::format_version_or_empty(nodejs_version.as_ref()),
            });
        }
        message::plain(detected);

        self.single_option_prompt()
    }

    /// Prompt whether to install yarn
    fn prompt_with_yarn(&self, yarn_install: &YarnInstall) -> Result<bool> {
        let yarn_version = Self::format_version_or_empty(yarn_install.yarn.version.as_ref());
        let node_version = Self::format_version_or_empty(yarn_install.node.version.as_ref());

        message::plain(formatdoc! {"
            Flox detected a package.json and a yarn.lock

            Flox can add the following to your environment:
            * yarn{yarn_version} with nodejs{node_version} bundled
            * A yarn installation hook
            "});

        self.single_option_prompt()
    }

    /// Prompt whether to install npm or yarn when either is viable
    async fn prompt_for_package_manager(
        &mut self,
        flox: &Flox,
        yarn_install: YarnInstall,
        node_install: NodeInstall,
    ) -> Result<bool> {
        let yarn_version = Self::format_version_or_empty(yarn_install.yarn.version.as_ref());
        let yarn_node_version = Self::format_version_or_empty(yarn_install.node.version.as_ref());
        let node_version = Self::format_version_or_empty(
            match &node_install.node {
                Some(found_node) => found_node.clone(),
                None => get_default_package(flox, &"nodejs".into()).await?,
            }
            .version
            .as_ref(),
        );

        message::plain(formatdoc! {"
            Flox detected both a package-lock.json and a yarn.lock

            Flox can add the following to your environment:
            * Either nodejs{node_version} with npm bundled, OR yarn{yarn_version} with nodejs{yarn_node_version} bundled
            * Either an npm installation hook, OR a yarn installation hook
            "});
        let message = formatdoc! {
        "Would you like Flox to apply one of these modifications?
         You can always change the environment's manifest with 'flox edit'"};
        let options = [
            "Yes - with npm",
            "Yes - with yarn",
            "No",
            "Show modifications with npm",
            "Show modifications with yarn",
        ]
        .to_vec();

        let dialog = Dialog {
            message: &message,
            help_message: Some(AUTO_SETUP_HINT),
            typed: Select {
                options: options.clone(),
            },
        };

        let (mut choice, _) = dialog.clone().raw_prompt()?;

        while choice == 3 || choice == 4 {
            // Temporarily set choice so self.get_init_customization() returns
            // the correct hook
            if choice == 3 {
                self.action = NodeInstallAction::Node(node_install.clone())
            } else if choice == 4 {
                self.action = NodeInstallAction::Yarn(yarn_install.clone())
            }
            message::plain(format_customization(&self.get_init_customization())?);

            (choice, _) = dialog.clone().raw_prompt()?;
        }

        if choice == 0 {
            self.action = NodeInstallAction::Node(node_install.clone())
        } else if choice == 1 {
            self.action = NodeInstallAction::Yarn(yarn_install.clone())
        }
        Ok(choice == 0 || choice == 1)
    }

    fn format_version_or_empty(version: Option<&String>) -> String {
        version
            .map(|version| format!(" {version}"))
            .unwrap_or("".to_string())
    }
}

impl InitHook for Node {
    async fn prompt_user(&mut self, flox: &Flox, _path: &Path) -> Result<bool> {
        match &self.action {
            NodeInstallAction::Yarn(yarn_install) => self.prompt_with_yarn(yarn_install),
            NodeInstallAction::YarnOrNode(yarn_install, node_install) => {
                self.prompt_for_package_manager(flox, yarn_install.clone(), node_install.clone())
                    .await
            },
            NodeInstallAction::Node(node_install) => {
                self.prompt_with_node(flox, node_install).await
            },
        }
    }

    fn get_init_customization(&self) -> InitCustomization {
        let mut packages = vec![];

        let hook_on_activate = match &self.action {
            NodeInstallAction::Yarn(yarn_install) => {
                packages.push(CatalogPackage {
                    id: "yarn".to_string(),
                    pkg_path: yarn_install.yarn.rel_path.clone().into(),
                    // TODO: we probably shouldn't pin this when we're just
                    // providing the default
                    version: yarn_install.yarn.version.clone(),
                    systems: None,
                });
                Some(YARN_HOOK.to_string())
            },
            // Default to node for InstallYarnOrNode
            // This is only reachable if --auto-setup is used.
            NodeInstallAction::YarnOrNode(_, node_install)
            | NodeInstallAction::Node(node_install) => {
                let nodejs_to_install = match &node_install.node {
                    Some(result) => CatalogPackage {
                        id: "nodejs".to_string(),
                        pkg_path: result.rel_path.clone().into(),
                        version: result.version.clone(),
                        systems: None,
                    },
                    None => CatalogPackage {
                        id: "nodejs".to_string(),
                        pkg_path: "nodejs".to_string(),
                        version: None,
                        systems: None,
                    },
                };
                packages.push(nodejs_to_install);
                if node_install.npm_hook {
                    Some(NPM_HOOK.to_string())
                } else {
                    None
                }
            },
        };

        InitCustomization {
            hook_on_activate,
            profile_common: None,
            profile_bash: None,
            profile_fish: None,
            profile_tcsh: None,
            profile_zsh: None,
            packages: Some(packages),
        }
    }
}

#[cfg(test)]
mod tests {
    use flox_rust_sdk::data::System;
    use flox_rust_sdk::flox::test_helpers::flox_instance;
    use flox_rust_sdk::providers::catalog::test_helpers::resolved_pkg_group_with_dummy_package;
    use flox_rust_sdk::providers::catalog::Client;
    use pretty_assertions::assert_eq;

    use super::*;

    #[test]
    fn parse_nvmrc_version_some() {
        assert_eq!(
            Node::parse_nvmrc_version("v0.1.14"),
            RequestedNVMRCVersion::Found("0.1.14".to_string())
        );
        assert_eq!(
            Node::parse_nvmrc_version("v20.11.1"),
            RequestedNVMRCVersion::Found("20.11.1".to_string())
        );
        assert_eq!(
            Node::parse_nvmrc_version("0.1.14"),
            RequestedNVMRCVersion::Found("0.1.14".to_string())
        );
        assert_eq!(
            Node::parse_nvmrc_version("0"),
            RequestedNVMRCVersion::Found("0".to_string())
        );
        assert_eq!(
            Node::parse_nvmrc_version("0.1"),
            RequestedNVMRCVersion::Found("0.1".to_string())
        );
        assert_eq!(
            Node::parse_nvmrc_version("0.1.14\n"),
            RequestedNVMRCVersion::Found("0.1.14".to_string())
        );
        assert_eq!(
            Node::parse_nvmrc_version("0.1.14   "),
            RequestedNVMRCVersion::Found("0.1.14".to_string())
        );
    }

    #[test]
    fn parse_nvmrc_version_unsure() {
        assert_eq!(
            Node::parse_nvmrc_version("node"),
            RequestedNVMRCVersion::Unsure
        );
        assert_eq!(
            Node::parse_nvmrc_version("0.1.14 blah blah"),
            RequestedNVMRCVersion::Unsure
        );
    }

    #[test]
    fn parse_nvmrc_version_none() {
        assert_eq!(Node::parse_nvmrc_version(""), RequestedNVMRCVersion::None);
        assert_eq!(Node::parse_nvmrc_version("\n"), RequestedNVMRCVersion::None);
    }

    /// Test get_init_customization() for action InstallYarn
    #[test]
    fn get_init_customization_yarn() {
        assert_eq!(
            Node {
                package_json_node_version: None,
                nvmrc_version: None,
                action: NodeInstallAction::Yarn(YarnInstall {
                    yarn: ProvidedPackage {
                        rel_path: "yarn.path".into(),
                        version: Some("1".to_string()),
                        name: "yarn".to_string(),
                        display_version: "1".to_string(),
                    },
                    node: ProvidedPackage {
                        name: "nodejs".to_string(),
                        rel_path: "nodejs".into(),
                        display_version: "N/A".to_string(),
                        version: None
                    },
                }),
            }
            .get_init_customization(),
            InitCustomization {
                packages: Some(vec![CatalogPackage {
                    id: "yarn".to_string(),
                    pkg_path: "yarn.path".to_string(),
                    version: Some("1".to_string()),
                    systems: None,
                }]),
                hook_on_activate: Some(YARN_HOOK.to_string()),
                profile_common: None,
                profile_bash: None,
                profile_fish: None,
                profile_tcsh: None,
                profile_zsh: None,
            }
        );
    }

    /// Test get_init_customization() for action InstallYarnOrNode and npm_hook
    /// true
    #[test]
    fn get_init_customization_yarn_or_node() {
        assert_eq!(
            Node {
                package_json_node_version: None,
                nvmrc_version: None,
                action: NodeInstallAction::YarnOrNode(
                    YarnInstall {
                        yarn: ProvidedPackage {
                            name: "yarn".to_string(),
                            rel_path: "yarn".into(),
                            display_version: "N/A".to_string(),
                            version: None
                        },
                        node: ProvidedPackage {
                            name: "nodejs".to_string(),
                            rel_path: "nodejs".into(),
                            display_version: "N/A".to_string(),
                            version: None
                        },
                    },
                    NodeInstall {
                        node: Some(ProvidedPackage {
                            rel_path: "nodejs.path".into(),
                            version: Some("1".to_string()),
                            name: "nodejs".to_string(),
                            display_version: "1".to_string()
                        }),
                        npm_hook: true,
                    }
                ),
            }
            .get_init_customization(),
            InitCustomization {
                packages: Some(vec![CatalogPackage {
                    id: "nodejs".to_string(),
                    pkg_path: "nodejs.path".to_string(),
                    version: Some("1".to_string()),
                    systems: None,
                }]),
                hook_on_activate: Some(NPM_HOOK.to_string()),
                profile_common: None,
                profile_bash: None,
                profile_fish: None,
                profile_tcsh: None,
                profile_zsh: None,
            }
        );
    }
    /// Test get_init_customization() for action InstallNode and npm_hook false
    #[test]
    fn get_init_customization_node() {
        assert_eq!(
            Node {
                package_json_node_version: None,
                nvmrc_version: None,
                action: NodeInstallAction::Node(NodeInstall {
                    node: Some(ProvidedPackage {
                        rel_path: "nodejs.path".into(),
                        version: Some("1".to_string()),
                        name: "nodejs".to_string(),
                        display_version: "1".to_string()
                    }),
                    npm_hook: false,
                })
            }
            .get_init_customization(),
            InitCustomization {
                packages: Some(vec![CatalogPackage {
                    id: "nodejs".to_string(),
                    pkg_path: "nodejs.path".to_string(),
                    version: Some("1".to_string()),
                    systems: None,
                }]),
                hook_on_activate: None,
                profile_common: None,
                profile_bash: None,
                profile_fish: None,
                profile_tcsh: None,
                profile_zsh: None,
            }
        );
    }

    ///////////////////////////////////////////////////////////////////////////
    // Catalog tests
    ///////////////////////////////////////////////////////////////////////////

    /// Test finding yarn with no constraints succeeds
    #[tokio::test]
    async fn try_find_compatible_yarn_no_constraints_with_catalog() {
        let (mut flox, _temp_dir_handle) = flox_instance();

        if let Client::Mock(ref mut client) = flox.catalog_client {
            // Response for unconstrained nodejs version
            client.push_resolve_response(vec![resolved_pkg_group_with_dummy_package(
                "nodejs_group",
                &System::from("aarch64-darwin"),
                "nodejs",
                "nodejs",
                "18",
            )]);
            // Response for unconstrained yarn version
            client.push_resolve_response(vec![resolved_pkg_group_with_dummy_package(
                "yarn_group",
                &System::from("aarch64-darwin"),
                "yarn",
                "yarn",
                "1.22",
            )]);
        }
        let yarn_install = Node::try_find_compatible_yarn(&flox, &PackageJSONVersions {
            yarn: None,
            node: None,
        })
        .await
        .unwrap()
        .unwrap();

        assert_eq!(yarn_install.node.rel_path, "nodejs".into());
        assert_eq!(yarn_install.yarn.rel_path, "yarn".into());
    }

    /// Test finding yarn with the version of nixpkgs#nodejs specified succeeds
    #[tokio::test]
    async fn try_find_compatible_yarn_node_available_with_catalog() {
        let (mut flox, _temp_dir_handle) = flox_instance();

        if let Client::Mock(ref mut client) = flox.catalog_client {
            // Response when nodejs 18 is requested
            client.push_resolve_response(vec![resolved_pkg_group_with_dummy_package(
                "nodejs_group",
                &System::from("aarch64-darwin"),
                "nodejs",
                "nodejs",
                "18",
            )]);
            // Response for unconstrained yarn version
            client.push_resolve_response(vec![resolved_pkg_group_with_dummy_package(
                "yarn_group",
                &System::from("aarch64-darwin"),
                "yarn",
                "yarn",
                "1.22",
            )]);
        }
        let yarn_install = Node::try_find_compatible_yarn(&flox, &PackageJSONVersions {
            yarn: None,
            node: Some("18".to_string()),
        })
        .await
        .unwrap()
        .unwrap();

        assert_eq!(yarn_install.node.rel_path, "nodejs".into());
        assert!(yarn_install.node.version.unwrap().starts_with("18"));
        assert_eq!(yarn_install.yarn.rel_path, "yarn".into());
    }

    /// Test finding yarn with a version of node other than that of
    /// nixpkgs#nodejs fails
    #[tokio::test]
    async fn try_find_compatible_yarn_node_unavailable_with_catalog() {
        let (mut flox, _temp_dir_handle) = flox_instance();

        if let Client::Mock(ref mut client) = flox.catalog_client {
            // The default version is something other than "20",
            // so resolution fails and you get no groups back
            client.push_resolve_response(vec![]);
        }
        let yarn_install = Node::try_find_compatible_yarn(&flox, &PackageJSONVersions {
            yarn: None,
            node: Some("20".to_string()),
        })
        .await
        .unwrap();

        assert_eq!(yarn_install, None);
    }

    /// Test finding yarn with the version nixpkgs#yarn specified succeeds
    #[tokio::test]
    async fn try_find_compatible_yarn_yarn_available_with_catalog() {
        let (mut flox, _temp_dir_handle) = flox_instance();

        if let Client::Mock(ref mut client) = flox.catalog_client {
            // Response for unconstrained nodejs version
            client.push_resolve_response(vec![resolved_pkg_group_with_dummy_package(
                "nodejs_group",
                &System::from("aarch64-darwin"),
                "nodejs",
                "nodejs",
                "18",
            )]);
            // Reponse when yarn version 1 is requested
            client.push_resolve_response(vec![resolved_pkg_group_with_dummy_package(
                "yarn_group",
                &System::from("aarch64-darwin"),
                "yarn",
                "yarn",
                "1.22",
            )]);
        }
        let yarn_install = Node::try_find_compatible_yarn(&flox, &PackageJSONVersions {
            yarn: Some("1".to_string()),
            node: None,
        })
        .await
        .unwrap()
        .unwrap();

        assert_eq!(yarn_install.node.rel_path, "nodejs".into());
        assert_eq!(yarn_install.yarn.rel_path, "yarn".into());
        assert!(yarn_install.yarn.version.unwrap().starts_with('1'));
    }

    /// Test finding yarn with a version of yarn other than that of
    /// nixpkgs#yarn fails
    #[tokio::test]
    async fn try_find_compatible_yarn_yarn_unavailable_with_catalog() {
        let (mut flox, _temp_dir_handle) = flox_instance();

        if let Client::Mock(ref mut client) = flox.catalog_client {
            // Response for unconstrained nodejs version
            client.push_resolve_response(vec![resolved_pkg_group_with_dummy_package(
                "nodejs_group",
                &System::from("aarch64-darwin"),
                "nodejs",
                "nodejs",
                "18",
            )]);
            // Response for yarn version 2 (resolution failure)
            client.push_resolve_response(vec![]);
        }
        let yarn_install = Node::try_find_compatible_yarn(&flox, &PackageJSONVersions {
            yarn: Some("2".to_string()),
            node: None,
        })
        .await
        .unwrap();

        assert_eq!(yarn_install, None);
    }

    /// Test finding yarn with versions of nixpkgs#yarn and nixpkgs#nodejs
    /// specified succeeds
    #[tokio::test]
    async fn try_find_compatible_yarn_both_available_with_catalog() {
        let (mut flox, _temp_dir_handle) = flox_instance();

        if let Client::Mock(ref mut client) = flox.catalog_client {
            // Response for nodejs version 18
            client.push_resolve_response(vec![resolved_pkg_group_with_dummy_package(
                "nodejs_group",
                &System::from("aarch64-darwin"),
                "nodejs",
                "nodejs",
                "18",
            )]);
            // Response for yarn version 1
            client.push_resolve_response(vec![resolved_pkg_group_with_dummy_package(
                "yarn_group",
                &System::from("aarch64-darwin"),
                "yarn",
                "yarn",
                "1.22",
            )]);
        }
        let yarn_install = Node::try_find_compatible_yarn(&flox, &PackageJSONVersions {
            yarn: Some("1".to_string()),
            node: Some("18".to_string()),
        })
        .await
        .unwrap()
        .unwrap();

        assert_eq!(yarn_install.node.rel_path, "nodejs".into());
        assert!(yarn_install.node.version.unwrap().starts_with("18"));
        assert_eq!(yarn_install.yarn.rel_path, "yarn".into());
        assert!(yarn_install.yarn.version.unwrap().starts_with('1'));
    }
}
