use std::collections::HashMap;
use std::fs;
use std::path::Path;

use anyhow::{Context, Result};
use flox_core::traceable_path;
use flox_rust_sdk::flox::Flox;
use flox_rust_sdk::models::environment::path_environment::InitCustomization;
use flox_rust_sdk::models::manifest::raw::CatalogPackage;
use flox_rust_sdk::providers::catalog::{
    ALL_SYSTEMS,
    ClientTrait,
    PackageDescriptor,
    PackageGroup,
};
use indoc::{formatdoc, indoc};
use regex::Regex;
use semver::VersionReq;
use tracing::debug;

use super::{
    AUTO_SETUP_HINT,
    InitHook,
    ProvidedPackage,
    find_compatible_package,
    format_customization,
};
use crate::commands::init::try_find_compatible_major_version_package;
use crate::utils::dialog::{Dialog, Select};
use crate::utils::message;

const NPM_HOOK: &str = indoc! {"
                # Install nodejs dependencies
                npm install"};

const YARN_HOOK: &str = indoc! {"
                # Install nodejs dependencies
                yarn"};

/// The general flow of the node hook is:
///
/// - [Self::new]: Calculate a [NodeAction]
/// - [Self::prompt_user]: If the action is [NodeAction::InstallYarnOrNode],
///   set it to one of [NodeAction::InstallNode] or [NodeAction::InstallYarn].
///   Otherwise, just return true or false based on whether the user wants the
///   customization.
/// - [Self::get_init_customization]: Return a customization based on [Self::action]
#[derive(Debug, Clone, PartialEq)]
pub(super) struct Node {
    /// Stores what customization should be generated by
    /// [Self::get_init_customization].
    ///
    /// Initialized in [Self::new] and potentially modified by [Self::prompt_user].
    action: NodeInstallAction,
    /// This is initialized in [Self::new] and currently only used by
    /// [Self::nodejs_message_and_version]
    /// TODO: should this be stored on [NodeAction::InstallNode]?
    ///
    /// Node version as specified in package.json if it exists
    /// If action is set to [NodeAction::InstallYarn], this is left
    /// uninitialized as [None].
    package_json_node_version: Option<PackageJSONVersion>,
    /// This is initialized in [Self::new] and currently only used by
    /// [Self::nodejs_message_and_version]
    /// TODO: should this be stored on [NodeAction::InstallNode]?
    ///
    /// Node version as specified in .nvmrc if it exists
    /// If action is set to [NodeAction::InstallYarn], this is left
    /// uninitialized as [None].
    nvmrc_version: Option<NVMRCVersion>,
}

/// Information about the version specifier found in the `.nvmrc` file
#[derive(Debug, PartialEq)]
enum RequestedNVMRCVersion {
    /// .nvmrc not present or empty
    None,
    /// .nvmrc contains an alias or something we can't parse as a version.
    Unsure,
    /// The version specifier in the .nvmrc file
    Found(String),
}

/// Information about the result of finding a node version compatible with what the `.nvmrc` file
/// requested
#[derive(Debug, Clone, PartialEq)]
pub(crate) enum NVMRCVersion {
    /// .nvmrc exists but doesn't specify a version
    Unspecified,
    /// .nvmrc contains a version, but flox doesn't provide it.
    Unavailable,
    /// .nvmrc contains an alias or something we can't parse as a version.
    Unsure,
    /// An available version of nodejs that matches the version specifier in the .nvmrc file
    Found(ProvidedPackage),
}

#[derive(Debug, Clone, PartialEq)]
pub(crate) enum PackageJSONVersion {
    /// package.json exists but doesn't specify a version
    Unspecified,
    /// package.json specifies a version, but flox can't provide it
    Unavailable,
    /// package.json specifies a version,
    /// and we found a search result satisfying that version constraint
    Found(ProvidedPackage),
}

/// Which node and yarn versions to install together
#[derive(Clone, Debug, PartialEq)]
struct YarnAndNodeInstall {
    yarn: ProvidedPackage,
    node: ProvidedPackage,
}

/// Which yarn package to install
#[derive(Clone, Debug, PartialEq)]
struct YarnInstall {
    pkg: ProvidedPackage,
}

/// Which node version to install if desired
#[derive(Debug, Clone, PartialEq)]
struct NodeInstall {
    node: Option<ProvidedPackage>,
    npm_hook: bool,
}

/// Which node ecosystem packages to install
#[derive(Debug, Clone, PartialEq)]
enum NodeInstallAction {
    YarnAndNode(YarnAndNodeInstall),
    YarnOnly(YarnInstall),
    Node(NodeInstall),
}

/// Version strings extracted from `package.json` without any resolution against
/// catalog packages.
#[derive(Debug, Clone)]
struct PackageJSONVersionsUnresolved {
    yarn: Option<String>,
    node: Option<String>,
}

/// The collected context about the Node files in the project and
/// requested versions within them. This serves as the input to deciding
/// which packages to install.
#[derive(Debug)]
struct NodeCtx {
    /// The raw version requirements in a `package.json` file if it existed.
    package_json_versions: Option<PackageJSONVersionsUnresolved>,
    /// True when `yarn.lock` exists. It's an ambiguous state if both `yarn.lock`
    /// and `package-lock.json` exist.
    yarn_lock_exists: bool,
    /// True when `package-lock.json` exists. It's an ambiguous state if both
    /// `yarn.lock` and `package-lock.json` exist.
    package_lock_exists: bool,
    /// The raw contents of the `.nvmrc` file. We store this as a `Result`
    /// so that if an error occurs while reading it we don't bail immediately
    /// if it turns out we weren't going to need it.
    nvmrc_contents: Result<Option<String>>,
}

impl NodeCtx {
    /// Load all of the context about ecosystem files and versions.
    fn new(path: impl AsRef<Path>) -> Result<Self> {
        let path = path.as_ref();
        let package_json_path = path.join("package.json");
        let package_lock_path = path.join("package-lock.json");
        let yarn_lock_path = path.join("yarn.lock");
        let nvmrc_path = path.join(".nvmrc");

        let package_json_versions = Self::get_package_json_versions(&package_json_path)?;
        debug!(path = %package_json_path.display(), "read package.json");
        let yarn_lock_exists = yarn_lock_path.exists();
        debug!(path = %yarn_lock_path.display(), exists = yarn_lock_exists, "searched for yarn.lock");
        let package_lock_exists = package_lock_path.exists();
        debug!(path = %package_lock_path.display(), exists = package_lock_exists, "searched for package-lock.json");
        let nvmrc_contents = Self::get_nvmrc_version(&nvmrc_path);
        debug!(path = %nvmrc_path.display(), success = nvmrc_contents.is_ok(), "attempted read of .nvmrc");

        let ctx = Self {
            package_json_versions,
            yarn_lock_exists,
            package_lock_exists,
            nvmrc_contents,
        };
        Ok(ctx)
    }

    /// Look for nodejs and yarn versions in a (possibly non-existent)
    /// `package.json` file
    fn get_package_json_versions(
        package_json: &Path,
    ) -> Result<Option<PackageJSONVersionsUnresolved>> {
        if !package_json.exists() {
            tracing::debug!(
                path = traceable_path(&package_json),
                "did not find a package.json at this location"
            );
            return Ok(None);
        }
        tracing::debug!(path = traceable_path(&package_json), "found a package.json");
        let package_json_contents = fs::read_to_string(package_json)?;
        match serde_json::from_str::<serde_json::Value>(&package_json_contents) {
            // Treat a package.json that can't be parsed as JSON the same as it not existing
            Err(_) => {
                debug!("package.json not found or failed to parse");
                Ok(None)
            },
            Ok(package_json_json) => {
                let node = package_json_json["engines"]["node"]
                    .as_str()
                    .map(|s| s.to_string());
                let yarn = package_json_json["engines"]["yarn"]
                    .as_str()
                    .map(|s| s.to_string());
                debug!(
                    node = node.as_ref().unwrap_or(&"null".to_string()),
                    yarn = yarn.as_ref().unwrap_or(&"null".to_string()),
                    "read package.json"
                );
                Ok(Some(PackageJSONVersionsUnresolved { node, yarn }))
            },
        }
    }

    /// Look for a Node version specified in a possibly-nonexistent .nvmrc file.
    fn get_nvmrc_version(path: &Path) -> Result<Option<String>> {
        if !path.exists() {
            debug!(path = %path.display(), ".nvmrc didn't exist");
            return Ok(None);
        }

        let contents = fs::read_to_string(path);
        let debug_contents = contents
            .as_ref()
            .map(|s| s.as_str())
            .unwrap_or("read_error");
        debug!(contents = debug_contents, "read .nvmrc");

        contents.context("failed to read .nvmrc file").map(Some)
    }

    /// Returns whether this state is even valid before we start looking for
    /// compatible versions or trying to decide which packages to install.
    fn is_valid_state(&self) -> bool {
        // We need _some_ kind of information, and at the very least one of
        // these things will get you some kind of Node installation:
        // - A valid `package.json` even if it doesn't contain versions.
        // - The presence of a `yarn.lock` file.
        // - The presence of a `.nvmrc` file.
        //
        // TODO(zmitchell, 2025-08-01): the previous iteration of this setup
        // code didn't really use `package-lock.json` to inform whether we
        // were in a good state, so this doesn't either, but we may decide
        // to do that in the future.
        self.package_json_versions.is_some()
            || self.yarn_lock_exists
            || self.nvmrc_contents.as_ref().is_ok_and(|c| c.is_some())
    }

    /// Returns whether we should install both `yarn` and a matching `node`.
    fn should_install_yarn_and_node(&self) -> bool {
        // There may be some cases missing from this logic, but I *think* this
        // reproduces the existing behavior.
        self.yarn_lock_exists
            && self
                .package_json_versions
                .as_ref()
                .is_some_and(|versions| versions.yarn.is_some())
            && self
                .package_json_versions
                .as_ref()
                .is_some_and(|versions| versions.node.is_some())
            && !self.package_lock_exists
    }

    /// Returns whether we should install just `yarn` without `node`.
    fn should_install_yarn_only(&self) -> bool {
        // If both `yarn.lock` and `package-lock.json` exist, we're in an
        // ambiguous state since these files serve the same purpose.
        // It could mean that the user just left one of them around after
        // switching between package managers. In this ambiguous state
        // we defer to the `package-lock.json`
        self.yarn_lock_exists && self.package_json_versions.is_some() && !self.package_lock_exists
    }

    /// Returns whether we should only install `node`.
    fn should_install_node_only(&self) -> bool {
        // The bar here is pretty low
        self.package_json_versions.is_some()
            || self
                .nvmrc_contents
                .as_ref()
                .is_ok_and(|contents| contents.is_some())
    }
}

#[derive(Debug, Clone, PartialEq)]
pub(crate) enum NodeVersionSource {
    PackageJson(PackageJSONVersion),
    Nvmrc(NVMRCVersion),
}

impl NodeVersionSource {
    /// Returns the version string for the version we found and resolved
    /// if we did so successfully.
    fn version_found(&self) -> Option<String> {
        if let NodeVersionSource::PackageJson(PackageJSONVersion::Found(pkg)) = self {
            return pkg.version.clone();
        }
        if let NodeVersionSource::Nvmrc(NVMRCVersion::Found(pkg)) = self {
            return pkg.version.clone();
        }
        None
    }
}

impl Node {
    /// Reorders node packages so even (LTS) versions come before odd (Current) versions.
    ///
    /// Input: `["nodejs_23", "nodejs_22", "nodejs_21", "nodejs_20"]`
    /// Output: `["nodejs_22", "nodejs_20", "nodejs_23", "nodejs_21"]`
    ///
    /// Packages that don't match the `nodejs_XX` pattern are placed at the end.
    fn reorder_preferring_lts(packages: Vec<String>) -> Vec<String> {
        let (even, odd): (Vec<_>, Vec<_>) = packages.into_iter().partition(|pkg| {
            pkg.strip_prefix("nodejs_")
                .and_then(|v| v.parse::<u32>().ok())
                .map(|v| v % 2 == 0)
                .unwrap_or(false)
        });
        [even, odd].concat()
    }

    /// Determine the [NodeAction] that should be taken by the node hook.
    /// See tests for more information.
    pub async fn new(flox: &Flox, path: &Path) -> Result<Option<Self>> {
        // These are the files we care about:
        // - package.json: config file for npm/node
        // - package-lock.json: this person is using npm/node instead of yarn
        // - yarn.lock: lockfile for packages in package.json via yarn
        // - .nvmrc: this persion is using nvm to manage node versions
        //
        // The `yarn` package brings a `node` dependency along with it.
        // The yarn version is specified in `package.json`.
        // If the user specifies both a `yarn` and `node` version in `package.json`
        // then we want the `node` dependency of `yarn` *and* the `node` package
        // to match the version in `package.json`.
        //
        // If the user isn't using `yarn`, then we try to get a `node` version from
        // `package.json`
        let ctx = NodeCtx::new(path)?;
        if !ctx.is_valid_state() {
            debug!("node ctx detected an invalid state");
            return Ok(None);
        }
        if ctx.should_install_yarn_and_node() {
            // SAFETY: it's only possible to get to this point if we already found versions
            // in the `package.json` file, so it's safe to unwrap here.
            debug!("finding yarn and node versions");
            let versions = ctx
                .package_json_versions
                .clone()
                .expect("expected to find package.json versions");
            let action = Self::try_find_compatible_yarn_and_node_versions(flox, &versions).await?;
            let node = action.map(|action| {
                let node_install_action = NodeInstallAction::YarnAndNode(action.clone());
                Node {
                    action: node_install_action,
                    package_json_node_version: Some(PackageJSONVersion::Found(action.node.clone())),
                    nvmrc_version: None,
                }
            });
            Ok(node)
        } else if ctx.should_install_yarn_only() {
            // SAFETY: it's only possible to get to this point if we already found versions
            // in the `package.json` file, so it's safe to unwrap here.
            debug!("finding yarn version");
            let versions = ctx
                .package_json_versions
                .clone()
                .expect("expected to find package.json versions");
            let action = Self::try_find_compatible_yarn_only(flox, &versions).await?;
            let node = action.map(|action| {
                let node_install_action = NodeInstallAction::YarnOnly(action);
                Node {
                    action: node_install_action,
                    package_json_node_version: None,
                    nvmrc_version: None,
                }
            });
            Ok(node)
        } else if ctx.should_install_node_only() {
            debug!("finding node version");
            let versions = ctx.package_json_versions.clone();
            let res =
                Self::try_find_compatible_node_only(flox, versions.as_ref(), ctx.nvmrc_contents)
                    .await?;
            let node = res.map(|(action, version_source)| {
                let node_install_action = NodeInstallAction::Node(action.clone());
                match version_source {
                    NodeVersionSource::PackageJson(version) => Node {
                        action: node_install_action,
                        package_json_node_version: Some(version),
                        nvmrc_version: None,
                    },
                    NodeVersionSource::Nvmrc(version) => Node {
                        action: node_install_action,
                        package_json_node_version: None,
                        nvmrc_version: Some(version),
                    },
                }
            });
            Ok(node)
        } else {
            Ok(None)
        }
    }

    /// Try to find a satisfactory `yarn` version and a compatible `node` version.
    async fn try_find_compatible_yarn_and_node_versions(
        flox: &Flox,
        versions: &PackageJSONVersionsUnresolved,
    ) -> Result<Option<YarnAndNodeInstall>> {
        let PackageJSONVersionsUnresolved {
            yarn: requested_yarn_version,
            node: requested_node_version,
        } = versions;

        // First try to determine whether we need the `yarn` or `yarn-berry`
        // package so we can try to pair it with a node package later.
        let resolved_pkg_groups = try_find_compatible_major_version_package(
            flox,
            "yarn",
            &["yarn-berry", "yarn"],
            requested_yarn_version.as_deref(),
        )
        .await?;
        let yarn_pkg = resolved_pkg_groups
            .first()
            .map(|pkg| pkg.attr_path.to_string());
        if yarn_pkg.is_none() {
            // If we can't find a compatible version of *either*
            // yarn package, there's nothing to do here.
            return Ok(None);
        }
        let yarn_pkg = yarn_pkg.unwrap(); // just checked that it was Some

        let yarn_and_node_pkg_group = PackageGroup {
            descriptors: vec![
                PackageDescriptor {
                    attr_path: yarn_pkg.clone(),
                    install_id: yarn_pkg.clone(),
                    version: requested_yarn_version.clone(),
                    allow_pre_releases: None,
                    derivation: None,
                    allow_broken: None,
                    allow_insecure: None,
                    allow_unfree: None,
                    allowed_licenses: None,
                    allow_missing_builds: None,
                    systems: ALL_SYSTEMS.to_vec(),
                },
                PackageDescriptor {
                    allow_broken: None,
                    allow_insecure: None,
                    allow_missing_builds: None,
                    allow_pre_releases: None,
                    allow_unfree: None,
                    allowed_licenses: None,
                    attr_path: "nodejs".to_string(),
                    derivation: None,
                    install_id: "nodejs".to_string(), // generic "nodejs" package
                    systems: ALL_SYSTEMS.to_vec(),
                    version: requested_node_version.clone(),
                },
            ],
            name: "yarn".to_string(), // pkg-group name
        };
        let resolved = flox
            .catalog_client
            .resolve(vec![yarn_and_node_pkg_group])
            .await?;
        // A map of attr_path -> ProvidedPackage
        let pkgs = resolved
            .first()
            .and_then(|group| group.page.clone())
            .and_then(|page| page.packages)
            .map(|pkgs| {
                pkgs.into_iter()
                    .map(|pkg| (pkg.attr_path.clone(), pkg.into()))
                    .collect::<HashMap<String, ProvidedPackage>>()
            });
        if pkgs.is_none() {
            debug!("failed to resolve yarn/node group");
            return Ok(None);
        }
        let pkgs = pkgs.unwrap(); // We just checked that it was Some
        let yarn_pkg = pkgs.get(&yarn_pkg);
        let node_pkg = pkgs.get("nodejs");
        if yarn_pkg.is_none() || node_pkg.is_none() {
            return Ok(None);
        }

        let install = YarnAndNodeInstall {
            yarn: yarn_pkg.unwrap().clone(),
            node: node_pkg.unwrap().clone(),
        };
        Ok(Some(install))
    }

    /// Try to find a satisfactory `yarn` version and a compatible `node` version.
    async fn try_find_compatible_yarn_only(
        flox: &Flox,
        versions: &PackageJSONVersionsUnresolved,
    ) -> Result<Option<YarnInstall>> {
        let PackageJSONVersionsUnresolved {
            yarn: requested_yarn_version,
            ..
        } = versions;

        // First try to determine whether we need the `yarn` or `yarn-berry`
        // package so we can try to pair it with a node package later.
        let resolved_pkg_groups = try_find_compatible_major_version_package(
            flox,
            "yarn",
            &["yarn-berry", "yarn"],
            requested_yarn_version.as_deref(),
        )
        .await?;
        if let Some(pkg) = resolved_pkg_groups.first() {
            Ok(Some(YarnInstall { pkg: pkg.clone() }))
        } else {
            Ok(None)
        }
    }

    async fn try_find_compatible_node_only(
        flox: &Flox,
        versions: Option<&PackageJSONVersionsUnresolved>,
        nvmrc_contents: Result<Option<String>>,
    ) -> Result<Option<(NodeInstall, NodeVersionSource)>> {
        let nodejs_packages = Self::get_available_node_packages(flox).await?;
        debug!("resolving node version from package.json");
        let node_from_package_json =
            Self::node_install_from_package_json(flox, &nodejs_packages, versions).await?;
        if let Some((node_install, version)) = node_from_package_json {
            let source = NodeVersionSource::PackageJson(version);
            debug!(
                version = source.version_found().unwrap_or("null".to_string()),
                "found node version from package.json"
            );
            return Ok(Some((node_install, source)));
        }
        debug!("resolving node version from .nvmrc");
        let node_from_nvmrc =
            Self::node_install_from_nvmrc(flox, &nodejs_packages, nvmrc_contents).await?;
        if let Some((node_install, version)) = node_from_nvmrc {
            let source = NodeVersionSource::Nvmrc(version);
            debug!(
                version = source.version_found().unwrap_or("null".to_string()),
                "found node version from .nvmrc"
            );
            return Ok(Some((node_install, source)));
        }
        Ok(None)
    }

    /// Tries to get a Node installation from package.json, which may itself be missing,
    /// or may not contain a Node version even if package.json does exist.
    async fn node_install_from_package_json(
        flox: &Flox,
        node_pkgs: &[String],
        package_json_versions: Option<&PackageJSONVersionsUnresolved>,
    ) -> Result<Option<(NodeInstall, PackageJSONVersion)>> {
        debug!("checking compatible node version from package.json");
        let node_from_package_json: Option<(NodeInstall, PackageJSONVersion)> =
            match package_json_versions {
                // We had a package.json and a node version inside of it.
                Some(PackageJSONVersionsUnresolved {
                    node: Some(node_version),
                    ..
                }) => {
                    debug!(
                        version = node_version,
                        "trying to find compatible node version"
                    );
                    let resolved_groups = try_find_compatible_major_version_package(
                        flox,
                        "nodejs",
                        node_pkgs,
                        Some(node_version),
                    )
                    .await?;
                    match resolved_groups.first() {
                        Some(pkg) => {
                            let node_install = NodeInstall {
                                node: Some(pkg.clone()),
                                npm_hook: true,
                            };
                            let version = PackageJSONVersion::Found(pkg.clone());
                            Some((node_install, version))
                        },
                        None => {
                            let node_install = NodeInstall {
                                node: None,
                                npm_hook: false,
                            };
                            Some((node_install, PackageJSONVersion::Unavailable))
                        },
                    }
                },
                // We had a package.json but no node version inside of it.
                Some(PackageJSONVersionsUnresolved { node: None, .. }) => {
                    let node_install = NodeInstall {
                        node: None,
                        npm_hook: true,
                    };
                    Some((node_install, PackageJSONVersion::Unspecified))
                },
                // We didn't have a package.json file.
                None => None,
            };
        Ok(node_from_package_json)
    }

    /// Tries to get a Node installation from .nvmrc, which may itself be missing
    /// or have invalid contents.
    async fn node_install_from_nvmrc(
        flox: &Flox,
        node_pkgs: &[String],
        nvmrc_contents: Result<Option<String>>,
    ) -> Result<Option<(NodeInstall, NVMRCVersion)>> {
        match nvmrc_contents {
            // The .nvmrc file existed and we successfully read it.
            Ok(Some(contents)) => {
                let node_from_nvmrc = match Self::parse_nvmrc_version(&contents) {
                    // The file was empty
                    RequestedNVMRCVersion::None => {
                        let node_install = NodeInstall {
                            node: None,
                            npm_hook: false,
                        };
                        Some((node_install, NVMRCVersion::Unspecified))
                    },
                    // The file contained an alias (e.g. "stable") or something else
                    // that we don't know how to translate to a version.
                    RequestedNVMRCVersion::Unsure => {
                        let node_install = NodeInstall {
                            node: None,
                            npm_hook: false,
                        };
                        Some((node_install, NVMRCVersion::Unsure))
                    },
                    // The file contained a version we can search for.
                    RequestedNVMRCVersion::Found(version) => {
                        let resolved_groups = try_find_compatible_major_version_package(
                            flox,
                            "nodejs",
                            node_pkgs,
                            Some(version.as_str()),
                        )
                        .await?;
                        match resolved_groups.first() {
                            Some(pkg) => {
                                let node_install = NodeInstall {
                                    node: Some(pkg.clone()),
                                    npm_hook: false,
                                };
                                let version = NVMRCVersion::Found(pkg.clone());
                                Some((node_install, version))
                            },
                            None => {
                                let node_install = NodeInstall {
                                    node: None,
                                    npm_hook: false,
                                };
                                Some((node_install, NVMRCVersion::Unavailable))
                            },
                        }
                    },
                };
                Ok(node_from_nvmrc)
            },
            // The .nvmrc file didn't exist, so we didn't encounter an error
            // while trying to read it (e.g. we successfully did...nothing).
            Ok(None) => Ok(None),
            // The .nvmrc file existed and we encountered an error trying to read it.
            Err(err) => {
                // This is necessary to make it compile since the Ok variant has
                // a completely different type.
                Err(err)
            },
        }
    }

    async fn get_available_node_packages(flox: &Flox) -> Result<Vec<String>> {
        let res = flox
            .catalog_client
            .search("nodejs_", flox.system.clone(), None)
            .await
            .context("failed to query node versions")?;
        // SAFETY: This expect/unwrap will catch an invalid regex at test time,
        //         so if we really screw this up it will be caught before hitting
        //         production.
        let node_pkg_regex = Regex::new(r#"nodejs_\d\d"#).expect("invalid node package regex");
        let mut matches = res
            .results
            .into_iter()
            .filter_map(|search_result| {
                let name = search_result.attr_path;
                if node_pkg_regex.is_match(&name) {
                    Some(name)
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();
        // This will sort lexically, but lexically sorting also sorts by
        // version in this case e.g. nodejs_14 comes before nodejs_23 in
        // both cases.
        matches.sort();
        // We want later versions towards the front so we can take the first
        // one.
        matches.reverse();

        // Reorder to prefer even (LTS) versions. If the constraint requires
        // an odd (Current) version (e.g., "=23"), LTS versions will be
        // skipped during resolution.
        matches = Self::reorder_preferring_lts(matches);

        // The search term was specifically "nodejs_" to catch the major version
        // packages. Add generic "nodejs" as fallback.
        matches.push("nodejs".to_string());

        Ok(matches)
    }

    /// Translate the contents of a `.nvmrc` file into a [RequestedNVMRCVersion]
    fn parse_nvmrc_version(nvmrc_contents: &str) -> RequestedNVMRCVersion {
        // When reading from a file, nvm runs:
        // "$(command head -n 1 "${NVMRC_PATH}" | command tr -d '\r')" || command printf ''
        // https://github.com/nvm-sh/nvm/blob/294ff9e3aa8ce02bbf8d83fa235a363d9560a179/nvm.sh#L481
        let first_line = nvmrc_contents.lines().next();
        // From nvm --help:
        // <version> refers to any version-like string nvm understands. This includes:
        //   - full or partial version numbers, starting with an optional "v" (0.10, v0.1.2, v1)
        //   - default (built-in) aliases: node, stable, unstable, iojs, system
        //   - custom aliases you define with `nvm alias foo`
        match first_line {
            None => RequestedNVMRCVersion::None,
            Some(first_line) => {
                // nvm will fail if there's trailing whitespace,
                // so trimming whitespace is technically inconsistent,
                // but it's still probably a good recommendation from flox.
                let trimmed_first_line = first_line.trim();
                match trimmed_first_line {
                    "" => RequestedNVMRCVersion::None,
                    "node" | "stable" | "unstable" | "iojs" | "system" => {
                        RequestedNVMRCVersion::Unsure
                    },
                    _ if trimmed_first_line.starts_with('v')
                        && VersionReq::parse(&trimmed_first_line[1..]).is_ok() =>
                    {
                        RequestedNVMRCVersion::Found(trimmed_first_line[1..].to_string())
                    },
                    _ if VersionReq::parse(trimmed_first_line).is_ok() => {
                        RequestedNVMRCVersion::Found(trimmed_first_line.to_string())
                    },
                    _ => RequestedNVMRCVersion::Unsure,
                }
            },
        }
    }

    /// Returns:
    /// 1. A message describing what version of nodejs Flox found requested to
    ///    include in the prompt.
    /// 2. The version of nodejs Flox would install
    /// 3. Whether the message says Flox detected package.json (to avoid
    ///    printing that message twice)
    async fn nodejs_message_and_version(
        &self,
        flox: &Flox,
    ) -> Result<(String, Option<String>, bool)> {
        let mut mentions_package_json = false;
        let (message, version) = match (
            &self.package_json_node_version,
            self.nvmrc_version.as_ref(),
        ) {
            // package.json takes precedence over .nvmrc
            (Some(PackageJSONVersion::Found(result)), _) => {
                let message = format!(
                    "Flox detected a package.json compatible with node{}",
                    Self::format_version_or_empty(result.version.as_ref())
                );
                mentions_package_json = true;
                (message, result.version.clone())
            },
            // Treat the version in package.json strictly; if we can't find it, don't suggest something else.
            // get_action() returns NodeAction::Nothing for this case so it's unreachable
            (Some(PackageJSONVersion::Unavailable), _) => unreachable!(
                "shouldn't run setup hook when package.json node version is unavailable"
            ),
            (_, Some(NVMRCVersion::Found(result))) => {
                let message = format!(
                    "Flox detected an .nvmrc{}",
                    Self::format_version_or_empty(result.version.as_ref())
                );
                (message, result.version.clone())
            },
            (_, Some(NVMRCVersion::Unsure)) => {
                let result = find_compatible_package(flox, "nodejs", None).await?;
                let message = format!(
                    "Flox detected an .nvmrc with a version specifier not understood by Flox, but Flox can provide {}",
                    result
                        .version
                        .as_ref()
                        .map(|version| format!("version {version}"))
                        .unwrap_or("another version".to_string())
                );
                (message, result.version)
            },
            (_, Some(NVMRCVersion::Unavailable)) => {
                let result = find_compatible_package(flox, "nodejs", None).await?;
                let message = format!(
                    "Flox detected an .nvmrc with a version of nodejs not provided by Flox, but Flox can provide {}",
                    result
                        .version
                        .as_ref()
                        .map(|version| format!("version {version}"))
                        .unwrap_or("another version".to_string())
                );
                (message, result.version.clone())
            },
            (Some(PackageJSONVersion::Unspecified), None) => {
                let result = find_compatible_package(flox, "nodejs", None).await?;
                mentions_package_json = true;
                ("Flox detected a package.json".to_string(), result.version)
            },
            (None, Some(NVMRCVersion::Unspecified)) => {
                let result = find_compatible_package(flox, "nodejs", None).await?;
                ("Flox detected an .nvmrc".to_string(), result.version)
            },
            (Some(PackageJSONVersion::Unspecified), Some(NVMRCVersion::Unspecified)) => {
                // This is unreachable because we only set the source to `Some` that we
                // eventually used to find the package. In other words, if we had a
                // `package.json` and failed to locate a suitable package, we still
                // return `Some(_)` for the `package.json` one, and don't even look at
                // .nvmrc.
                unreachable!(
                    "shouldn't run a setup hook that uses both package.json and .nvmrc version"
                )
            },
            // get_action() returns NodeAction::Nothing for this case so it's unreachable
            (None, None) => {
                unreachable!("shouldn't run setup hook without something that needs node")
            },
        };
        Ok((message, version, mentions_package_json))
    }

    /// Helper function for [Self::prompt_with_node] and [Self::prompt_with_yarn]
    fn single_option_prompt(&self) -> Result<bool> {
        let message = indoc! {
        "Would you like Flox to apply this suggestion?
        You can always change the environment's manifest with 'flox edit'"};

        let dialog = Dialog {
            message,
            help_message: Some(AUTO_SETUP_HINT),
            typed: Select {
                options: ["Yes", "No", "Show suggested modifications"].to_vec(),
            },
        };
        let (mut choice, _) = dialog.clone().raw_prompt()?;

        while choice == 2 {
            message::plain(format_customization(&self.get_init_customization())?);

            (choice, _) = dialog.clone().raw_prompt()?;
        }

        Ok(choice == 0)
    }

    /// Prompt whether to install nodejs (but not npm or yarn)
    async fn prompt_with_node(&self, flox: &Flox, node_install: &NodeInstall) -> Result<bool> {
        let (nodejs_detected, nodejs_version, mentions_package_json) =
            self.nodejs_message_and_version(flox).await?;
        let mut detected = format!("{nodejs_detected}\n");
        if node_install.npm_hook {
            if !mentions_package_json {
                detected.push_str("Flox detected a package.json\n");
            }

            detected.push_str(&formatdoc! {"

                Flox can add the following to your environment:
                * nodejs{} with npm bundled
                * An npm installation hook
            ",
                Self::format_version_or_empty(nodejs_version.as_ref()),
            });
        } else {
            detected.push_str(&formatdoc! {"

                Flox can add the following to your environment:
                * nodejs{}
            ",
                Self::format_version_or_empty(nodejs_version.as_ref()),
            });
        }
        message::plain(detected);

        self.single_option_prompt()
    }

    /// Prompt whether to install yarn
    fn prompt_with_yarn_and_node(&self, yarn_install: &YarnAndNodeInstall) -> Result<bool> {
        let yarn_version = Self::format_version_or_empty(yarn_install.yarn.version.as_ref());
        let node_version = Self::format_version_or_empty(yarn_install.node.version.as_ref());

        message::plain(formatdoc! {"
            Flox detected a package.json and a yarn.lock

            Flox can add the following to your environment:
            * yarn{yarn_version} with nodejs{node_version} bundled
            * A yarn installation hook
            "});

        self.single_option_prompt()
    }

    /// Prompt whether to install yarn
    fn prompt_with_yarn(&self, yarn_install: &YarnInstall) -> Result<bool> {
        let yarn_version = Self::format_version_or_empty(yarn_install.pkg.version.as_ref());

        message::plain(formatdoc! {"
            Flox detected a package.json and a yarn.lock

            Flox can add the following to your environment:
            * yarn{yarn_version}
            * A yarn installation hook
            "});

        self.single_option_prompt()
    }

    fn format_version_or_empty(version: Option<&String>) -> String {
        version
            .map(|version| format!(" {version}"))
            .unwrap_or("".to_string())
    }
}

impl InitHook for Node {
    async fn prompt_user(&mut self, flox: &Flox, _path: &Path) -> Result<bool> {
        match &self.action {
            NodeInstallAction::YarnAndNode(yarn_and_node_install) => {
                self.prompt_with_yarn_and_node(yarn_and_node_install)
            },
            NodeInstallAction::Node(node_install) => {
                self.prompt_with_node(flox, node_install).await
            },
            NodeInstallAction::YarnOnly(yarn_install) => self.prompt_with_yarn(yarn_install),
        }
    }

    fn get_init_customization(&self) -> InitCustomization {
        let mut packages = vec![];

        let hook_on_activate = match &self.action {
            NodeInstallAction::YarnAndNode(yarn_install) => {
                packages.push(CatalogPackage {
                    id: "yarn".to_string(),
                    pkg_path: yarn_install.yarn.attr_path.clone().into(),
                    // TODO: we probably shouldn't pin this when we're just
                    // providing the default
                    version: yarn_install.yarn.version.clone(),
                    systems: None,
                    outputs: None,
                });
                packages.push(CatalogPackage {
                    id: "node".to_string(),
                    pkg_path: yarn_install.node.attr_path.clone().into(),
                    // TODO: we probably shouldn't pin this when we're just
                    // providing the default
                    version: yarn_install.node.version.clone(),
                    systems: None,
                    outputs: None,
                });
                Some(YARN_HOOK.to_string())
            },
            NodeInstallAction::Node(node_install) => {
                let nodejs_to_install = match &node_install.node {
                    Some(result) => CatalogPackage {
                        id: "nodejs".to_string(),
                        pkg_path: result.attr_path.clone().into(),
                        version: result.version.clone(),
                        systems: None,
                        outputs: None,
                    },
                    None => CatalogPackage {
                        id: "nodejs".to_string(),
                        pkg_path: "nodejs".to_string(),
                        version: None,
                        systems: None,
                        outputs: None,
                    },
                };
                packages.push(nodejs_to_install);
                if node_install.npm_hook {
                    Some(NPM_HOOK.to_string())
                } else {
                    None
                }
            },
            NodeInstallAction::YarnOnly(yarn_install) => {
                packages.push(CatalogPackage {
                    id: "yarn".to_string(),
                    pkg_path: yarn_install.pkg.attr_path.clone().into(),
                    // TODO: we probably shouldn't pin this when we're just
                    // providing the default
                    version: yarn_install.pkg.version.clone(),
                    systems: None,
                    outputs: None,
                });
                Some(YARN_HOOK.to_string())
            },
        };

        InitCustomization {
            hook_on_activate,
            packages: Some(packages),
            ..Default::default()
        }
    }
}

#[cfg(test)]
mod tests {

    use flox_rust_sdk::flox::test_helpers::flox_instance;
    use flox_rust_sdk::providers::catalog::test_helpers::auto_recording_catalog_client;
    use pretty_assertions::assert_eq;
    use serde::Serialize;
    use serde_with::skip_serializing_none;

    use super::*;

    #[tokio::test]
    async fn new_detection() {
        #[skip_serializing_none]
        #[derive(Clone, Debug, Serialize, Default)]
        struct PackageJSON {
            engines: Option<Engines>,
        }
        #[skip_serializing_none]
        #[derive(Clone, Debug, Serialize, Default)]
        struct Engines {
            node: Option<String>,
            yarn: Option<String>,
        }

        #[derive(Clone, Debug)]
        struct File {
            name: String,
            content: String,
        }
        #[derive(Clone, Debug)]
        struct Package {
            name: String,
            version: String,
        }
        impl From<&Package> for ProvidedPackage {
            fn from(pkg: &Package) -> Self {
                ProvidedPackage {
                    name: pkg.name.clone(),
                    attr_path: pkg.name.clone().into(),
                    display_version: pkg.version.clone(),
                    version: Some(pkg.version.clone()),
                }
            }
        }
        #[derive(Debug)]
        struct TestCase {
            description: &'static str,
            files: Vec<File>,
            expected: Option<Node>,
            needs_client: bool,
        }

        let yarn_package = Package {
            name: "yarn".to_string(),
            version: "1.22.22".to_string(),
        };
        let node_package = Package {
            name: "nodejs".to_string(),
            version: "20.18.1".to_string(),
        };
        let node_20 = Package {
            name: "nodejs_20".to_string(),
            version: "20.20.0".to_string(),
        };

        let test_cases = vec![
            // - Returns [NodeAction::InstallYarn] if
            //   - package.json and yarn.lock exist
            //   - We can find nodejs and yarn packages compatible with package.json
            //     engines
            //   - package-lock.json does not exist
            TestCase {
                description: "package.json and yarn.lock",
                files: vec![
                    File {
                        name: "package.json".to_string(),
                        content: serde_json::to_string(&PackageJSON {
                            engines: Some(Engines {
                                node: Some(node_package.version.clone()),
                                yarn: Some(yarn_package.version.clone()),
                            }),
                        })
                        .unwrap(),
                    },
                    File {
                        name: "yarn.lock".to_string(),
                        content: "".to_string(),
                    },
                ],
                expected: Some(Node {
                    action: NodeInstallAction::YarnAndNode(YarnAndNodeInstall {
                        yarn: (&yarn_package).into(),
                        node: (&node_package).into(),
                    }),
                    package_json_node_version: Some(PackageJSONVersion::Found(
                        (&node_package).into(),
                    )),
                    nvmrc_version: None,
                }),
                needs_client: true,
            },
            // - Returns [NodeAction::InstallNode] if
            //   - .nvmrc or package.json exists
            //   - We can find nodejs compatible with package.json engines
            //     (.nvmrc is respected if possible,
            //     but we offer an alternative even if we can't satisfy its
            //     constraints)
            //   - yarn.lock does not exist
            TestCase {
                description: "package.json with satisfied nodejs version",
                files: vec![File {
                    name: "package.json".to_string(),
                    content: serde_json::to_string(&PackageJSON {
                        engines: Some(Engines {
                            node: Some(node_20.version.clone()),
                            yarn: None,
                        }),
                    })
                    .unwrap(),
                }],
                expected: Some(Node {
                    action: NodeInstallAction::Node(NodeInstall {
                        node: Some((&node_20).into()),
                        npm_hook: true,
                    }),
                    package_json_node_version: Some(PackageJSONVersion::Found((&node_20).into())),
                    nvmrc_version: None,
                }),
                needs_client: true,
            },
            TestCase {
                description: ".nvmrc with satisfied version",
                files: vec![File {
                    name: ".nvmrc".to_string(),
                    content: "v20".to_string(),
                }],
                expected: Some(Node {
                    action: NodeInstallAction::Node(NodeInstall {
                        node: Some((&node_20).into()),
                        npm_hook: false,
                    }),
                    package_json_node_version: None,
                    nvmrc_version: Some(NVMRCVersion::Found((&node_20).into())),
                }),
                needs_client: true,
            },
            TestCase {
                description: "package.json with no engines",
                files: vec![File {
                    name: "package.json".to_string(),
                    content: serde_json::to_string(&PackageJSON { engines: None }).unwrap(),
                }],
                expected: Some(Node {
                    action: NodeInstallAction::Node(NodeInstall {
                        node: None,
                        npm_hook: true,
                    }),
                    package_json_node_version: Some(PackageJSONVersion::Unspecified),
                    nvmrc_version: None,
                }),
                needs_client: true,
            },
            // package-lock.json takes precedence over yarn.lock
            TestCase {
                description: "package.json, package-json.lock, and yarn.lock",
                files: vec![
                    File {
                        name: "package.json".to_string(),
                        content: serde_json::to_string(&PackageJSON {
                            engines: Some(Engines {
                                node: Some(node_20.version.clone()),
                                yarn: Some(yarn_package.version.clone()),
                            }),
                        })
                        .unwrap(),
                    },
                    File {
                        name: "package-lock.json".to_string(),
                        content: "".to_string(),
                    },
                    File {
                        name: "yarn.lock".to_string(),
                        content: "".to_string(),
                    },
                ],
                expected: Some(Node {
                    action: NodeInstallAction::Node(NodeInstall {
                        node: Some((&node_20).into()),
                        npm_hook: true,
                    }),
                    package_json_node_version: Some(PackageJSONVersion::Found((&node_20).into())),
                    nvmrc_version: None,
                }),
                needs_client: true,
            },
            // - Returns [None] if
            //   - There's no package.json or .nvmrc
            //   - We can't satisfy constraints in package.json
            TestCase {
                description: "no files at all",
                files: vec![],
                expected: None,
                needs_client: false,
            },
            // Returns a `NodeInstall` saying that we looked and didn't find a
            // matching nodejs package.
            TestCase {
                description: "constraints not met",
                files: vec![File {
                    name: "package.json".to_string(),
                    content: serde_json::to_string(&PackageJSON {
                        engines: Some(Engines {
                            node: Some("9.9.9".to_string()),
                            yarn: Some("9.9.9".to_string()),
                        }),
                    })
                    .unwrap(),
                }],
                expected: Some(Node {
                    action: NodeInstallAction::Node(NodeInstall {
                        node: None,
                        npm_hook: false,
                    }),
                    package_json_node_version: Some(PackageJSONVersion::Unavailable),
                    nvmrc_version: None,
                }),
                needs_client: true,
            },
        ];

        for tc in test_cases {
            let (mut flox, temp_dir) = flox_instance();

            for File { name, content } in tc.files {
                let file = temp_dir.path().join(name);
                fs::write(file, content).unwrap();
            }

            if tc.needs_client {
                flox.catalog_client = auto_recording_catalog_client(&format!(
                    "node_new_detection_{}",
                    tc.description.replace(" ", "_").replace(".", "_")
                ));
            }

            let node = Node::new(&flox, temp_dir.path())
                .await
                .context(format!("test case: {}", tc.description))
                .unwrap();
            assert_eq!(node, tc.expected, "test case: {}", tc.description);
        }
    }

    #[test]
    fn parse_nvmrc_version_some() {
        assert_eq!(
            Node::parse_nvmrc_version("v0.1.14"),
            RequestedNVMRCVersion::Found("0.1.14".to_string())
        );
        assert_eq!(
            Node::parse_nvmrc_version("v20.11.1"),
            RequestedNVMRCVersion::Found("20.11.1".to_string())
        );
        assert_eq!(
            Node::parse_nvmrc_version("0.1.14"),
            RequestedNVMRCVersion::Found("0.1.14".to_string())
        );
        assert_eq!(
            Node::parse_nvmrc_version("0"),
            RequestedNVMRCVersion::Found("0".to_string())
        );
        assert_eq!(
            Node::parse_nvmrc_version("0.1"),
            RequestedNVMRCVersion::Found("0.1".to_string())
        );
        assert_eq!(
            Node::parse_nvmrc_version("0.1.14\n"),
            RequestedNVMRCVersion::Found("0.1.14".to_string())
        );
        assert_eq!(
            Node::parse_nvmrc_version("0.1.14   "),
            RequestedNVMRCVersion::Found("0.1.14".to_string())
        );
    }

    #[test]
    fn parse_nvmrc_version_unsure() {
        assert_eq!(
            Node::parse_nvmrc_version("node"),
            RequestedNVMRCVersion::Unsure
        );
        assert_eq!(
            Node::parse_nvmrc_version("0.1.14 blah blah"),
            RequestedNVMRCVersion::Unsure
        );
    }

    #[test]
    fn parse_nvmrc_version_none() {
        assert_eq!(Node::parse_nvmrc_version(""), RequestedNVMRCVersion::None);
        assert_eq!(Node::parse_nvmrc_version("\n"), RequestedNVMRCVersion::None);
    }

    /// Test get_init_customization() for action InstallYarn
    #[test]
    fn get_init_customization_yarn() {
        assert_eq!(
            Node {
                package_json_node_version: None,
                nvmrc_version: None,
                action: NodeInstallAction::YarnAndNode(YarnAndNodeInstall {
                    yarn: ProvidedPackage {
                        attr_path: "yarn.path".into(),
                        version: Some("1".to_string()),
                        name: "yarn".to_string(),
                        display_version: "1".to_string(),
                    },
                    node: ProvidedPackage {
                        name: "nodejs".to_string(),
                        attr_path: "nodejs".into(),
                        display_version: "N/A".to_string(),
                        version: None
                    },
                }),
            }
            .get_init_customization(),
            InitCustomization {
                packages: Some(vec![
                    CatalogPackage {
                        id: "yarn".to_string(),
                        pkg_path: "yarn.path".to_string(),
                        version: Some("1".to_string()),
                        systems: None,
                        outputs: None,
                    },
                    CatalogPackage {
                        id: "node".to_string(),
                        pkg_path: "nodejs".to_string(),
                        version: None,
                        systems: None,
                        outputs: None,
                    }
                ]),
                hook_on_activate: Some(YARN_HOOK.to_string()),
                ..Default::default()
            }
        );
    }

    /// Test get_init_customization() for action InstallNode and npm_hook false
    #[test]
    fn get_init_customization_node() {
        assert_eq!(
            Node {
                package_json_node_version: None,
                nvmrc_version: None,
                action: NodeInstallAction::Node(NodeInstall {
                    node: Some(ProvidedPackage {
                        attr_path: "nodejs.path".into(),
                        version: Some("1".to_string()),
                        name: "nodejs".to_string(),
                        display_version: "1".to_string()
                    }),
                    npm_hook: false,
                })
            }
            .get_init_customization(),
            InitCustomization {
                packages: Some(vec![CatalogPackage {
                    id: "nodejs".to_string(),
                    pkg_path: "nodejs.path".to_string(),
                    version: Some("1".to_string()),
                    systems: None,
                    outputs: None,
                }]),
                ..Default::default()
            }
        );
    }

    ///////////////////////////////////////////////////////////////////////////
    // Catalog tests
    ///////////////////////////////////////////////////////////////////////////

    /// Test finding yarn with no constraints succeeds
    #[tokio::test]
    async fn try_find_compatible_yarn_no_constraints_with_catalog() {
        let (mut flox, _temp_dir_handle) = flox_instance();
        flox.catalog_client =
            auto_recording_catalog_client("try_find_compatible_yarn_no_constraints_with_catalog");

        let yarn_install = Node::try_find_compatible_yarn_and_node_versions(
            &flox,
            &PackageJSONVersionsUnresolved {
                yarn: None,
                node: None,
            },
        )
        .await
        .unwrap()
        .unwrap();

        assert_eq!(yarn_install.node.attr_path, "nodejs".into());
        assert_eq!(yarn_install.yarn.attr_path, "yarn-berry".into());
    }

    /// Test finding yarn with the version of nixpkgs#nodejs specified succeeds
    #[tokio::test]
    async fn try_find_compatible_yarn_node_available_with_catalog() {
        let (mut flox, _temp_dir_handle) = flox_instance();
        flox.catalog_client =
            auto_recording_catalog_client("try_find_compatible_yarn_node_available_with_catalog");

        // NOTE: there's a similar test below that tests for `yarn` and `nodejs`,
        // whereas this one tests for `yarn-berry` and `nodejs`.
        let yarn_install = Node::try_find_compatible_yarn_and_node_versions(
            &flox,
            &PackageJSONVersionsUnresolved {
                yarn: Some("4".to_string()),
                node: Some("22".to_string()),
            },
        )
        .await
        .unwrap()
        .unwrap();

        assert_eq!(yarn_install.node.attr_path, "nodejs".into());
        assert!(yarn_install.node.version.unwrap().starts_with("22"));
        assert_eq!(yarn_install.yarn.attr_path, "yarn-berry".into());
    }

    /// Test finding yarn with a version of node other than that of
    /// nixpkgs#nodejs fails
    #[tokio::test]
    async fn try_find_compatible_yarn_node_unavailable_with_catalog() {
        let (mut flox, _temp_dir_handle) = flox_instance();
        flox.catalog_client =
            auto_recording_catalog_client("try_find_compatible_yarn_node_unavailable_with_catalog");

        let yarn_install = Node::try_find_compatible_yarn_and_node_versions(
            &flox,
            &PackageJSONVersionsUnresolved {
                yarn: Some("4".to_string()),
                node: Some("25".to_string()),
            },
        )
        .await
        .unwrap();

        assert_eq!(yarn_install, None);
    }

    /// Test finding yarn with the version nixpkgs#yarn specified succeeds
    #[tokio::test]
    async fn try_find_compatible_yarn_yarn_available_with_catalog() {
        let (mut flox, _temp_dir_handle) = flox_instance();
        flox.catalog_client =
            auto_recording_catalog_client("try_find_compatible_yarn_yarn_available_with_catalog");

        let yarn_install =
            Node::try_find_compatible_yarn_only(&flox, &PackageJSONVersionsUnresolved {
                yarn: Some("1".to_string()),
                node: None,
            })
            .await
            .unwrap()
            .unwrap();

        assert_eq!(yarn_install.pkg.attr_path, "yarn".into());
        assert!(yarn_install.pkg.version.unwrap().starts_with('1'));
    }

    /// Test finding yarn with a version of yarn other than that of
    /// nixpkgs#yarn fails
    #[tokio::test]
    async fn try_find_compatible_yarn_yarn_unavailable_with_catalog() {
        let (mut flox, _temp_dir_handle) = flox_instance();
        flox.catalog_client =
            auto_recording_catalog_client("try_find_compatible_yarn_yarn_unavailable_with_catalog");

        let yarn_install =
            Node::try_find_compatible_yarn_only(&flox, &PackageJSONVersionsUnresolved {
                yarn: Some("22".to_string()),
                node: None,
            })
            .await
            .unwrap();

        assert_eq!(yarn_install, None);
    }

    /// Test finding yarn with versions of nixpkgs#yarn and nixpkgs#nodejs
    /// specified succeeds
    #[tokio::test]
    async fn try_find_compatible_yarn_both_available_with_catalog() {
        let (mut flox, _temp_dir_handle) = flox_instance();

        flox.catalog_client =
            auto_recording_catalog_client("try_find_compatible_yarn_both_available_with_catalog");
        let yarn_install = Node::try_find_compatible_yarn_and_node_versions(
            &flox,
            &PackageJSONVersionsUnresolved {
                yarn: Some("1".to_string()),
                node: Some("18".to_string()),
            },
        )
        .await
        .unwrap()
        .unwrap();

        assert_eq!(yarn_install.node.attr_path, "nodejs".into());
        assert!(yarn_install.node.version.unwrap().starts_with("18"));
        assert_eq!(yarn_install.yarn.attr_path, "yarn".into());
        assert!(yarn_install.yarn.version.unwrap().starts_with('1'));
    }

    ///////////////////////////////////////////////////////////////////////////
    // LTS preference tests
    ///////////////////////////////////////////////////////////////////////////

    #[test]
    fn test_reorder_preferring_lts() {
        // Test basic reordering: even versions should come before odd versions
        let input = vec![
            "nodejs_23".to_string(),
            "nodejs_22".to_string(),
            "nodejs_21".to_string(),
            "nodejs_20".to_string(),
        ];
        let expected = vec![
            "nodejs_22".to_string(),
            "nodejs_20".to_string(),
            "nodejs_23".to_string(),
            "nodejs_21".to_string(),
        ];
        assert_eq!(Node::reorder_preferring_lts(input), expected);

        // Test with only even versions
        let input = vec![
            "nodejs_22".to_string(),
            "nodejs_20".to_string(),
            "nodejs_18".to_string(),
        ];
        let expected = vec![
            "nodejs_22".to_string(),
            "nodejs_20".to_string(),
            "nodejs_18".to_string(),
        ];
        assert_eq!(Node::reorder_preferring_lts(input), expected);

        // Test with only odd versions (they go to the "odd" partition)
        let input = vec!["nodejs_23".to_string(), "nodejs_21".to_string()];
        let expected = vec!["nodejs_23".to_string(), "nodejs_21".to_string()];
        assert_eq!(Node::reorder_preferring_lts(input), expected);

        // Test with empty input
        let input: Vec<String> = vec![];
        let expected: Vec<String> = vec![];
        assert_eq!(Node::reorder_preferring_lts(input), expected);

        // Test that non-matching packages (like "nodejs") go to the odd partition
        let input = vec![
            "nodejs_23".to_string(),
            "nodejs_22".to_string(),
            "nodejs".to_string(),
        ];
        let expected = vec![
            "nodejs_22".to_string(),
            "nodejs_23".to_string(),
            "nodejs".to_string(),
        ];
        assert_eq!(Node::reorder_preferring_lts(input), expected);
    }
}
