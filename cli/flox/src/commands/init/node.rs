use std::fs;
use std::path::Path;

use anyhow::{Context, Result, anyhow};
use flox_rust_sdk::flox::Flox;
use flox_rust_sdk::models::environment::path_environment::InitCustomization;
use flox_rust_sdk::models::manifest::raw::CatalogPackage;
use flox_rust_sdk::providers::catalog::ClientTrait;
use flox_rust_sdk::utils::logging::traceable_path;
use indoc::{formatdoc, indoc};
use regex::Regex;
use semver::VersionReq;
use tracing::debug;

use super::{
    AUTO_SETUP_HINT,
    InitHook,
    ProvidedPackage,
    find_compatible_package,
    format_customization,
    try_find_compatible_package,
};
use crate::commands::init::try_find_compatible_major_version_package;
use crate::utils::dialog::{Dialog, Select};
use crate::utils::message;

const NPM_HOOK: &str = indoc! {"
                # Install nodejs dependencies
                npm install"};

const YARN_HOOK: &str = indoc! {"
                # Install nodejs dependencies
                yarn"};

/// The general flow of the node hook is:
///
/// - [Self::new]: Calculate a [NodeAction]
/// - [Self::prompt_user]: If the action is [NodeAction::InstallYarnOrNode],
///   set it to one of [NodeAction::InstallNode] or [NodeAction::InstallYarn].
///   Otherwise, just return true or false based on whether the user wants the
///   customization.
/// - [Self::get_init_customization]: Return a customization based on [Self::action]
#[derive(Debug, Clone, PartialEq)]
pub(super) struct Node {
    /// Stores what customization should be generated by
    /// [Self::get_init_customization].
    ///
    /// Initialized in [Self::new] and potentially modified by [Self::prompt_user].
    action: NodeInstallAction,
    /// This is initialized in [Self::new] and currently only used by
    /// [Self::nodejs_message_and_version]
    /// TODO: should this be stored on [NodeAction::InstallNode]?
    ///
    /// Node version as specified in package.json if it exists
    /// If action is set to [NodeAction::InstallYarn], this is left
    /// uninitialized as [None].
    package_json_node_version: Option<PackageJSONVersion>,
    /// This is initialized in [Self::new] and currently only used by
    /// [Self::nodejs_message_and_version]
    /// TODO: should this be stored on [NodeAction::InstallNode]?
    ///
    /// Node version as specified in .nvmrc if it exists
    /// If action is set to [NodeAction::InstallYarn], this is left
    /// uninitialized as [None].
    nvmrc_version: Option<NVMRCVersion>,
}

/// Information about the version specifier found in the `.nvmrc` file
#[derive(Debug, PartialEq)]
enum RequestedNVMRCVersion {
    /// .nvmrc not present or empty
    None,
    /// .nvmrc contains an alias or something we can't parse as a version.
    Unsure,
    /// The version specifier in the .nvmrc file
    Found(String),
}

/// Information about the result of finding a node version compatible with what the `.nvmrc` file
/// requested
#[derive(Debug, Clone, PartialEq)]
enum NVMRCVersion {
    /// .nvmrc contains a version, but flox doesn't provide it.
    Unavailable,
    /// .nvmrc contains an alias or something we can't parse as a version.
    Unsure,
    /// An available version of nodejs that matches the version specifier in the .nvmrc file
    Found(ProvidedPackage),
}

#[derive(Debug, Clone, PartialEq)]
enum PackageJSONVersion {
    /// package.json exists but doesn't specify a version
    Unspecified,
    /// package.json specifies a version, but flox can't provide it
    Unavailable,
    /// package.json specifies a version,
    /// and we found a search result satisfying that version constraint
    Found(ProvidedPackage),
}

/// Which node and yarn versions to install together
#[derive(Clone, Debug, PartialEq)]
struct YarnInstall {
    yarn: ProvidedPackage,
    node: ProvidedPackage,
}

/// Which node version to install if desired
#[derive(Debug, Clone, PartialEq)]
struct NodeInstall {
    node: Option<ProvidedPackage>,
    npm_hook: bool,
}

/// Which node ecosystem packages to install
#[derive(Debug, Clone, PartialEq)]
enum NodeInstallAction {
    Yarn(YarnInstall),
    YarnOrNode(YarnInstall, NodeInstall),
    Node(NodeInstall),
}

/// Version strings extracted from `package.json` without any resolution against
/// catalog packages.
struct PackageJSONVersionsUnresolved {
    yarn: Option<String>,
    node: Option<String>,
}

impl Node {
    /// Determine the [NodeAction] that should be taken by the node hook.
    /// See tests for more information.
    pub async fn new(flox: &Flox, path: &Path) -> Result<Option<Self>> {
        // Check for a viable yarn
        // TODO: we should check for npm version as well,
        // but since npm comes bundled with nodejs, we'll probably cover the most
        // cases by just giving the requested node and hoping for the bundled
        // npm to work.
        // We could check if our one version of npm with its hardcoded nodejs
        // satisfies all constraints,
        // but that seems unlikely to be as commonly needed.
        let versions = Self::get_package_json_versions(path)?;
        let yarn_lock_path = path.join("yarn.lock");
        let yarn_lock_exists = yarn_lock_path.exists();
        let yarn_install = match versions {
            None => None,
            Some(ref versions) => {
                if yarn_lock_exists {
                    tracing::debug!(path = traceable_path(&yarn_lock_path), "found yarn.lock");
                    Self::try_find_compatible_yarn(flox, versions).await?
                } else {
                    tracing::debug!(
                        path = traceable_path(&yarn_lock_path),
                        "did not find a yarn.lock at this location"
                    );
                    None
                }
            },
        };

        let valid_package_json = versions.is_some();
        let package_json_and_package_lock =
            valid_package_json && path.join("package-lock.json").exists();

        // If there's yarn and not both a package.json and a package-lock.json,
        // return early with just yarn.
        if let Some(yarn_install) = &yarn_install {
            if !package_json_and_package_lock {
                return Ok(Some(Self {
                    action: NodeInstallAction::Yarn(yarn_install.clone()),
                    package_json_node_version: None,
                    nvmrc_version: None,
                }));
            }
        }

        // Get value for self.package_json_node_version.
        // We only do this if we didn't return early with action [NodeAction::YarnInstall]
        let package_json_node_version = match versions {
            None => None,
            Some(ref versions) => Self::try_find_compatible_nodejs(flox, versions).await?,
        };

        // Get value for self.nvmrc_version
        // We only do this if we didn't return early with action [NodeAction::YarnInstall]
        let nvmrc_version = match package_json_node_version {
            // package.json is higher priority than .nvmrc,
            // so don't check .nvmrc if we know we'll use the version in
            // package.json or we know we can't provide it
            Some(PackageJSONVersion::Found(_)) | Some(PackageJSONVersion::Unavailable) => None,
            _ => Self::get_nvmrc_version(flox, path).await?,
        };

        let node_install = Self::get_node_install(
            &package_json_node_version,
            &nvmrc_version,
            valid_package_json,
        );

        let action = match yarn_install {
            Some(yarn_install) => {
                node_install.map_or(
                    Some(NodeInstallAction::Yarn(yarn_install.clone())),
                    |node_install| {
                        // We know at this point that package-lock.json exists,
                        // because otherwise we would have returned above
                        Some(NodeInstallAction::YarnOrNode(yarn_install, node_install))
                    },
                )
            },
            None => {
                node_install.map(|mut node_install| {
                    // If yarn.lock exists but we couldn't find a compatible
                    // yarn, don't offer an npm hook
                    if yarn_lock_exists {
                        node_install.npm_hook = false;
                    }
                    NodeInstallAction::Node(node_install)
                })
            },
        };

        Ok(action.map(|action| Self {
            package_json_node_version,
            nvmrc_version,
            action,
        }))
    }

    /// Look for nodejs, npm, and yarn versions in a (possibly non-existent)
    /// `package.json` file
    fn get_package_json_versions(path: &Path) -> Result<Option<PackageJSONVersionsUnresolved>> {
        let package_json = path.join("package.json");
        if !package_json.exists() {
            tracing::debug!(
                path = traceable_path(&package_json),
                "did not find a package.json at this location"
            );
            return Ok(None);
        }
        tracing::debug!(path = traceable_path(&package_json), "found a package.json");
        let package_json_contents = fs::read_to_string(package_json)?;
        match serde_json::from_str::<serde_json::Value>(&package_json_contents) {
            // Treat a package.json that can't be parsed as JSON the same as it not existing
            Err(_) => {
                debug!("package.json not found or failed to parse");
                Ok(None)
            },
            Ok(package_json_json) => {
                let node = package_json_json["engines"]["node"]
                    .as_str()
                    .map(|s| s.to_string());
                let yarn = package_json_json["engines"]["yarn"]
                    .as_str()
                    .map(|s| s.to_string());
                debug!(
                    node = node.as_ref().unwrap_or(&"null".to_string()),
                    yarn = yarn.as_ref().unwrap_or(&"null".to_string()),
                    "detected package.json versions"
                );
                Ok(Some(PackageJSONVersionsUnresolved { node, yarn }))
            },
        }
    }

    /// Try to find node, npm, and yarn versions that satisfy constraints in
    /// package.json
    async fn try_find_compatible_yarn(
        flox: &Flox,
        versions: &PackageJSONVersionsUnresolved,
    ) -> Result<Option<YarnInstall>> {
        let PackageJSONVersionsUnresolved { yarn, .. } = versions;

        let found_node = match Self::try_find_compatible_nodejs(flox, versions).await? {
            // If the corresponding node isn't compatible, don't install yarn
            None => return Ok(None),
            Some(pkg_json_version) => {
                if let PackageJSONVersion::Found(pkg) = pkg_json_version {
                    pkg
                } else if let PackageJSONVersion::Unspecified = pkg_json_version {
                    try_find_compatible_package(flox, "nodejs", None)
                        .await?
                        .ok_or(anyhow!("Flox couldn't find nodejs in nixpkgs"))?
                } else {
                    return Ok(None);
                }
            },
        };

        // We assume that yarn is built with found_node, which is currently true
        // in nixpkgs
        let resolved_pkg_groups = try_find_compatible_major_version_package(
            flox,
            "yarn",
            &["yarn-berry", "yarn"],
            yarn.as_deref(),
        )
        .await?;
        let found_yarn = resolved_pkg_groups.first();

        Ok(found_yarn.map(|found_yarn| YarnInstall {
            yarn: found_yarn.clone(),
            node: found_node,
        }))
    }

    /// Try to find nodejs (alone) that satisfies constraints in package.json
    async fn try_find_compatible_nodejs(
        flox: &Flox,
        versions: &PackageJSONVersionsUnresolved,
    ) -> Result<Option<PackageJSONVersion>> {
        let PackageJSONVersionsUnresolved { node, .. } = versions;

        debug!(
            version = node.as_ref().unwrap_or(&"unspecified".to_string()),
            "trying to find compatible node version"
        );
        let nodejs_packages = Self::get_available_node_packages(flox).await?;
        let found_node = match node {
            Some(node_version) => {
                let resolved_groups = try_find_compatible_major_version_package(
                    flox,
                    "nodejs",
                    &nodejs_packages,
                    Some(node_version),
                )
                .await?;
                if let Some(result) = resolved_groups.first() {
                    Some(PackageJSONVersion::Found(result.clone()))
                } else {
                    Some(PackageJSONVersion::Unavailable)
                }
            },
            _ => {
                debug!("node version was unspecified");
                Some(PackageJSONVersion::Unspecified)
            },
        };

        Ok(found_node)
    }

    async fn get_available_node_packages(flox: &Flox) -> Result<Vec<String>> {
        let res = flox
            .catalog_client
            .search("nodejs_", flox.system.clone(), None)
            .await
            .context("failed to query node versions")?;
        // SAFETY: This expect/unwrap will catch an invalid regex at test time,
        //         so if we really screw this up it will be caught before hitting
        //         production.
        let node_pkg_regex = Regex::new(r#"nodejs_\d\d"#).expect("invalid node package regex");
        let matches = {
            let mut matches = res
                .results
                .into_iter()
                .filter_map(|search_result| {
                    let name = search_result.attr_path;
                    if node_pkg_regex.is_match(&name) {
                        Some(name)
                    } else {
                        None
                    }
                })
                .collect::<Vec<_>>();
            // This will sort lexically, but lexically sorting also sorts by
            // version in this case e.g. nodejs_14 comes before nodejs_23 in
            // both cases.
            matches.sort();
            // We want later versions towards the front so we can take the first
            // one.
            matches.reverse();
            // The search term was specifically "nodejs_" to catch the major version
            // packages.
            matches.push("nodejs".to_string());
            matches
        };

        Ok(matches)
    }

    /// Determine appropriate [NVMRCVersion] variant for a (possibly
    /// non-existent) `.nvmrc` file in `path`.
    ///
    /// This will perform a search to determine if a requested version is
    /// available.
    async fn get_nvmrc_version(flox: &Flox, path: &Path) -> Result<Option<NVMRCVersion>> {
        let nvmrc = path.join(".nvmrc");
        if !nvmrc.exists() {
            return Ok(None);
        }

        let nvmrc_contents = fs::read_to_string(&nvmrc)?;
        let nvmrc_version = match Self::parse_nvmrc_version(&nvmrc_contents) {
            RequestedNVMRCVersion::None => None,
            RequestedNVMRCVersion::Unsure => Some(NVMRCVersion::Unsure),
            RequestedNVMRCVersion::Found(ref version) => {
                match try_find_compatible_package(flox, "nodejs", Some(version)).await? {
                    None => Some(NVMRCVersion::Unavailable),
                    Some(result) => Some(NVMRCVersion::Found(result)),
                }
            },
        };
        Ok(nvmrc_version)
    }

    /// Translate the contents of a `.nvmrc` file into a [RequestedNVMRCVersion]
    fn parse_nvmrc_version(nvmrc_contents: &str) -> RequestedNVMRCVersion {
        // When reading from a file, nvm runs:
        // "$(command head -n 1 "${NVMRC_PATH}" | command tr -d '\r')" || command printf ''
        // https://github.com/nvm-sh/nvm/blob/294ff9e3aa8ce02bbf8d83fa235a363d9560a179/nvm.sh#L481
        let first_line = nvmrc_contents.lines().next();
        // From nvm --help:
        // <version> refers to any version-like string nvm understands. This includes:
        //   - full or partial version numbers, starting with an optional "v" (0.10, v0.1.2, v1)
        //   - default (built-in) aliases: node, stable, unstable, iojs, system
        //   - custom aliases you define with `nvm alias foo`
        match first_line {
            None => RequestedNVMRCVersion::None,
            Some(first_line) => {
                // nvm will fail if there's trailing whitespace,
                // so trimming whitespace is technically inconsistent,
                // but it's still probably a good recommendation from flox.
                let trimmed_first_line = first_line.trim();
                match trimmed_first_line {
                    "" => RequestedNVMRCVersion::None,
                    "node" | "stable" | "unstable" | "iojs" | "system" => {
                        RequestedNVMRCVersion::Unsure
                    },
                    _ if trimmed_first_line.starts_with('v')
                        && VersionReq::parse(&trimmed_first_line[1..]).is_ok() =>
                    {
                        RequestedNVMRCVersion::Found(trimmed_first_line[1..].to_string())
                    },
                    _ if VersionReq::parse(trimmed_first_line).is_ok() => {
                        RequestedNVMRCVersion::Found(trimmed_first_line.to_string())
                    },
                    _ => RequestedNVMRCVersion::Unsure,
                }
            },
        }
    }

    /// Return whether to skip the nodejs hook entirely, install a requested
    /// version of nodejs, or offer to install the Flox default version of
    /// nodejs.
    ///
    /// This is decided based on whether .nvmrc and package.json are present,
    /// and whether Flox can provide versions they request.
    fn get_node_install(
        package_json_node_version: &Option<PackageJSONVersion>,
        nvmrc_version: &Option<NVMRCVersion>,
        npm_hook: bool,
    ) -> Option<NodeInstall> {
        match (package_json_node_version, nvmrc_version) {
            // package.json takes precedence over .nvmrc
            (Some(PackageJSONVersion::Found(package)), _) => Some(NodeInstall {
                node: Some(package.clone()),
                npm_hook,
            }),
            // Treat the version in package.json strictly; if we can't find it, don't suggest something else.
            (Some(PackageJSONVersion::Unavailable), _) => None,
            (_, Some(NVMRCVersion::Found(package))) => Some(NodeInstall {
                node: Some(package.clone()),
                npm_hook,
            }),
            (_, Some(NVMRCVersion::Unsure)) => Some(NodeInstall {
                node: None,
                npm_hook,
            }),
            (_, Some(NVMRCVersion::Unavailable)) => Some(NodeInstall {
                node: None,
                npm_hook,
            }),
            (Some(PackageJSONVersion::Unspecified), None) => Some(NodeInstall {
                node: None,
                npm_hook,
            }),
            (None, None) => None,
        }
    }

    /// Returns:
    /// 1. A message describing what version of nodejs Flox found requested to
    ///    include in the prompt.
    /// 2. The version of nodejs Flox would install
    /// 3. Whether the message says Flox detected package.json (to avoid
    ///    printing that message twice)
    async fn nodejs_message_and_version(
        &self,
        flox: &Flox,
    ) -> Result<(String, Option<String>, bool)> {
        let mut mentions_package_json = false;
        let (message, version) = match (
            &self.package_json_node_version,
            self.nvmrc_version.as_ref(),
        ) {
            // package.json takes precedence over .nvmrc
            (Some(PackageJSONVersion::Found(result)), _) => {
                let message = format!(
                    "Flox detected a package.json compatible with node{}",
                    Self::format_version_or_empty(result.version.as_ref())
                );
                mentions_package_json = true;
                (message, result.version.clone())
            },
            // Treat the version in package.json strictly; if we can't find it, don't suggest something else.
            // get_action() returns NodeAction::Nothing for this case so it's unreachable
            (Some(PackageJSONVersion::Unavailable), _) => unreachable!(),
            (_, Some(NVMRCVersion::Found(result))) => {
                let message = format!(
                    "Flox detected an .nvmrc{}",
                    Self::format_version_or_empty(result.version.as_ref())
                );
                (message, result.version.clone())
            },
            (_, Some(NVMRCVersion::Unsure)) => {
                let result = find_compatible_package(flox, "nodejs", None).await?;
                let message = format!(
                    "Flox detected an .nvmrc with a version specifier not understood by Flox, but Flox can provide {}",
                    result
                        .version
                        .as_ref()
                        .map(|version| format!("version {version}"))
                        .unwrap_or("another version".to_string())
                );
                (message, result.version)
            },
            (_, Some(NVMRCVersion::Unavailable)) => {
                let result = find_compatible_package(flox, "nodejs", None).await?;
                let message = format!(
                    "Flox detected an .nvmrc with a version of nodejs not provided by Flox, but Flox can provide {}",
                    result
                        .version
                        .as_ref()
                        .map(|version| format!("version {version}"))
                        .unwrap_or("another version".to_string())
                );
                (message, result.version.clone())
            },
            (Some(PackageJSONVersion::Unspecified), None) => {
                let result = find_compatible_package(flox, "nodejs", None).await?;
                mentions_package_json = true;
                ("Flox detected a package.json".to_string(), result.version)
            },
            // get_action() returns NodeAction::Nothing for this case so it's unreachable
            (None, None) => unreachable!(),
        };
        Ok((message, version, mentions_package_json))
    }

    /// Helper function for [Self::prompt_with_node] and [Self::prompt_with_yarn]
    fn single_option_prompt(&self) -> Result<bool> {
        let message = indoc! {
        "Would you like Flox to apply this suggestion?
        You can always change the environment's manifest with 'flox edit'"};

        let dialog = Dialog {
            message,
            help_message: Some(AUTO_SETUP_HINT),
            typed: Select {
                options: ["Yes", "No", "Show suggested modifications"].to_vec(),
            },
        };
        let (mut choice, _) = dialog.clone().raw_prompt()?;

        while choice == 2 {
            message::plain(format_customization(&self.get_init_customization())?);

            (choice, _) = dialog.clone().raw_prompt()?;
        }

        Ok(choice == 0)
    }

    /// Prompt whether to install nodejs (but not npm or yarn)
    async fn prompt_with_node(&self, flox: &Flox, node_install: &NodeInstall) -> Result<bool> {
        let (nodejs_detected, nodejs_version, mentions_package_json) =
            self.nodejs_message_and_version(flox).await?;
        let mut detected = format!("{nodejs_detected}\n");
        if node_install.npm_hook {
            if !mentions_package_json {
                detected.push_str("Flox detected a package.json\n");
            }

            detected.push_str(&formatdoc! {"

                Flox can add the following to your environment:
                * nodejs{} with npm bundled
                * An npm installation hook
            ",
                Self::format_version_or_empty(nodejs_version.as_ref()),
            });
        } else {
            detected.push_str(&formatdoc! {"

                Flox can add the following to your environment:
                * nodejs{}
            ",
                Self::format_version_or_empty(nodejs_version.as_ref()),
            });
        }
        message::plain(detected);

        self.single_option_prompt()
    }

    /// Prompt whether to install yarn
    fn prompt_with_yarn(&self, yarn_install: &YarnInstall) -> Result<bool> {
        let yarn_version = Self::format_version_or_empty(yarn_install.yarn.version.as_ref());
        let node_version = Self::format_version_or_empty(yarn_install.node.version.as_ref());

        message::plain(formatdoc! {"
            Flox detected a package.json and a yarn.lock

            Flox can add the following to your environment:
            * yarn{yarn_version} with nodejs{node_version} bundled
            * A yarn installation hook
            "});

        self.single_option_prompt()
    }

    /// Prompt whether to install npm or yarn when either is viable
    async fn prompt_for_package_manager(
        &mut self,
        flox: &Flox,
        yarn_install: YarnInstall,
        node_install: NodeInstall,
    ) -> Result<bool> {
        let yarn_version = Self::format_version_or_empty(yarn_install.yarn.version.as_ref());
        let yarn_node_version = Self::format_version_or_empty(yarn_install.node.version.as_ref());
        let node_version = Self::format_version_or_empty(
            match &node_install.node {
                Some(found_node) => found_node.clone(),
                None => find_compatible_package(flox, "nodejs", None).await?,
            }
            .version
            .as_ref(),
        );

        message::plain(formatdoc! {"
            Flox detected both a package-lock.json and a yarn.lock

            Flox can add the following to your environment:
            * Either nodejs{node_version} with npm bundled, OR yarn{yarn_version} with nodejs{yarn_node_version} bundled
            * Either an npm installation hook, OR a yarn installation hook
            "});
        let message = formatdoc! {
        "Would you like Flox to apply one of these modifications?
         You can always change the environment's manifest with 'flox edit'"};
        let options = [
            "Yes - with npm",
            "Yes - with yarn",
            "No",
            "Show modifications with npm",
            "Show modifications with yarn",
        ]
        .to_vec();

        let dialog = Dialog {
            message: &message,
            help_message: Some(AUTO_SETUP_HINT),
            typed: Select {
                options: options.clone(),
            },
        };

        let (mut choice, _) = dialog.clone().raw_prompt()?;

        while choice == 3 || choice == 4 {
            // Temporarily set choice so self.get_init_customization() returns
            // the correct hook
            if choice == 3 {
                self.action = NodeInstallAction::Node(node_install.clone())
            } else if choice == 4 {
                self.action = NodeInstallAction::Yarn(yarn_install.clone())
            }
            message::plain(format_customization(&self.get_init_customization())?);

            (choice, _) = dialog.clone().raw_prompt()?;
        }

        if choice == 0 {
            self.action = NodeInstallAction::Node(node_install.clone())
        } else if choice == 1 {
            self.action = NodeInstallAction::Yarn(yarn_install.clone())
        }
        Ok(choice == 0 || choice == 1)
    }

    fn format_version_or_empty(version: Option<&String>) -> String {
        version
            .map(|version| format!(" {version}"))
            .unwrap_or("".to_string())
    }
}

impl InitHook for Node {
    async fn prompt_user(&mut self, flox: &Flox, _path: &Path) -> Result<bool> {
        match &self.action {
            NodeInstallAction::Yarn(yarn_install) => self.prompt_with_yarn(yarn_install),
            NodeInstallAction::YarnOrNode(yarn_install, node_install) => {
                self.prompt_for_package_manager(flox, yarn_install.clone(), node_install.clone())
                    .await
            },
            NodeInstallAction::Node(node_install) => {
                self.prompt_with_node(flox, node_install).await
            },
        }
    }

    fn get_init_customization(&self) -> InitCustomization {
        let mut packages = vec![];

        let hook_on_activate = match &self.action {
            NodeInstallAction::Yarn(yarn_install) => {
                packages.push(CatalogPackage {
                    id: "yarn".to_string(),
                    pkg_path: yarn_install.yarn.attr_path.clone().into(),
                    // TODO: we probably shouldn't pin this when we're just
                    // providing the default
                    version: yarn_install.yarn.version.clone(),
                    systems: None,
                });
                Some(YARN_HOOK.to_string())
            },
            // Default to node for InstallYarnOrNode
            // This is only reachable if --auto-setup is used.
            NodeInstallAction::YarnOrNode(_, node_install)
            | NodeInstallAction::Node(node_install) => {
                let nodejs_to_install = match &node_install.node {
                    Some(result) => CatalogPackage {
                        id: "nodejs".to_string(),
                        pkg_path: result.attr_path.clone().into(),
                        version: result.version.clone(),
                        systems: None,
                    },
                    None => CatalogPackage {
                        id: "nodejs".to_string(),
                        pkg_path: "nodejs".to_string(),
                        version: None,
                        systems: None,
                    },
                };
                packages.push(nodejs_to_install);
                if node_install.npm_hook {
                    Some(NPM_HOOK.to_string())
                } else {
                    None
                }
            },
        };

        InitCustomization {
            hook_on_activate,
            packages: Some(packages),
            ..Default::default()
        }
    }
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use flox_rust_sdk::data::System;
    use flox_rust_sdk::flox::test_helpers::flox_instance;
    use flox_rust_sdk::models::search::{SearchResult, SearchResults};
    use flox_rust_sdk::providers::catalog::test_helpers::{
        constraints_too_tight_dummy_response,
        resolved_pkg_group_with_dummy_package,
    };
    use flox_rust_sdk::providers::catalog::{Client, Response, SystemEnum};
    use pretty_assertions::assert_eq;
    use serde::Serialize;
    use serde_with::skip_serializing_none;

    use super::*;

    // TODO: Replace with httpmock generated fixture.
    fn search_response_nodejs_all() -> Response {
        let packages_versions = HashMap::from([
            ("nodejs_14", "14.21.3"),
            ("nodejs_16", "16.20.2"),
            ("nodejs_18", "18.20.8"),
            ("nodejs_19", "19.9.0"),
            ("nodejs_20", "20.19.0"),
            ("nodejs_21", "21.7.3"),
            ("nodejs_22", "22.14.0"),
            ("nodejs_23", "23.11.0"),
            ("nodejs_24", "24.0.0"),
            ("nodejs_latest", "24.0.0"),
        ]);

        Response::Search(SearchResults {
            count: Some(packages_versions.len() as u64),
            results: packages_versions
                .iter()
                .map(|(name, version)| SearchResult {
                    attr_path: name.to_string(),
                    catalog: None,
                    description: Some(
                        "Event-driven I/O framework for the V8 JavaScript engine".to_string(),
                    ),
                    name: format!("nodejs-{}", version),
                    pkg_path: name.to_string(),
                    pname: name.to_string(),
                    stabilities: vec![],
                    system: SystemEnum::Aarch64Darwin,
                    version: Some(version.to_string()),
                })
                .collect(),
        })
    }

    #[tokio::test]
    async fn new_detection() {
        #[skip_serializing_none]
        #[derive(Clone, Debug, Serialize, Default)]
        struct PackageJSON {
            engines: Option<Engines>,
        }
        #[skip_serializing_none]
        #[derive(Clone, Debug, Serialize, Default)]
        struct Engines {
            node: Option<String>,
            yarn: Option<String>,
        }

        #[derive(Clone, Debug)]
        struct File {
            name: String,
            content: String,
        }
        #[derive(Clone, Debug)]
        struct Package {
            name: String,
            version: String,
        }
        impl From<&Package> for ProvidedPackage {
            fn from(pkg: &Package) -> Self {
                ProvidedPackage {
                    name: pkg.name.clone(),
                    attr_path: pkg.name.clone().into(),
                    display_version: pkg.version.clone(),
                    version: Some(pkg.version.clone()),
                }
            }
        }
        #[derive(Debug)]
        struct TestCase {
            description: &'static str,
            files: Vec<File>,
            catalog_responses: Vec<Response>,
            expected: Option<Node>,
        }

        let yarn_package = Package {
            name: "yarn".to_string(),
            version: "1.1.1".to_string(),
        };
        let node_package = Package {
            name: "nodejs".to_string(),
            version: "2.2.2".to_string(),
        };

        fn dummy_pkg_to_resolved_pkg_group_response(pkg: &Package) -> Response {
            let pkg_group = resolved_pkg_group_with_dummy_package(
                &pkg.name,
                &"aarch64-darwin".to_string(),
                &pkg.name,
                &pkg.name,
                &pkg.version,
            );
            Response::Resolve(vec![pkg_group])
        }

        let test_cases = vec![
            // - Returns [NodeAction::InstallYarn] if
            //   - package.json and yarn.lock exist
            //   - We can find nodejs and yarn packages compatible with package.json
            //     engines
            //   - package-lock.json does not exist
            TestCase {
                description: "package.json and yarn.lock",
                files: vec![
                    File {
                        name: "package.json".to_string(),
                        content: serde_json::to_string(&PackageJSON {
                            engines: Some(Engines {
                                node: Some(node_package.version.clone()),
                                yarn: Some(yarn_package.version.clone()),
                            }),
                        })
                        .unwrap(),
                    },
                    File {
                        name: "yarn.lock".to_string(),
                        content: "".to_string(),
                    },
                ],
                catalog_responses: vec![
                    search_response_nodejs_all(),
                    dummy_pkg_to_resolved_pkg_group_response(&node_package),
                    dummy_pkg_to_resolved_pkg_group_response(&yarn_package),
                ],
                expected: Some(Node {
                    action: NodeInstallAction::Yarn(YarnInstall {
                        yarn: (&yarn_package).into(),
                        node: (&node_package).into(),
                    }),
                    package_json_node_version: None,
                    nvmrc_version: None,
                }),
            },
            // - Returns [NodeAction::InstallNode] if
            //   - .nvmrc or package.json exists
            //   - We can find nodejs compatible with package.json engines
            //     (.nvmrc is respected if possible,
            //     but we offer an alternative even if we can't satisfy its
            //     constraints)
            //   - yarn.lock does not exist
            TestCase {
                description: "package.json with satisified nodejs version",
                files: vec![File {
                    name: "package.json".to_string(),
                    content: serde_json::to_string(&PackageJSON {
                        engines: Some(Engines {
                            node: Some(node_package.version.clone()),
                            yarn: None,
                        }),
                    })
                    .unwrap(),
                }],
                catalog_responses: vec![
                    search_response_nodejs_all(),
                    dummy_pkg_to_resolved_pkg_group_response(&node_package),
                ],
                expected: Some(Node {
                    action: NodeInstallAction::Node(NodeInstall {
                        node: Some((&node_package).into()),
                        npm_hook: true,
                    }),
                    package_json_node_version: Some(PackageJSONVersion::Found(
                        (&node_package).into(),
                    )),
                    nvmrc_version: None,
                }),
            },
            TestCase {
                description: ".nvmrc with satisified version",
                files: vec![File {
                    name: ".nvmrc".to_string(),
                    content: "v0.1.14".to_string(),
                }],
                // There's no node version search when we install nvm
                catalog_responses: vec![dummy_pkg_to_resolved_pkg_group_response(&node_package)],
                expected: Some(Node {
                    action: NodeInstallAction::Node(NodeInstall {
                        node: Some((&node_package).into()),
                        npm_hook: false,
                    }),
                    package_json_node_version: None,
                    nvmrc_version: Some(NVMRCVersion::Found((&node_package).into())),
                }),
            },
            TestCase {
                description: "package.json with no engines",
                files: vec![File {
                    name: "package.json".to_string(),
                    content: serde_json::to_string(&PackageJSON { engines: None }).unwrap(),
                }],
                catalog_responses: vec![
                    search_response_nodejs_all(),
                    dummy_pkg_to_resolved_pkg_group_response(&node_package),
                    Response::Resolve(vec![constraints_too_tight_dummy_response("yarn")]),
                ],
                expected: Some(Node {
                    action: NodeInstallAction::Node(NodeInstall {
                        node: None,
                        npm_hook: true,
                    }),
                    package_json_node_version: Some(PackageJSONVersion::Unspecified),
                    nvmrc_version: None,
                }),
            },
            // returns YarnOrNode
            // - Returns [NodeAction::InstallYarnOrNode] if
            //   - Constraints for yarn and constraints for nodejs are met
            TestCase {
                description: "package.json, package-json.lock, and yarn.lock",
                files: vec![
                    File {
                        name: "package.json".to_string(),
                        content: serde_json::to_string(&PackageJSON {
                            engines: Some(Engines {
                                node: Some(node_package.version.clone()),
                                yarn: Some(yarn_package.version.clone()),
                            }),
                        })
                        .unwrap(),
                    },
                    File {
                        name: "package-lock.json".to_string(),
                        content: "".to_string(),
                    },
                    File {
                        name: "yarn.lock".to_string(),
                        content: "".to_string(),
                    },
                ],
                catalog_responses: vec![
                    search_response_nodejs_all(),
                    dummy_pkg_to_resolved_pkg_group_response(&node_package),
                    dummy_pkg_to_resolved_pkg_group_response(&yarn_package),
                    search_response_nodejs_all(),
                    dummy_pkg_to_resolved_pkg_group_response(&node_package),
                ],
                expected: Some(Node {
                    action: NodeInstallAction::YarnOrNode(
                        YarnInstall {
                            yarn: (&yarn_package).into(),
                            node: (&node_package).into(),
                        },
                        NodeInstall {
                            node: Some((&node_package).into()),
                            npm_hook: true,
                        },
                    ),
                    package_json_node_version: Some(PackageJSONVersion::Found(
                        (&node_package).into(),
                    )),
                    nvmrc_version: None,
                }),
            },
            // - Returns [None] if
            //   - There's no package.json or .nvmrc
            //   - We can't satisfy constraints in package.json
            TestCase {
                description: "no files at all",
                files: vec![],
                catalog_responses: vec![],
                expected: None,
            },
            TestCase {
                description: "constraints not met",
                files: vec![File {
                    name: "package.json".to_string(),
                    content: serde_json::to_string(&PackageJSON {
                        engines: Some(Engines {
                            node: Some("9.9.9".to_string()),
                            yarn: Some("9.9.9".to_string()),
                        }),
                    })
                    .unwrap(),
                }],
                catalog_responses: vec![
                    search_response_nodejs_all(),
                    Response::Resolve(vec![constraints_too_tight_dummy_response("nodejs_XX")]),
                ],
                expected: None,
            },
        ];

        for tc in test_cases {
            let (mut flox, temp_dir) = flox_instance();

            for File { name, content } in tc.files {
                let file = temp_dir.path().join(name);
                fs::write(file, content).unwrap();
            }

            if let Client::Mock(ref mut client) = flox.catalog_client {
                for resp in tc.catalog_responses.into_iter() {
                    client.push_response(resp);
                }
            }

            let node = Node::new(&flox, temp_dir.path()).await.unwrap();
            assert_eq!(node, tc.expected, "test case: {}", tc.description);
        }
    }

    #[test]
    fn parse_nvmrc_version_some() {
        assert_eq!(
            Node::parse_nvmrc_version("v0.1.14"),
            RequestedNVMRCVersion::Found("0.1.14".to_string())
        );
        assert_eq!(
            Node::parse_nvmrc_version("v20.11.1"),
            RequestedNVMRCVersion::Found("20.11.1".to_string())
        );
        assert_eq!(
            Node::parse_nvmrc_version("0.1.14"),
            RequestedNVMRCVersion::Found("0.1.14".to_string())
        );
        assert_eq!(
            Node::parse_nvmrc_version("0"),
            RequestedNVMRCVersion::Found("0".to_string())
        );
        assert_eq!(
            Node::parse_nvmrc_version("0.1"),
            RequestedNVMRCVersion::Found("0.1".to_string())
        );
        assert_eq!(
            Node::parse_nvmrc_version("0.1.14\n"),
            RequestedNVMRCVersion::Found("0.1.14".to_string())
        );
        assert_eq!(
            Node::parse_nvmrc_version("0.1.14   "),
            RequestedNVMRCVersion::Found("0.1.14".to_string())
        );
    }

    #[test]
    fn parse_nvmrc_version_unsure() {
        assert_eq!(
            Node::parse_nvmrc_version("node"),
            RequestedNVMRCVersion::Unsure
        );
        assert_eq!(
            Node::parse_nvmrc_version("0.1.14 blah blah"),
            RequestedNVMRCVersion::Unsure
        );
    }

    #[test]
    fn parse_nvmrc_version_none() {
        assert_eq!(Node::parse_nvmrc_version(""), RequestedNVMRCVersion::None);
        assert_eq!(Node::parse_nvmrc_version("\n"), RequestedNVMRCVersion::None);
    }

    /// Test get_init_customization() for action InstallYarn
    #[test]
    fn get_init_customization_yarn() {
        assert_eq!(
            Node {
                package_json_node_version: None,
                nvmrc_version: None,
                action: NodeInstallAction::Yarn(YarnInstall {
                    yarn: ProvidedPackage {
                        attr_path: "yarn.path".into(),
                        version: Some("1".to_string()),
                        name: "yarn".to_string(),
                        display_version: "1".to_string(),
                    },
                    node: ProvidedPackage {
                        name: "nodejs".to_string(),
                        attr_path: "nodejs".into(),
                        display_version: "N/A".to_string(),
                        version: None
                    },
                }),
            }
            .get_init_customization(),
            InitCustomization {
                packages: Some(vec![CatalogPackage {
                    id: "yarn".to_string(),
                    pkg_path: "yarn.path".to_string(),
                    version: Some("1".to_string()),
                    systems: None,
                }]),
                hook_on_activate: Some(YARN_HOOK.to_string()),
                ..Default::default()
            }
        );
    }

    /// Test get_init_customization() for action InstallYarnOrNode and npm_hook
    /// true
    #[test]
    fn get_init_customization_yarn_or_node() {
        assert_eq!(
            Node {
                package_json_node_version: None,
                nvmrc_version: None,
                action: NodeInstallAction::YarnOrNode(
                    YarnInstall {
                        yarn: ProvidedPackage {
                            name: "yarn".to_string(),
                            attr_path: "yarn".into(),
                            display_version: "N/A".to_string(),
                            version: None
                        },
                        node: ProvidedPackage {
                            name: "nodejs".to_string(),
                            attr_path: "nodejs".into(),
                            display_version: "N/A".to_string(),
                            version: None
                        },
                    },
                    NodeInstall {
                        node: Some(ProvidedPackage {
                            attr_path: "nodejs.path".into(),
                            version: Some("1".to_string()),
                            name: "nodejs".to_string(),
                            display_version: "1".to_string()
                        }),
                        npm_hook: true,
                    }
                ),
            }
            .get_init_customization(),
            InitCustomization {
                packages: Some(vec![CatalogPackage {
                    id: "nodejs".to_string(),
                    pkg_path: "nodejs.path".to_string(),
                    version: Some("1".to_string()),
                    systems: None,
                }]),
                hook_on_activate: Some(NPM_HOOK.to_string()),
                ..Default::default()
            }
        );
    }
    /// Test get_init_customization() for action InstallNode and npm_hook false
    #[test]
    fn get_init_customization_node() {
        assert_eq!(
            Node {
                package_json_node_version: None,
                nvmrc_version: None,
                action: NodeInstallAction::Node(NodeInstall {
                    node: Some(ProvidedPackage {
                        attr_path: "nodejs.path".into(),
                        version: Some("1".to_string()),
                        name: "nodejs".to_string(),
                        display_version: "1".to_string()
                    }),
                    npm_hook: false,
                })
            }
            .get_init_customization(),
            InitCustomization {
                packages: Some(vec![CatalogPackage {
                    id: "nodejs".to_string(),
                    pkg_path: "nodejs.path".to_string(),
                    version: Some("1".to_string()),
                    systems: None,
                }]),
                ..Default::default()
            }
        );
    }

    ///////////////////////////////////////////////////////////////////////////
    // Catalog tests
    ///////////////////////////////////////////////////////////////////////////

    /// Test finding yarn with no constraints succeeds
    #[tokio::test]
    async fn try_find_compatible_yarn_no_constraints_with_catalog() {
        let (mut flox, _temp_dir_handle) = flox_instance();

        if let Client::Mock(ref mut client) = flox.catalog_client {
            // Response to query available node versions
            client.push_response(search_response_nodejs_all());
            // Response for unconstrained nodejs version
            client.push_resolve_response(vec![resolved_pkg_group_with_dummy_package(
                "nodejs_group",
                &System::from("aarch64-darwin"),
                "nodejs",
                "nodejs",
                "18",
            )]);
            // Response for unconstrained yarn version
            client.push_resolve_response(vec![resolved_pkg_group_with_dummy_package(
                "yarn_group",
                &System::from("aarch64-darwin"),
                "yarn",
                "yarn",
                "1.22",
            )]);
        }
        let yarn_install = Node::try_find_compatible_yarn(&flox, &PackageJSONVersionsUnresolved {
            yarn: None,
            node: None,
        })
        .await
        .unwrap()
        .unwrap();

        assert_eq!(yarn_install.node.attr_path, "nodejs".into());
        assert_eq!(yarn_install.yarn.attr_path, "yarn".into());
    }

    /// Test finding yarn with the version of nixpkgs#nodejs specified succeeds
    #[tokio::test]
    async fn try_find_compatible_yarn_node_available_with_catalog() {
        let (mut flox, _temp_dir_handle) = flox_instance();

        if let Client::Mock(ref mut client) = flox.catalog_client {
            // Response to query available node versions
            client.push_response(search_response_nodejs_all());
            // Response when nodejs 18 is requested
            client.push_resolve_response(vec![
                // Here rather than writing out all N node versions we support,
                // I've listed at least one non-matching version, the correct
                // version, and the catch-all "nodejs" package
                constraints_too_tight_dummy_response("nodejs_20"),
                resolved_pkg_group_with_dummy_package(
                    "nodejs_group",
                    &System::from("aarch64-darwin"),
                    "nodejs_18",
                    "nodejs_18",
                    "18",
                ),
                resolved_pkg_group_with_dummy_package(
                    "nodejs_group",
                    &System::from("aarch64-darwin"),
                    "nodejs",
                    "nodejs",
                    "18",
                ),
            ]);
            // Response for unconstrained yarn version
            client.push_resolve_response(vec![resolved_pkg_group_with_dummy_package(
                "yarn_group",
                &System::from("aarch64-darwin"),
                "yarn",
                "yarn",
                "1.22",
            )]);
        }
        let yarn_install = Node::try_find_compatible_yarn(&flox, &PackageJSONVersionsUnresolved {
            yarn: None,
            node: Some("18".to_string()),
        })
        .await
        .unwrap()
        .unwrap();

        assert_eq!(yarn_install.node.attr_path, "nodejs_18".into());
        assert!(yarn_install.node.version.unwrap().starts_with("18"));
        assert_eq!(yarn_install.yarn.attr_path, "yarn".into());
    }

    /// Test finding yarn with a version of node other than that of
    /// nixpkgs#nodejs fails
    #[tokio::test]
    async fn try_find_compatible_yarn_node_unavailable_with_catalog() {
        let (mut flox, _temp_dir_handle) = flox_instance();

        if let Client::Mock(ref mut client) = flox.catalog_client {
            // Response to query available node versions
            client.push_response(search_response_nodejs_all());
            // No version of node satisfies this version requirement
            // Again, this is just an arbitrary number of node versions
            // since there's so many of them.
            client.push_resolve_response(vec![
                constraints_too_tight_dummy_response("nodejs_23"),
                constraints_too_tight_dummy_response("nodejs_18"),
                constraints_too_tight_dummy_response("nodejs"),
            ]);
        }
        let yarn_install = Node::try_find_compatible_yarn(&flox, &PackageJSONVersionsUnresolved {
            yarn: None,
            node: Some("25".to_string()),
        })
        .await
        .unwrap();

        assert_eq!(yarn_install, None);
    }

    /// Test finding yarn with the version nixpkgs#yarn specified succeeds
    #[tokio::test]
    async fn try_find_compatible_yarn_yarn_available_with_catalog() {
        let (mut flox, _temp_dir_handle) = flox_instance();

        if let Client::Mock(ref mut client) = flox.catalog_client {
            // Response to query available node versions
            client.push_response(search_response_nodejs_all());
            // Response for unconstrained nodejs version
            client.push_resolve_response(vec![resolved_pkg_group_with_dummy_package(
                "nodejs_group",
                &System::from("aarch64-darwin"),
                "nodejs",
                "nodejs",
                "18",
            )]);
            // Response when yarn version 1 is requested
            client.push_resolve_response(vec![resolved_pkg_group_with_dummy_package(
                "yarn_group",
                &System::from("aarch64-darwin"),
                "yarn",
                "yarn",
                "1.22",
            )]);
        }
        let yarn_install = Node::try_find_compatible_yarn(&flox, &PackageJSONVersionsUnresolved {
            yarn: Some("1".to_string()),
            node: None,
        })
        .await
        .unwrap()
        .unwrap();

        assert_eq!(yarn_install.node.attr_path, "nodejs".into());
        assert_eq!(yarn_install.yarn.attr_path, "yarn".into());
        assert!(yarn_install.yarn.version.unwrap().starts_with('1'));
    }

    /// Test finding yarn with a version of yarn other than that of
    /// nixpkgs#yarn fails
    #[tokio::test]
    async fn try_find_compatible_yarn_yarn_unavailable_with_catalog() {
        let (mut flox, _temp_dir_handle) = flox_instance();

        if let Client::Mock(ref mut client) = flox.catalog_client {
            // Response to query available node versions
            client.push_response(search_response_nodejs_all());
            // Response for unconstrained nodejs version
            client.push_resolve_response(vec![resolved_pkg_group_with_dummy_package(
                "nodejs_group",
                &System::from("aarch64-darwin"),
                "nodejs",
                "nodejs",
                "18",
            )]);
            // Response for yarn version 2 (resolution failure)
            client.push_resolve_response(vec![]);
        }
        let yarn_install = Node::try_find_compatible_yarn(&flox, &PackageJSONVersionsUnresolved {
            yarn: Some("2".to_string()),
            node: None,
        })
        .await
        .unwrap();

        assert_eq!(yarn_install, None);
    }

    /// Test finding yarn with versions of nixpkgs#yarn and nixpkgs#nodejs
    /// specified succeeds
    #[tokio::test]
    async fn try_find_compatible_yarn_both_available_with_catalog() {
        let (mut flox, _temp_dir_handle) = flox_instance();

        if let Client::Mock(ref mut client) = flox.catalog_client {
            // Response to query available node versions
            client.push_response(search_response_nodejs_all());
            // Response for nodejs version 18
            client.push_resolve_response(vec![
                constraints_too_tight_dummy_response("nodejs_23"),
                constraints_too_tight_dummy_response("nodejs_21"),
                constraints_too_tight_dummy_response("nodejs_20"),
                resolved_pkg_group_with_dummy_package(
                    "nodejs_group",
                    &System::from("aarch64-darwin"),
                    "nodejs_18",
                    "nodejs_18",
                    "18",
                ),
            ]);
            // Response for yarn version 1
            client.push_resolve_response(vec![resolved_pkg_group_with_dummy_package(
                "yarn_group",
                &System::from("aarch64-darwin"),
                "yarn",
                "yarn",
                "1.22",
            )]);
        }
        let yarn_install = Node::try_find_compatible_yarn(&flox, &PackageJSONVersionsUnresolved {
            yarn: Some("1".to_string()),
            node: Some("18".to_string()),
        })
        .await
        .unwrap()
        .unwrap();

        assert_eq!(yarn_install.node.attr_path, "nodejs_18".into());
        assert!(yarn_install.node.version.unwrap().starts_with("18"));
        assert_eq!(yarn_install.yarn.attr_path, "yarn".into());
        assert!(yarn_install.yarn.version.unwrap().starts_with('1'));
    }
}
