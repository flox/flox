use std::collections::{BTreeMap, HashMap};
use std::ops::{Deref, DerefMut};
use std::str::FromStr;

use indoc::{formatdoc, indoc};
use log::debug;
#[cfg(test)]
use proptest::prelude::*;
use serde::de::Error;
use serde::{Deserialize, Serialize};
use serde_with::skip_serializing_none;
use toml_edit::{self, Array, DocumentMut, Formatted, InlineTable, Item, Key, Table, Value};
use url::Url;

use super::environment::path_environment::InitCustomization;
use crate::data::{System, Version};
#[cfg(test)]
use crate::utils::proptest_btree_map_alphanum_keys;

pub(super) const DEFAULT_GROUP_NAME: &str = "toplevel";
pub(super) const DEFAULT_PRIORITY: usize = 5;

/// Represents the `[version]` number key in manifest.toml
pub const MANIFEST_VERSION_KEY: &str = "version";
/// Represents the `[install]` table key in manifest.toml
pub const MANIFEST_INSTALL_KEY: &str = "install";
/// Represents the `[vars]` table key in manifest.toml
pub const MANIFEST_VARS_KEY: &str = "vars";
/// Represents the `[hook]` table key in manifest.toml
pub const MANIFEST_HOOK_KEY: &str = "hook";
/// Represents the `[profile]` table key in manifest.toml
pub const MANIFEST_PROFILE_KEY: &str = "profile";
/// Represents the `[options]` table key in manifest.toml
pub const MANIFEST_OPTIONS_KEY: &str = "options";
/// Represents the `systems = []` array key in manifest.toml
pub const MANIFEST_SYSTEMS_KEY: &str = "systems";

/// A wrapper around a [`toml_edit::DocumentMut`]
/// that allows modifications of the raw manifest document,
/// while preserving comments and user formatting.
#[derive(Clone, Debug)]
pub struct RawManifest(toml_edit::DocumentMut);
impl RawManifest {
    /// Creates a new [RawManifest] instance, populating its configuration from
    /// fields in `customization` [InitCustomization] and systems [System] arguments.
    ///
    /// Additionally, this method prefixes each table with documentation on its usage, and
    /// and inserts commented configuration examples for tables left empty.
    pub fn new_documented(
        systems: &[&System],
        customization: &InitCustomization,
        use_catalog: bool,
    ) -> RawManifest {
        let mut manifest = DocumentMut::new();

        // `version` number
        if use_catalog {
            manifest.insert(MANIFEST_VERSION_KEY, toml_edit::value(1));
        }

        // `[install]` table
        let packages_vec = vec![];
        let packages = customization.packages.as_ref().unwrap_or(&packages_vec);

        let mut install_table = if packages.is_empty() {
            // Add comment with example packages
            let mut table = Table::new();

            table.decor_mut().set_suffix(indoc! {r#"

                # hello.pkg-path = "hello"
                # nodejs = { version = "^18.4.2", pkg-path = "nodejs_18" }"#
            });

            table
        } else {
            Table::from_iter(packages.iter().map(|pkg| (&pkg.id, InlineTable::from(pkg))))
        };

        install_table.decor_mut().set_prefix(indoc! {r#"

            # List packages you wish to install in your environment inside
            # the `[install]` section.
        "#});

        manifest.insert(MANIFEST_INSTALL_KEY, Item::Table(install_table));

        // `[vars]` table
        let mut vars_table = Table::new();

        vars_table.decor_mut().set_prefix(indoc! {r#"

            # Set environment variables in the `[vars]` section. These variables may not
            # reference one another, and are added to the environment without first
            # expanding them. They are available for use in the `[profile]` and `[hook]`
            # scripts.
        "#});

        // [sic]: vars not customized using InitCustomization yet
        vars_table.decor_mut().set_suffix(indoc! {r#"

            # message = "Howdy""#});

        manifest.insert(MANIFEST_VARS_KEY, Item::Table(vars_table));

        // `[hook]` table
        let mut hook_table = Table::new();

        hook_table.decor_mut().set_prefix(indoc! {r#"

            # The `hook.on-activate` script is run by the *bash* shell immediately upon
            # activating an environment, and will not be invoked if Flox detects that the
            # environment has previously been activated. Variables set by the script will
            # be inherited by `[profile]` scripts defined below. Note that any stdout
            # generated by the script will be redirected to stderr.
        "#});

        if let Some(ref hook_on_activate_script) = customization.hook_on_activate {
            let on_activate_content = indent::indent_all_by(2, hook_on_activate_script);

            hook_table.insert("on-activate", toml_edit::value(on_activate_content));
        } else {
            hook_table.decor_mut().set_suffix(indoc! {r#"

                # on-activate = '''
                #   # Set variables, create files and directories
                #   venv_dir="$(mktemp -d)"
                #   export venv_dir
                #
                #   # Perform initialization steps, e.g. create a python venv
                #   python -m venv "$venv_dir"
                # '''"#
            });
        };

        manifest.insert(MANIFEST_HOOK_KEY, Item::Table(hook_table));

        // `[profile]` table
        let mut profile_table = Table::new();

        profile_table.decor_mut().set_prefix(indoc! {r#"

            # Scripts defined in the `[profile]` section are *sourced* by *your shell* and
            # inherit environment variables set in the `[vars]` section and by `[hook]` scripts.
            # The `profile.common` script is sourced by all shells and special care should be
            # taken to ensure compatibility with all shells, after which exactly one of
            # `profile.{bash,fish,tcsh,zsh}` is sourced by the corresponding shell.
        "#});

        match customization {
            InitCustomization {
                profile_common: None,
                profile_bash: None,
                profile_fish: None,
                profile_tcsh: None,
                profile_zsh: None,
                ..
            } => {
                profile_table.decor_mut().set_suffix(indoc! {r#"

                    # common = '''
                    #   echo "it's gettin' flox in here"
                    # '''"#
                });
            },
            _ => {
                if let Some(profile_common) = &customization.profile_common {
                    profile_table.insert(
                        "common",
                        toml_edit::value(indent::indent_all_by(2, profile_common)),
                    );
                }
                if let Some(profile_bash) = &customization.profile_bash {
                    profile_table.insert(
                        "bash",
                        toml_edit::value(indent::indent_all_by(2, profile_bash)),
                    );
                }
                if let Some(profile_fish) = &customization.profile_fish {
                    profile_table.insert(
                        "fish",
                        toml_edit::value(indent::indent_all_by(2, profile_fish)),
                    );
                }
                if let Some(profile_tcsh) = &customization.profile_tcsh {
                    profile_table.insert(
                        "tcsh",
                        toml_edit::value(indent::indent_all_by(2, profile_tcsh)),
                    );
                }
                if let Some(profile_zsh) = &customization.profile_zsh {
                    profile_table.insert(
                        "zsh",
                        toml_edit::value(indent::indent_all_by(2, profile_zsh)),
                    );
                }
            },
        };

        manifest.insert(MANIFEST_PROFILE_KEY, Item::Table(profile_table));

        // `[options]` table
        let mut options_table = Table::new();

        options_table.decor_mut().set_prefix(indoc! {r#"

            # Additional options can be set in the `[options]` section. Refer to
            # manifest.toml(5) for a list of available options.
        "#});

        // `systems` array
        let mut systems_key = Key::new(MANIFEST_SYSTEMS_KEY);
        systems_key.leaf_decor_mut().set_prefix(indoc! {r#"

                # An environment that works on one system is guaranteed to work on the same type
                # of system, but other systems may not have the same packages available, etc.
                # In order to use the environment on a system you must explicitly add it to the
                # `options.systems` list.
            "#});

        options_table.insert(
            &systems_key,
            toml_edit::value(Array::from_iter(systems.iter().copied())),
        );

        let cuda_detection_key = Key::new("cuda-detection");
        options_table.insert(&cuda_detection_key, toml_edit::value(false));
        if let Some((mut key, _)) = options_table.get_key_value_mut(&cuda_detection_key) {
            key.leaf_decor_mut().set_prefix(indoc! {r#"
            # Uncomment to disable CUDA detection.
            # "#});
        }

        manifest.insert(MANIFEST_OPTIONS_KEY, Item::Table(options_table));

        // Insert heading comment
        if let Some((mut key, item)) = manifest.iter_mut().next() {
            if let Some(decor) = match item {
                Item::Value(_) => Some(key.leaf_decor_mut()),
                Item::Table(table) => Some(table.decor_mut()),
                _ => None,
            } {
                decor.set_prefix(formatdoc! {r#"
                  #
                  # This is a Flox environment manifest.
                  # Visit flox.dev/docs/concepts/manifest/
                  # or see flox-edit(1), manifest.toml(5) for more information.
                  #
                  {}"#,
                decor.prefix().and_then(|raw_str| raw_str.as_str()).unwrap_or("")})
            }
        }

        RawManifest(manifest)
    }

    /// Get the version of the manifest.
    fn get_version(&self) -> Option<i64> {
        self.0.get("version").and_then(Item::as_integer)
    }

    /// Serde's error messages for _untagged_ enums are rather bad
    /// and don't appear to become better any time soon:
    /// - <https://github.com/serde-rs/serde/pull/1544>
    /// - <https://github.com/serde-rs/serde/pull/2376>
    ///
    /// This function aims to provide the intermediate version matching on
    /// the `version` field, and then deserializes the correct version
    /// of the Manifest explicitly.
    ///
    /// <https://github.com/serde-rs/serde/pull/2525> will allow the use of integers
    /// (i.e. versions) as enum tags, which will allow us to use `#[serde(tag = "version")]`
    /// and avoid the [Version] field entirely, where the version field is not optional.
    ///
    /// Discussion: using a string field as the version tag `version: "1"` vs `version: 1`
    /// could work today, but is still limited by the lack of an optional tag.
    pub fn to_typed(&self) -> Result<TypedManifest, toml_edit::de::Error> {
        match self.get_version() {
            Some(1) => Ok(TypedManifest::Catalog(toml_edit::de::from_document(
                self.0.clone(),
            )?)),
            None => Ok(TypedManifest::Pkgdb(toml_edit::de::from_document(
                self.0.clone(),
            )?)),
            Some(v) => {
                let msg = format!("unsupported manifest version: {v}");
                Err(toml_edit::de::Error::custom(msg))
            },
        }
    }
}

impl FromStr for RawManifest {
    type Err = toml_edit::de::Error;

    /// Parses a string to a `ManifestMut` and validates that it's a valid manifest
    /// Validation is currently only checking the structure of the manifest,
    /// not the precise contents.
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let doc = s.parse::<DocumentMut>()?;
        let manifest = RawManifest(doc);
        let _validate = manifest.to_typed()?;
        Ok(manifest)
    }
}

impl Deref for RawManifest {
    type Target = DocumentMut;

    // Allows accessing the [DocumentMut] instance wrapped by [RawManifest].
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for RawManifest {
    // Allows accessing the mutable [DocumentMut] instance wrapped by [RawManifest].
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

/// Represents the Manifest data schema for reading/processing of the manifest.
/// Writing a [`TypedManifest`] will drop comments and formatting.
/// Hence, this should only be used in cases where these can safely be severed.
/// Edits to the user facing manifest.toml file should be made using [`RawManifest`] instead.
#[derive(Debug, Clone, Serialize, PartialEq)]
#[cfg_attr(test, derive(proptest_derive::Arbitrary))]
#[serde(untagged)]
pub enum TypedManifest {
    /// v1 manifest, processed by flox and resolved using the catalog service
    Catalog(Box<TypedManifestCatalog>),
    /// deprecated ~v0~ manifest, processed entirely by `pkgdb`
    #[cfg_attr(test, proptest(skip))]
    Pkgdb(TypedManifestPkgdb),
}

/// Not meant for writing manifest files, only for reading them.
/// Modifications should be made using the the raw functions in this module.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Default)]
#[cfg_attr(test, derive(proptest_derive::Arbitrary))]
#[serde(deny_unknown_fields)]
pub struct TypedManifestCatalog {
    pub version: Version<1>,
    /// The packages to install in the form of a map from install_id
    /// to package descriptor.
    #[serde(default)]
    pub install: ManifestInstall,
    /// Variables that are exported to the shell environment upon activation.
    #[serde(default)]
    pub vars: ManifestVariables,
    /// Hooks that are run at various times during the lifecycle of the manifest
    /// in a known shell environment.
    #[serde(default)]
    pub hook: ManifestHook,
    /// Profile scripts that are run in the user's shell upon activation.
    #[serde(default)]
    pub profile: ManifestProfile,
    /// Options that control the behavior of the manifest.
    #[serde(default)]
    pub options: ManifestOptions,
    /// Service definitions
    #[serde(default)]
    #[serde(skip_serializing_if = "BTreeMap::is_empty")]
    pub services: ManifestServices,
}

impl TypedManifestCatalog {
    /// Get the package descriptor with the specified install_id.
    pub fn pkg_descriptor_with_id(&self, id: impl AsRef<str>) -> Option<ManifestPackageDescriptor> {
        self.install.0.get(id.as_ref()).cloned()
    }

    /// Get the package descriptor with the specified install_id.
    pub fn catalog_pkg_descriptor_with_id(
        &self,
        id: impl AsRef<str>,
    ) -> Option<ManifestPackageDescriptorCatalog> {
        self.install
            .0
            .get(id.as_ref())
            .and_then(ManifestPackageDescriptor::as_catalog_descriptor_ref)
            .cloned()
    }

    /// Get the package descriptor with the specified install_id.
    pub fn flake_pkg_descriptor_with_id(
        &self,
        id: impl AsRef<str>,
    ) -> Option<ManifestPackageDescriptor> {
        self.install.0.get(id.as_ref()).cloned()
    }

    /// Get the package descriptors in the "toplevel" group.
    pub fn pkg_descriptors_in_toplevel_group(&self) -> Vec<(String, ManifestPackageDescriptor)> {
        pkg_descriptors_in_toplevel_group(&self.install.0)
    }

    /// Get the package descriptors in a named group.
    pub fn pkg_descriptors_in_named_group(
        &self,
        name: impl AsRef<str>,
    ) -> Vec<(String, ManifestPackageDescriptor)> {
        pkg_descriptors_in_named_group(name, &self.install.0)
    }

    /// Check whether the specified name is either an install_id or group name.
    pub fn pkg_or_group_found_in_manifest(&self, name: impl AsRef<str>) -> bool {
        pkg_or_group_found_in_manifest(name.as_ref(), &self.install.0)
    }

    /// Check whether the specified package belongs to a named group
    /// with additional packages.
    pub fn pkg_belongs_to_non_empty_named_group(
        &self,
        pkg: impl AsRef<str>,
    ) -> Result<Option<String>, ManifestError> {
        pkg_belongs_to_non_empty_named_group(pkg.as_ref(), &self.install.0)
    }

    /// Check whether the specified package belongs to the "toplevel" group
    /// with additional packages.
    pub fn pkg_belongs_to_non_empty_toplevel_group(
        &self,
        pkg: impl AsRef<str>,
    ) -> Result<bool, ManifestError> {
        pkg_belongs_to_non_empty_toplevel_group(pkg.as_ref(), &self.install.0)
    }
}

pub(crate) fn pkg_descriptors_in_toplevel_group(
    descriptors: &BTreeMap<String, ManifestPackageDescriptor>,
) -> Vec<(String, ManifestPackageDescriptor)> {
    descriptors
        .iter()
        .filter(|(_, desc)| {
            let ManifestPackageDescriptor::Catalog(ManifestPackageDescriptorCatalog {
                pkg_group,
                ..
            }) = desc
            else {
                return false;
            };

            pkg_group.is_none()
        })
        .map(|(id, desc)| (id.clone(), desc.clone()))
        .collect::<Vec<_>>()
}

pub(crate) fn pkg_descriptors_in_named_group(
    name: impl AsRef<str>,
    descriptors: &BTreeMap<String, ManifestPackageDescriptor>,
) -> Vec<(String, ManifestPackageDescriptor)> {
    descriptors
        .iter()
        .filter(|(_, desc)| {
            let ManifestPackageDescriptor::Catalog(ManifestPackageDescriptorCatalog {
                pkg_group,
                ..
            }) = desc
            else {
                return false;
            };

            pkg_group
                .as_ref()
                .is_some_and(|n| n.as_str() == name.as_ref())
        })
        .map(|(id, desc)| (id.clone(), desc.clone()))
        .collect::<Vec<_>>()
}

/// Scans the provided package descriptors to determine if the search term is a package or
/// group in the manifest.

fn pkg_or_group_found_in_manifest(
    search_term: impl AsRef<str>,
    descriptors: &BTreeMap<String, ManifestPackageDescriptor>,
) -> bool {
    descriptors.iter().any(|(id, desc)| {
        let ManifestPackageDescriptor::Catalog(ManifestPackageDescriptorCatalog {
            pkg_group, ..
        }) = desc
        else {
            return false;
        };

        let search_term = search_term.as_ref();

        (search_term == id.as_str()) || (Some(search_term) == pkg_group.as_deref())
    })
}

/// named group in the manifest with other packages.
fn pkg_belongs_to_non_empty_named_group(
    pkg: &str,
    descriptors: &BTreeMap<String, ManifestPackageDescriptor>,
) -> Result<Option<String>, ManifestError> {
    let descriptor = descriptors
        .get(pkg)
        .ok_or(ManifestError::PkgOrGroupNotFound(pkg.to_string()))?;

    let ManifestPackageDescriptor::Catalog(ManifestPackageDescriptorCatalog { pkg_group, .. }) =
        descriptor
    else {
        return Ok(None);
    };

    let Some(ref group) = pkg_group else {
        return Ok(None);
    };
    let pkgs = pkg_descriptors_in_named_group(group, descriptors);
    let other_pkgs_in_group = pkgs.iter().any(|(id, _)| id != pkg);
    if other_pkgs_in_group {
        Ok(Some(group.clone()))
    } else {
        Ok(None)
    }
}

/// Scans the provided package descriptors to determine if the specified package belongs to
/// the "toplevel" group with other packages.
fn pkg_belongs_to_non_empty_toplevel_group(
    pkg: &str,
    descriptors: &BTreeMap<String, ManifestPackageDescriptor>,
) -> Result<bool, ManifestError> {
    descriptors
        .get(pkg)
        .ok_or(ManifestError::PkgOrGroupNotFound(pkg.to_string()))?;
    let pkgs = pkg_descriptors_in_toplevel_group(descriptors);
    let other_toplevel_packages_exist = pkgs.iter().any(|(id, _)| id != pkg);
    Ok(other_toplevel_packages_exist)
}

#[derive(
    Debug,
    Clone,
    Serialize,
    Deserialize,
    Default,
    PartialEq,
    derive_more::Deref,
    derive_more::DerefMut,
)]
#[cfg_attr(test, derive(proptest_derive::Arbitrary))]
pub struct ManifestInstall(
    #[cfg_attr(
        test,
        proptest(
            strategy = "proptest_btree_map_alphanum_keys::<ManifestPackageDescriptor>(10, 3)"
        )
    )]
    BTreeMap<String, ManifestPackageDescriptor>,
);

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[cfg_attr(test, derive(proptest_derive::Arbitrary))]
// todo: this can make the error messages less clear and might call for a custom (de)serialize impl
#[serde(
    untagged,
    expecting = "Expected either a catalog package descriptor or flake installable.
See https://flox.dev/docs/concepts/manifest/#package-descriptors for more information."
)]
pub enum ManifestPackageDescriptor {
    Catalog(ManifestPackageDescriptorCatalog),
    FlakeRef(ManifestPackageDescriptorFlake),
    // TODO: StorePath(ManifestPackageDescriptorStorePath),
}

impl ManifestPackageDescriptor {
    /// Check if two package descriptors should have the same resolution.
    /// This is used to determine if a package needs to be re-resolved
    /// in the presence of an existing lock.
    ///
    /// * Descriptors are resolved per system,
    ///   changing the supported systems does not invalidate _existing_ resolutions.
    /// * Priority is not used in resolution, so it is ignored.
    pub(super) fn invalidates_existing_resolution(&self, other: &Self) -> bool {
        use ManifestPackageDescriptor::*;
        match (self, other) {
            (Catalog(this), Catalog(other)) => this.invalidates_existing_resolution(other),
            (FlakeRef(this), FlakeRef(other)) => this != other,
            // different types of descriptors are always different
            _ => true,
        }
    }

    #[must_use]
    pub fn unwrap_catalog_descriptor(self) -> Option<ManifestPackageDescriptorCatalog> {
        match self {
            ManifestPackageDescriptor::Catalog(descriptor) => Some(descriptor),
            _ => None,
        }
    }

    #[must_use]
    pub fn as_catalog_descriptor_ref(&self) -> Option<&ManifestPackageDescriptorCatalog> {
        match self {
            ManifestPackageDescriptor::Catalog(descriptor) => Some(descriptor),
            _ => None,
        }
    }

    #[must_use]
    pub fn unwrap_flake_descriptor(self) -> Option<ManifestPackageDescriptorFlake> {
        match self {
            ManifestPackageDescriptor::FlakeRef(descriptor) => Some(descriptor),
            _ => None,
        }
    }

    #[must_use]
    pub fn as_flake_descriptor_ref(&self) -> Option<&ManifestPackageDescriptorFlake> {
        match self {
            ManifestPackageDescriptor::FlakeRef(descriptor) => Some(descriptor),
            _ => None,
        }
    }
}

impl From<&ManifestPackageDescriptorCatalog> for ManifestPackageDescriptor {
    fn from(val: &ManifestPackageDescriptorCatalog) -> Self {
        ManifestPackageDescriptor::Catalog(val.clone())
    }
}

impl From<ManifestPackageDescriptorCatalog> for ManifestPackageDescriptor {
    fn from(val: ManifestPackageDescriptorCatalog) -> Self {
        ManifestPackageDescriptor::Catalog(val)
    }
}

impl From<&ManifestPackageDescriptorFlake> for ManifestPackageDescriptor {
    fn from(val: &ManifestPackageDescriptorFlake) -> Self {
        ManifestPackageDescriptor::FlakeRef(val.clone())
    }
}

impl From<ManifestPackageDescriptorFlake> for ManifestPackageDescriptor {
    fn from(val: ManifestPackageDescriptorFlake) -> Self {
        ManifestPackageDescriptor::FlakeRef(val)
    }
}

#[skip_serializing_none]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[cfg_attr(test, derive(proptest_derive::Arbitrary))]
#[serde(rename_all = "kebab-case")]
#[serde(deny_unknown_fields)]
pub struct ManifestPackageDescriptorCatalog {
    pub(crate) pkg_path: String,
    pub(crate) pkg_group: Option<String>,
    #[cfg_attr(test, proptest(strategy = "proptest::option::of(0..10usize)"))]
    pub(crate) priority: Option<usize>,
    pub(crate) version: Option<String>,
    #[cfg_attr(
        test,
        proptest(
            strategy = "proptest::option::of(proptest::collection::vec(any::<System>(), 1..3))"
        )
    )]
    pub(crate) systems: Option<Vec<System>>,
}

impl ManifestPackageDescriptorCatalog {
    /// Check if two package descriptors should have the same resolution.
    /// This is used to determine if a package needs to be re-resolved
    /// in the presence of an existing lock.
    ///
    /// * Descriptors are resolved per system,
    ///   changing the supported systems does not invalidate _existing_ resolutions.
    /// * Priority is not used in resolution, so it is ignored.
    pub(super) fn invalidates_existing_resolution(&self, other: &Self) -> bool {
        // unpack to avoid forgetting to update this method when new fields are added
        let ManifestPackageDescriptorCatalog {
            pkg_path,
            pkg_group,
            version,
            systems: _,
            priority: _,
        } = self;

        pkg_path != &other.pkg_path || pkg_group != &other.pkg_group || version != &other.version
    }
}

#[skip_serializing_none]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[cfg_attr(test, derive(proptest_derive::Arbitrary))]
#[serde(rename_all = "kebab-case")]
#[serde(deny_unknown_fields)]
pub struct ManifestPackageDescriptorFlake {
    pub(crate) flake: String,
}

#[skip_serializing_none]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[cfg_attr(test, derive(proptest_derive::Arbitrary))]
#[serde(rename_all = "kebab-case")]
#[serde(deny_unknown_fields)]
pub struct ManifestPackageDescriptorStorePath {
    store_path: String,
}

/// A map of service names to service definitions
#[derive(
    Debug,
    Clone,
    Serialize,
    Deserialize,
    Default,
    PartialEq,
    derive_more::Deref,
    derive_more::DerefMut,
)]
#[cfg_attr(test, derive(proptest_derive::Arbitrary))]
pub struct ManifestServices(
    #[cfg_attr(
        test,
        proptest(
            strategy = "proptest_btree_map_alphanum_keys::<ManifestServiceDescriptor>(10, 3)"
        )
    )]
    pub(crate) BTreeMap<String, ManifestServiceDescriptor>,
);

/// The definition of a service in a manifest
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[cfg_attr(test, derive(proptest_derive::Arbitrary))]
#[serde(rename_all = "kebab-case")]
#[serde(deny_unknown_fields)]
pub struct ManifestServiceDescriptor {
    /// The command to run to start the service
    pub command: String,
    /// Service-specific environment variables
    pub vars: Option<ManifestVariables>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default, PartialEq, Eq, Hash)]
#[cfg_attr(test, derive(proptest_derive::Arbitrary))]
pub struct ManifestVariables(
    #[cfg_attr(
        test,
        proptest(strategy = "proptest_btree_map_alphanum_keys::<String>(10, 3)")
    )]
    pub(crate) BTreeMap<String, String>,
);

#[skip_serializing_none]
#[derive(Debug, Clone, Serialize, Deserialize, Default, PartialEq, Eq, Hash)]
#[cfg_attr(test, derive(proptest_derive::Arbitrary))]
#[serde(rename_all = "kebab-case")]
#[serde(deny_unknown_fields)]
pub struct ManifestHook {
    /// A script that is run at activation time,
    /// in a flox provided bash shell
    on_activate: Option<String>,
}

#[skip_serializing_none]
#[derive(Debug, Clone, Serialize, Deserialize, Default, PartialEq, Eq, Hash)]
#[cfg_attr(test, derive(proptest_derive::Arbitrary))]
#[serde(deny_unknown_fields)]
pub struct ManifestProfile {
    /// When defined, this hook is run by _all_ shells upon activation
    common: Option<String>,
    /// When defined, this hook is run upon activation in a bash shell
    bash: Option<String>,
    /// When defined, this hook is run upon activation in a zsh shell
    zsh: Option<String>,
    /// When defined, this hook is run upon activation in a fish shell
    fish: Option<String>,
    /// When defined, this hook is run upon activation in a tcsh shell
    tcsh: Option<String>,
}

#[skip_serializing_none]
#[derive(Debug, Clone, Serialize, Deserialize, Default, PartialEq, Eq, Hash)]
#[cfg_attr(test, derive(proptest_derive::Arbitrary))]
#[serde(rename_all = "kebab-case")]
#[serde(deny_unknown_fields)]
pub struct ManifestOptions {
    /// A list of systems that each package is resolved for.
    #[cfg_attr(
        test,
        proptest(
            strategy = "proptest::option::of(proptest::collection::vec(any::<System>(), 1..4))"
        )
    )]
    pub systems: Option<Vec<System>>,
    /// Options that control what types of packages are allowed.
    #[serde(default)]
    pub allow: Allows,
    /// Options that control how semver versions are resolved.
    #[serde(default)]
    pub semver: SemverOptions,
    pub cuda_detection: Option<bool>,
}

#[skip_serializing_none]
#[derive(Debug, Clone, Serialize, Deserialize, Default, PartialEq, Eq, Hash)]
#[cfg_attr(test, derive(proptest_derive::Arbitrary))]
#[serde(deny_unknown_fields)]
pub struct Allows {
    /// Whether to allow packages that are marked as `unfree`
    pub unfree: Option<bool>,
    /// Whether to allow packages that are marked as `broken`
    pub broken: Option<bool>,
    /// A list of license descriptors that are allowed
    #[serde(default)]
    #[cfg_attr(
        test,
        proptest(strategy = "proptest::collection::vec(any::<String>(), 0..3)")
    )]
    pub licenses: Vec<String>,
}

#[skip_serializing_none]
#[derive(Debug, Clone, Serialize, Deserialize, Default, PartialEq, Eq, Hash)]
#[cfg_attr(test, derive(proptest_derive::Arbitrary))]
#[serde(rename_all = "kebab-case")]
#[serde(deny_unknown_fields)]
pub struct SemverOptions {
    /// Whether to allow pre-release versions when resolving
    #[serde(default)]
    pub allow_pre_releases: Option<bool>,
}

/// Deserialize the manifest as a [serde_json::Value],
/// then convert it to a [RawManifest] that can then be converted to a [TypedManifest].
/// This provides more precise errors based on the version of the manifest.
///
/// See the comment on [`RawManifest::to_typed`] for more information.
impl<'de> Deserialize<'de> for TypedManifest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        let document = toml_edit::ser::to_document(&value)
            .map_err(|err| serde::de::Error::custom(err.to_string()))?;
        RawManifest(document)
            .to_typed()
            .map_err(serde::de::Error::custom)
    }
}

#[derive(Debug, thiserror::Error)]
pub enum ManifestError {
    #[error("couldn't parse descriptor '{}': {}", desc, msg)]
    MalformedStringDescriptor { msg: String, desc: String },
    /// FIXME: This is a temporary error variant until `flox` parses descriptors on its own
    #[error("failed while calling pkgdb")]
    PkgDbCall(#[source] std::io::Error),
    #[error("no package or group named '{0}' in the manifest")]
    PkgOrGroupNotFound(String),
    #[error("invalid flake ref: {0}")]
    InvalidFlakeRef(String),
    #[error("only remote flake refs are supported: {0}")]
    LocalFlakeRef(String),
}

/// A subset of the manifest used to check what type of edits users make. We
/// don't use this struct for making our own edits.
///
/// The authoritative form of the manifest is in
/// https://github.com/flox/pkgdb/blob/main/include/flox/resolver/manifest-raw.hh#L263
#[derive(Debug, Clone, Deserialize, Serialize, PartialEq)]
pub struct TypedManifestPkgdb {
    pub vars: Option<toml::Table>,
    pub hook: Option<toml::Table>,
    pub profile: Option<toml::Table>,
    #[serde(flatten)]
    _toml: toml::Table,
}

/// An error encountered while manipulating a manifest using toml_edit.
#[derive(Debug, thiserror::Error, PartialEq)]
pub enum TomlEditError {
    /// The provided string couldn't be parsed into a valid TOML document
    #[error("couldn't parse manifest contents: {0}")]
    ParseManifest(toml_edit::de::Error),
    /// The provided string was a valid TOML file, but it didn't have
    /// the format that we anticipated.
    #[error("'install' must be a table, but found {0} instead")]
    MalformedInstallTable(String),
    /// The `[install]` table was missing entirely
    #[error("'install' table not found")]
    MissingInstallTable,
    /// Tried to uninstall a package that wasn't installed
    #[error("couldn't uninstall '{0}', wasn't previously installed")]
    PackageNotFound(String),
    #[error("'options' must be a table, but found {0} instead")]
    MalformedOptionsTable(String),
    #[error("'options' must be an array, but found {0} instead")]
    MalformedOptionsSystemsArray(String),

    #[error("'{0}' is not a supported attribute in manifest version 1")]
    UnsupportedAttributeV1(String),
}

/// Records the result of trying to install a collection of packages to the
#[derive(Debug)]
pub struct PackageInsertion {
    pub new_toml: Option<DocumentMut>,
    pub already_installed: HashMap<String, bool>,
}

/// Any kind of package that can be installed via `flox install`.
#[derive(Debug, Clone, PartialEq)]
pub enum PackageToInstall {
    Catalog(CatalogPackage),
    Flake(FlakePackage),
}

impl PackageToInstall {
    pub fn id(&self) -> &str {
        match self {
            PackageToInstall::Catalog(pkg) => &pkg.id,
            PackageToInstall::Flake(pkg) => &pkg.id,
        }
    }

    pub fn set_id(&mut self, id: impl AsRef<str>) {
        let id = String::from(id.as_ref());
        match self {
            PackageToInstall::Catalog(pkg) => pkg.id = id,
            PackageToInstall::Flake(pkg) => pkg.id = id,
        }
    }
}

impl FromStr for PackageToInstall {
    type Err = ManifestError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match Url::parse(s) {
            Ok(url) => {
                let id = infer_flake_install_id(&url)?;
                Ok(PackageToInstall::Flake(FlakePackage { id, url }))
            },
            _ => Ok(PackageToInstall::Catalog(s.parse()?)),
        }
    }
}

/// Tries to infer an install id from the flake ref URL, or falls back to "flake".
fn infer_flake_install_id(url: &Url) -> Result<String, ManifestError> {
    if let Some(fragment) = url.fragment() {
        let fragment = url_escape::decode(fragment).to_string();
        let attr_path = fragment
            // split off extended output spec
            .rsplit_once('^')
            .map(|(attr_path, _)| attr_path.to_string())
            .unwrap_or(fragment);
        if !attr_path.is_empty() {
            let install_id = install_id_from_attr_path(&attr_path, url.as_ref())?;
            return Ok(install_id);
        }
    }

    // Use `.path()`` because `github:` and co. are `cannot-be-a-base` urls
    // for which "path-segments" are undefined.
    // `Url::path_segments` will return `None` for such urls.
    if url.scheme() == "github" {
        // Using `.last()` isn't reliable for `github:` refs because you can have a `/<rev>`
        // after the repository name.
        url.path()
            .split('/')
            .nth(1)
            .map(|s| url_escape::decode(s).to_string())
            .ok_or(ManifestError::InvalidFlakeRef(url.to_string()))
    } else {
        url.path()
            .split('/')
            .last()
            .map(|s| url_escape::decode(s).to_string())
            .ok_or(ManifestError::InvalidFlakeRef(url.to_string()))
    }
}

/// Extracts only the catalog packages from a list of packages to install.
pub fn catalog_packages_to_install(packages: &[PackageToInstall]) -> Vec<CatalogPackage> {
    packages
        .iter()
        .filter_map(|pkg| match pkg {
            PackageToInstall::Catalog(pkg) => Some((*pkg).clone()),
            _ => None,
        })
        .collect()
}

/// A package to install from the catalog.
///
/// Users may specify a different install ID than the package name,
/// especially when the package is nested. This struct is the common
/// denominator for packages with specified IDs and packages with
/// default IDs.
#[derive(Debug, Clone, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CatalogPackage {
    pub id: String,
    pub pkg_path: String,
    pub version: Option<String>,
}

#[derive(Debug, Clone, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FlakePackage {
    pub id: String,
    pub url: Url,
}

impl FromStr for CatalogPackage {
    type Err = ManifestError;

    /// Parse a shorthand descriptor into `install_id`, `attribute_path` and `version`.
    ///
    /// A shorthand descriptor consists of a package name and an optional version.
    /// The attribute path is a dot-separated path to a package in the catalog.
    /// The last component of the attribute path is the `install_id`.
    ///
    /// The descriptor is parsed as follows:
    /// ```text
    ///     descriptor ::= <attribute_path>[@<version>]
    ///
    ///     attribute_path ::= <install_id> | <attribute_path_rest>.<install_id>
    ///     attribute_path_rest ::= <identifier> | <attribute_path_rest>.<identifier>
    ///     install_id ::= <identifier>
    ///
    ///     version ::= <string> # interpreted as semver or plain version by the resolver
    /// ```
    /// Todo: this does currently _not_ handle any more pathological cases like
    ///  - `@` in the version string (the last `@` is the delimiter)
    fn from_str(descriptor: &str) -> Result<Self, ManifestError> {
        let (attr_path, version) = match descriptor.split_once('@') {
            Some((attr_path, version)) if !version.is_empty() => {
                (attr_path.to_string(), Some(version.to_string()))
            },
            Some(_) => {
                return Err(ManifestError::MalformedStringDescriptor {
                    msg: indoc! {"
                        Expected version requrement after '@'.
                        Try adding quotes around the argument."}
                    .to_string(),
                    desc: descriptor.to_string(),
                })
            },
            None => (descriptor.to_string(), None),
        };

        let install_id = install_id_from_attr_path(&attr_path, descriptor)?;

        Ok(Self {
            id: install_id,
            pkg_path: attr_path,
            version,
        })
    }
}

/// Extracts an install ID from a dot-separated attribute path that potentially contains quotes.
fn install_id_from_attr_path(attr_path: &str, descriptor: &str) -> Result<String, ManifestError> {
    let mut install_id = None;
    let mut cur = String::new();

    let mut start_quote = None;

    for (n, c) in attr_path.chars().enumerate() {
        match c {
            '.' if start_quote.is_none() => {
                let _ = install_id.insert(std::mem::take(&mut cur));
            },
            // '"' if start_quote.is_some() => start_quote = None,
            '"' if start_quote.is_some() => {
                start_quote = None;
                cur.push('"');
            },
            // '"' if start_quote.is_none() => start_quote = Some(n),
            '"' if start_quote.is_none() => {
                start_quote = Some(n);
                cur.push('"');
            },
            other => cur.push(other),
        }
    }

    if start_quote.is_some() {
        return Err(ManifestError::MalformedStringDescriptor {
            msg: "unclosed quote".to_string(),
            desc: descriptor.to_string(),
        });
    }

    if !cur.is_empty() {
        let _ = install_id.insert(cur);
    }

    install_id.ok_or(ManifestError::MalformedStringDescriptor {
        msg: "attribute path is empty".to_string(),
        desc: descriptor.to_string(),
    })
}

impl From<&CatalogPackage> for Vec<(&'static str, String)> {
    fn from(val: &CatalogPackage) -> Self {
        let mut vec = vec![("pkg-path", val.pkg_path.clone())];
        if let Some(version) = &val.version {
            vec.push(("version", version.clone()));
        }
        vec
    }
}

impl From<&CatalogPackage> for InlineTable {
    fn from(val: &CatalogPackage) -> Self {
        InlineTable::from_iter(Vec::from(val))
    }
}

/// Insert package names into the `[install]` table of a manifest.
///
/// Note that the packages may be provided as dot-separated attribute paths
/// that should be interpreted as relative paths under whatever input they're
/// coming from. For this reason we put them under the `<descriptor>.path` key
/// rather than `<descriptor>.name`.
pub fn insert_packages(
    manifest_contents: &str,
    pkgs: &[PackageToInstall],
) -> Result<PackageInsertion, TomlEditError> {
    debug!("attempting to insert packages into manifest");
    let mut already_installed: HashMap<String, bool> = HashMap::new();
    let manifest = manifest_contents
        .parse::<RawManifest>()
        .map_err(TomlEditError::ParseManifest)?;

    let mut toml = manifest.0;

    let install_table = {
        let install_field = toml
            .entry("install")
            .or_insert_with(|| Item::Table(Table::new()));
        let install_field_type = install_field.type_name().into();
        install_field.as_table_mut().ok_or_else(|| {
            debug!("creating new [install] table");
            TomlEditError::MalformedInstallTable(install_field_type)
        })?
    };

    for pkg in pkgs {
        if !install_table.contains_key(pkg.id()) {
            let mut descriptor_table = InlineTable::new();
            match pkg {
                PackageToInstall::Catalog(pkg) => {
                    descriptor_table.insert(
                        "pkg-path",
                        Value::String(Formatted::new(pkg.pkg_path.clone())),
                    );
                    if let Some(ref version) = pkg.version {
                        descriptor_table
                            .insert("version", Value::String(Formatted::new(version.clone())));
                    }
                    debug!(
                        "package newly installed: id={}, pkg-path={}",
                        pkg.id, pkg.pkg_path
                    );
                },
                PackageToInstall::Flake(pkg) => {
                    descriptor_table
                        .insert("flake", Value::String(Formatted::new(pkg.url.to_string())));
                    debug!(
                        "package newly installed: id={}, flakeref={}",
                        pkg.id,
                        pkg.url.to_string()
                    );
                },
            }

            descriptor_table.set_dotted(true);
            install_table.insert(pkg.id(), Item::Value(Value::InlineTable(descriptor_table)));
            already_installed.insert(pkg.id().to_string(), false);
        } else {
            already_installed.insert(pkg.id().to_string(), true);
            debug!("package already installed: id={}", pkg.id());
        }
    }

    Ok(PackageInsertion {
        new_toml: if !already_installed.values().all(|p| *p) {
            Some(toml)
        } else {
            None
        },
        already_installed,
    })
}

/// Remove package names from the `[install]` table of a manifest
pub fn remove_packages(
    manifest_contents: &str,
    pkgs: &[String],
) -> Result<DocumentMut, TomlEditError> {
    debug!("attempting to remove packages from the manifest");
    let mut toml = manifest_contents
        .parse::<RawManifest>()
        .map_err(TomlEditError::ParseManifest)?
        .0;

    let installs_table = {
        let installs_field = toml
            .get_mut("install")
            .ok_or(TomlEditError::PackageNotFound(pkgs[0].clone()))?;

        let type_name = installs_field.type_name().into();

        installs_field
            .as_table_mut()
            .ok_or(TomlEditError::MalformedInstallTable(type_name))?
    };

    for pkg in pkgs {
        debug!("checking for presence of package '{pkg}'");
        if !installs_table.contains_key(pkg) {
            debug!("package '{pkg}' wasn't found");
            return Err(TomlEditError::PackageNotFound(pkg.clone()));
        } else {
            installs_table.remove(pkg);
            debug!("package '{pkg}' was removed");
        }
    }

    Ok(toml)
}

/// Check whether a TOML document contains a line declaring that the provided package
/// should be installed.
pub fn contains_package(toml: &DocumentMut, pkg_name: &str) -> Result<bool, TomlEditError> {
    if let Some(installs) = toml.get("install") {
        if let Item::Table(installs_table) = installs {
            Ok(installs_table.contains_key(pkg_name))
        } else {
            Err(TomlEditError::MalformedInstallTable(
                installs.type_name().into(),
            ))
        }
    } else {
        Ok(false)
    }
}

/// Add a `system` to the `[options.systems]` array of a manifest
pub fn add_system(toml: &str, system: &str) -> Result<DocumentMut, TomlEditError> {
    let mut doc = toml
        .parse::<RawManifest>()
        .map_err(TomlEditError::ParseManifest)?
        .0;

    // extract the `[options]` table
    let options_table = doc
        .entry("options")
        .or_insert(toml_edit::Item::Table(toml_edit::Table::default()));
    let options_table_type = options_table.type_name().into();
    let options_table = options_table
        .as_table_like_mut()
        .ok_or(TomlEditError::MalformedOptionsTable(options_table_type))?;

    // extract the `options.systems` array
    let systems_list = options_table
        .entry("systems")
        .or_insert(toml_edit::Item::Value(toml_edit::Value::Array(
            toml_edit::Array::default(),
        )));
    let systems_list_type = systems_list.type_name().into();
    let systems_list =
        systems_list
            .as_array_mut()
            .ok_or(TomlEditError::MalformedOptionsSystemsArray(
                systems_list_type,
            ))?;

    // sanity check that the current system is not already in the list
    if systems_list
        .iter()
        .any(|s| s.as_str().map(|s| s == system).unwrap_or_default())
    {
        debug!("system '{system}' already in 'options.systems'");
        return Ok(doc);
    }

    systems_list.push(system.to_string());

    Ok(doc)
}

#[cfg(test)]
pub(super) mod test {
    use pretty_assertions::assert_eq;
    use proptest::prelude::*;
    use proptest_derive::Arbitrary;

    use super::*;

    const DUMMY_MANIFEST: &str = indoc! {r#"
        [install]
        hello = {}

        [install.ripgrep]
        [install.bat]
    "#};

    // This is an array of tables called `install` rather than a table called `install`.
    const BAD_MANIFEST: &str = indoc! {r#"
        [[install]]
        python = {}

        [[install]]
        ripgrep = {}
    "#};

    const CATALOG_MANIFEST: &str = indoc! {r#"
        version = 1
    "#};

    pub fn empty_catalog_manifest() -> TypedManifestCatalog {
        TypedManifestCatalog {
            version: Version,
            install: ManifestInstall::default(),
            vars: ManifestVariables::default(),
            hook: ManifestHook::default(),
            profile: ManifestProfile::default(),
            options: ManifestOptions::default(),
            services: ManifestServices::default(),
        }
    }

    #[test]
    fn catalog_manifest_rejects_unknown_fields() {
        let manifest = formatdoc! {"
            {CATALOG_MANIFEST}

            unknown = 'field'
        "};

        let err = toml_edit::de::from_str::<TypedManifest>(&manifest)
            .expect_err("manifest.toml should be invalid");

        assert!(
            err.message()
                .starts_with("unknown field `unknown`, expected one of"),
            "unexpected error message: {err}",
        );
    }

    #[test]
    fn catalog_manifest_rejects_unknown_nested_fields() {
        let manifest = formatdoc! {"
            {CATALOG_MANIFEST}

            [options]
            allow.unknown = true
        "};

        let err = toml_edit::de::from_str::<TypedManifest>(&manifest)
            .expect_err("manifest.toml should be invalid");

        assert!(
            err.message()
                .starts_with("unknown field `unknown`, expected one of"),
            "unexpected error message: {err}",
        );
    }

    #[test]
    fn create_documented_manifest_not_customized() {
        let systems = [];
        let customization = InitCustomization {
            hook_on_activate: None,
            profile_common: None,
            profile_bash: None,
            profile_fish: None,
            profile_tcsh: None,
            profile_zsh: None,
            packages: None,
        };

        let expected_string = indoc! {r#"
            #
            # This is a Flox environment manifest.
            # Visit flox.dev/docs/concepts/manifest/
            # or see flox-edit(1), manifest.toml(5) for more information.
            #

            # List packages you wish to install in your environment inside
            # the `[install]` section.
            [install]
            # hello.pkg-path = "hello"
            # nodejs = { version = "^18.4.2", pkg-path = "nodejs_18" }

            # Set environment variables in the `[vars]` section. These variables may not
            # reference one another, and are added to the environment without first
            # expanding them. They are available for use in the `[profile]` and `[hook]`
            # scripts.
            [vars]
            # message = "Howdy"

            # The `hook.on-activate` script is run by the *bash* shell immediately upon
            # activating an environment, and will not be invoked if Flox detects that the
            # environment has previously been activated. Variables set by the script will
            # be inherited by `[profile]` scripts defined below. Note that any stdout
            # generated by the script will be redirected to stderr.
            [hook]
            # on-activate = '''
            #   # Set variables, create files and directories
            #   venv_dir="$(mktemp -d)"
            #   export venv_dir
            #
            #   # Perform initialization steps, e.g. create a python venv
            #   python -m venv "$venv_dir"
            # '''

            # Scripts defined in the `[profile]` section are *sourced* by *your shell* and
            # inherit environment variables set in the `[vars]` section and by `[hook]` scripts.
            # The `profile.common` script is sourced by all shells and special care should be
            # taken to ensure compatibility with all shells, after which exactly one of
            # `profile.{bash,fish,tcsh,zsh}` is sourced by the corresponding shell.
            [profile]
            # common = '''
            #   echo "it's gettin' flox in here"
            # '''

            # Additional options can be set in the `[options]` section. Refer to
            # manifest.toml(5) for a list of available options.
            [options]
            systems = []
            # Uncomment to disable CUDA detection.
            # cuda-detection = false
        "#};

        let manifest = RawManifest::new_documented(systems.as_slice(), &customization, false);
        assert_eq!(manifest.to_string(), expected_string.to_string());
    }

    #[test]
    fn create_documented_manifest_catalog_enabled() {
        let systems = [];
        let customization = InitCustomization {
            hook_on_activate: None,
            profile_common: None,
            profile_bash: None,
            profile_fish: None,
            profile_tcsh: None,
            profile_zsh: None,
            packages: Some(vec![]),
        };

        let expected_string = indoc! {r#"
            #
            # This is a Flox environment manifest.
            # Visit flox.dev/docs/concepts/manifest/
            # or see flox-edit(1), manifest.toml(5) for more information.
            #
            version = 1

            # List packages you wish to install in your environment inside
            # the `[install]` section.
            [install]
            # hello.pkg-path = "hello"
            # nodejs = { version = "^18.4.2", pkg-path = "nodejs_18" }

            # Set environment variables in the `[vars]` section. These variables may not
            # reference one another, and are added to the environment without first
            # expanding them. They are available for use in the `[profile]` and `[hook]`
            # scripts.
            [vars]
            # message = "Howdy"

            # The `hook.on-activate` script is run by the *bash* shell immediately upon
            # activating an environment, and will not be invoked if Flox detects that the
            # environment has previously been activated. Variables set by the script will
            # be inherited by `[profile]` scripts defined below. Note that any stdout
            # generated by the script will be redirected to stderr.
            [hook]
            # on-activate = '''
            #   # Set variables, create files and directories
            #   venv_dir="$(mktemp -d)"
            #   export venv_dir
            #
            #   # Perform initialization steps, e.g. create a python venv
            #   python -m venv "$venv_dir"
            # '''

            # Scripts defined in the `[profile]` section are *sourced* by *your shell* and
            # inherit environment variables set in the `[vars]` section and by `[hook]` scripts.
            # The `profile.common` script is sourced by all shells and special care should be
            # taken to ensure compatibility with all shells, after which exactly one of
            # `profile.{bash,fish,tcsh,zsh}` is sourced by the corresponding shell.
            [profile]
            # common = '''
            #   echo "it's gettin' flox in here"
            # '''

            # Additional options can be set in the `[options]` section. Refer to
            # manifest.toml(5) for a list of available options.
            [options]
            systems = []
            # Uncomment to disable CUDA detection.
            # cuda-detection = false
        "#};

        let manifest = RawManifest::new_documented(systems.as_slice(), &customization, true);
        assert_eq!(manifest.to_string(), expected_string.to_string());
    }

    #[test]
    fn create_documented_manifest_with_packages() {
        let systems = [];
        let customization = InitCustomization {
            hook_on_activate: None,
            profile_common: None,
            profile_bash: None,
            profile_fish: None,
            profile_tcsh: None,
            profile_zsh: None,
            packages: Some(vec![CatalogPackage {
                id: "python3".to_string(),
                pkg_path: "python3".to_string(),
                version: Some("3.11.6".to_string()),
            }]),
        };

        let expected_string = indoc! {r#"
            #
            # This is a Flox environment manifest.
            # Visit flox.dev/docs/concepts/manifest/
            # or see flox-edit(1), manifest.toml(5) for more information.
            #

            # List packages you wish to install in your environment inside
            # the `[install]` section.
            [install]
            python3 = { pkg-path = "python3", version = "3.11.6" }

            # Set environment variables in the `[vars]` section. These variables may not
            # reference one another, and are added to the environment without first
            # expanding them. They are available for use in the `[profile]` and `[hook]`
            # scripts.
            [vars]
            # message = "Howdy"

            # The `hook.on-activate` script is run by the *bash* shell immediately upon
            # activating an environment, and will not be invoked if Flox detects that the
            # environment has previously been activated. Variables set by the script will
            # be inherited by `[profile]` scripts defined below. Note that any stdout
            # generated by the script will be redirected to stderr.
            [hook]
            # on-activate = '''
            #   # Set variables, create files and directories
            #   venv_dir="$(mktemp -d)"
            #   export venv_dir
            #
            #   # Perform initialization steps, e.g. create a python venv
            #   python -m venv "$venv_dir"
            # '''

            # Scripts defined in the `[profile]` section are *sourced* by *your shell* and
            # inherit environment variables set in the `[vars]` section and by `[hook]` scripts.
            # The `profile.common` script is sourced by all shells and special care should be
            # taken to ensure compatibility with all shells, after which exactly one of
            # `profile.{bash,fish,tcsh,zsh}` is sourced by the corresponding shell.
            [profile]
            # common = '''
            #   echo "it's gettin' flox in here"
            # '''

            # Additional options can be set in the `[options]` section. Refer to
            # manifest.toml(5) for a list of available options.
            [options]
            systems = []
            # Uncomment to disable CUDA detection.
            # cuda-detection = false
        "#};

        let manifest = RawManifest::new_documented(systems.as_slice(), &customization, false);
        assert_eq!(manifest.to_string(), expected_string.to_string());
    }

    #[test]
    fn create_documented_manifest_hook() {
        let systems = [&"x86_64-linux".to_string()];
        let customization = InitCustomization {
            hook_on_activate: Some(
                indoc! {r#"
                    # Print something
                    echo "hello world"

                    # Set a environment variable
                    $FOO="bar"
                "#}
                .to_string(),
            ),
            profile_common: None,
            profile_bash: None,
            profile_fish: None,
            profile_tcsh: None,
            profile_zsh: None,
            packages: None,
        };

        let expected_string = indoc! {r#"
            #
            # This is a Flox environment manifest.
            # Visit flox.dev/docs/concepts/manifest/
            # or see flox-edit(1), manifest.toml(5) for more information.
            #

            # List packages you wish to install in your environment inside
            # the `[install]` section.
            [install]
            # hello.pkg-path = "hello"
            # nodejs = { version = "^18.4.2", pkg-path = "nodejs_18" }

            # Set environment variables in the `[vars]` section. These variables may not
            # reference one another, and are added to the environment without first
            # expanding them. They are available for use in the `[profile]` and `[hook]`
            # scripts.
            [vars]
            # message = "Howdy"

            # The `hook.on-activate` script is run by the *bash* shell immediately upon
            # activating an environment, and will not be invoked if Flox detects that the
            # environment has previously been activated. Variables set by the script will
            # be inherited by `[profile]` scripts defined below. Note that any stdout
            # generated by the script will be redirected to stderr.
            [hook]
            on-activate = '''
              # Print something
              echo "hello world"

              # Set a environment variable
              $FOO="bar"
            '''

            # Scripts defined in the `[profile]` section are *sourced* by *your shell* and
            # inherit environment variables set in the `[vars]` section and by `[hook]` scripts.
            # The `profile.common` script is sourced by all shells and special care should be
            # taken to ensure compatibility with all shells, after which exactly one of
            # `profile.{bash,fish,tcsh,zsh}` is sourced by the corresponding shell.
            [profile]
            # common = '''
            #   echo "it's gettin' flox in here"
            # '''

            # Additional options can be set in the `[options]` section. Refer to
            # manifest.toml(5) for a list of available options.
            [options]
            systems = ["x86_64-linux"]
            # Uncomment to disable CUDA detection.
            # cuda-detection = false
        "#};

        let manifest = RawManifest::new_documented(systems.as_slice(), &customization, false);
        assert_eq!(manifest.to_string(), expected_string.to_string());
    }

    #[test]
    fn create_documented_profile_script() {
        let systems = [&"x86_64-linux".to_string()];
        let customization = InitCustomization {
            hook_on_activate: None,
            profile_common: Some(
                indoc! { r#"
                    echo "Hello from Flox"
                "#}
                .to_string(),
            ),
            profile_bash: None,
            profile_fish: None,
            profile_tcsh: None,
            profile_zsh: None,
            packages: None,
        };

        let expected_string = indoc! {r#"
            #
            # This is a Flox environment manifest.
            # Visit flox.dev/docs/concepts/manifest/
            # or see flox-edit(1), manifest.toml(5) for more information.
            #

            # List packages you wish to install in your environment inside
            # the `[install]` section.
            [install]
            # hello.pkg-path = "hello"
            # nodejs = { version = "^18.4.2", pkg-path = "nodejs_18" }

            # Set environment variables in the `[vars]` section. These variables may not
            # reference one another, and are added to the environment without first
            # expanding them. They are available for use in the `[profile]` and `[hook]`
            # scripts.
            [vars]
            # message = "Howdy"

            # The `hook.on-activate` script is run by the *bash* shell immediately upon
            # activating an environment, and will not be invoked if Flox detects that the
            # environment has previously been activated. Variables set by the script will
            # be inherited by `[profile]` scripts defined below. Note that any stdout
            # generated by the script will be redirected to stderr.
            [hook]
            # on-activate = '''
            #   # Set variables, create files and directories
            #   venv_dir="$(mktemp -d)"
            #   export venv_dir
            #
            #   # Perform initialization steps, e.g. create a python venv
            #   python -m venv "$venv_dir"
            # '''

            # Scripts defined in the `[profile]` section are *sourced* by *your shell* and
            # inherit environment variables set in the `[vars]` section and by `[hook]` scripts.
            # The `profile.common` script is sourced by all shells and special care should be
            # taken to ensure compatibility with all shells, after which exactly one of
            # `profile.{bash,fish,tcsh,zsh}` is sourced by the corresponding shell.
            [profile]
            common = '''
              echo "Hello from Flox"
            '''

            # Additional options can be set in the `[options]` section. Refer to
            # manifest.toml(5) for a list of available options.
            [options]
            systems = ["x86_64-linux"]
            # Uncomment to disable CUDA detection.
            # cuda-detection = false
        "#};

        let manifest = RawManifest::new_documented(systems.as_slice(), &customization, false);
        assert_eq!(manifest.to_string(), expected_string.to_string());
    }

    #[test]
    fn detect_pkgdb_manifest() {
        const PKGDB_MANIFEST: &str = indoc! {r#"
            # No version field, so it's a pkgdb manifest
        "#};

        assert!(matches!(
            toml_edit::de::from_str(PKGDB_MANIFEST),
            Ok(TypedManifest::Pkgdb(_))
        ))
    }

    #[test]
    fn detect_catalog_manifest() {
        assert!(matches!(
            toml_edit::de::from_str(CATALOG_MANIFEST),
            Ok(TypedManifest::Catalog(_))
        ))
    }

    #[test]
    fn insert_adds_new_package() {
        let test_packages = vec![PackageToInstall::Catalog(
            CatalogPackage::from_str("python").unwrap(),
        )];
        let pre_addition_toml = DUMMY_MANIFEST.parse::<DocumentMut>().unwrap();
        assert!(!contains_package(&pre_addition_toml, test_packages[0].id()).unwrap());
        let insertion =
            insert_packages(DUMMY_MANIFEST, &test_packages).expect("couldn't add package");
        assert!(
            insertion.new_toml.is_some(),
            "manifest was changed by install"
        );
        assert!(contains_package(&insertion.new_toml.unwrap(), test_packages[0].id()).unwrap());
    }

    #[test]
    fn no_change_adding_existing_package() {
        let test_packages = vec![PackageToInstall::Catalog(
            CatalogPackage::from_str("hello").unwrap(),
        )];
        let pre_addition_toml = DUMMY_MANIFEST.parse::<DocumentMut>().unwrap();
        assert!(contains_package(&pre_addition_toml, test_packages[0].id()).unwrap());
        let insertion = insert_packages(DUMMY_MANIFEST, &test_packages).unwrap();
        assert!(
            insertion.new_toml.is_none(),
            "manifest shouldn't be changed installing existing package"
        );
        assert!(
            insertion.already_installed.values().all(|p| *p),
            "all of the packages should be listed as already installed"
        );
    }

    #[test]
    fn insert_adds_install_table_when_missing() {
        let test_packages = vec![PackageToInstall::Catalog(
            CatalogPackage::from_str("foo").unwrap(),
        )];
        let insertion = insert_packages("", &test_packages).unwrap();
        assert!(
            contains_package(&insertion.new_toml.clone().unwrap(), test_packages[0].id()).unwrap()
        );
        assert!(
            insertion.new_toml.is_some(),
            "manifest was changed by install"
        );
        assert!(
            !insertion.already_installed.values().all(|p| *p),
            "none of the packages should be listed as already installed"
        );
    }

    #[test]
    fn insert_error_when_manifest_malformed() {
        let test_packages = vec![PackageToInstall::Catalog(
            CatalogPackage::from_str("foo").unwrap(),
        )];
        let attempted_insertion = insert_packages(BAD_MANIFEST, &test_packages);
        assert!(matches!(
            attempted_insertion,
            Err(TomlEditError::MalformedInstallTable(_))
        ))
    }

    #[test]
    fn remove_error_when_manifest_malformed() {
        let test_packages = vec!["hello".to_owned()];
        let attempted_removal = remove_packages(BAD_MANIFEST, &test_packages);
        assert!(matches!(
            attempted_removal,
            Err(TomlEditError::MalformedInstallTable(_))
        ))
    }

    #[test]
    fn error_when_install_table_missing() {
        let test_packages = vec!["hello".to_owned()];
        let removal = remove_packages("", &test_packages);
        assert!(matches!(removal, Err(TomlEditError::PackageNotFound(_))));
    }

    #[test]
    fn removes_all_requested_packages() {
        let test_packages = vec!["hello".to_owned(), "ripgrep".to_owned()];
        let toml = remove_packages(DUMMY_MANIFEST, &test_packages).unwrap();
        assert!(!contains_package(&toml, "hello").unwrap());
        assert!(!contains_package(&toml, "ripgrep").unwrap());
    }

    #[test]
    fn error_when_removing_nonexistent_package() {
        let test_packages = vec!["hello".to_owned(), "DOES_NOT_EXIST".to_owned()];
        let removal = remove_packages(DUMMY_MANIFEST, &test_packages);
        assert!(matches!(removal, Err(TomlEditError::PackageNotFound(_))));
    }

    #[test]
    fn inserts_package_needing_quotes() {
        let attrs = r#"foo."bar.baz".qux"#;
        let test_packages = vec![PackageToInstall::Catalog(
            CatalogPackage::from_str(attrs).unwrap(),
        )];
        let pre_addition_toml = DUMMY_MANIFEST.parse::<DocumentMut>().unwrap();
        assert!(!contains_package(&pre_addition_toml, test_packages[0].id()).unwrap());
        let insertion =
            insert_packages(DUMMY_MANIFEST, &test_packages).expect("couldn't add package");
        assert!(
            insertion.new_toml.is_some(),
            "manifest was changed by install"
        );
        let new_toml = insertion.new_toml.unwrap();
        assert!(contains_package(&new_toml, test_packages[0].id()).unwrap());
        let inserted_path = new_toml
            .get("install")
            .and_then(|t| t.get("qux"))
            .and_then(|d| d.get("pkg-path"))
            .and_then(|p| p.as_str())
            .unwrap();
        assert_eq!(inserted_path, r#"foo."bar.baz".qux"#);
    }

    #[test]
    fn parses_string_descriptor() {
        let parsed: CatalogPackage = "hello".parse().unwrap();
        assert_eq!(parsed, CatalogPackage {
            id: "hello".to_string(),
            pkg_path: "hello".to_string(),
            version: None,
        });
        let parsed: CatalogPackage = "foo.bar@=1.2.3".parse().unwrap();
        assert_eq!(parsed, CatalogPackage {
            id: "bar".to_string(),
            pkg_path: "foo.bar".to_string(),
            version: Some("=1.2.3".to_string()),
        });
        let parsed: CatalogPackage = "foo.bar@23.11".parse().unwrap();
        assert_eq!(parsed, CatalogPackage {
            id: "bar".to_string(),
            pkg_path: "foo.bar".to_string(),
            version: Some("23.11".to_string()),
        });
        let parsed: CatalogPackage = "rubyPackages.\"http_parser.rb\"".parse().unwrap();
        assert_eq!(parsed, CatalogPackage {
            id: "\"http_parser.rb\"".to_string(),
            pkg_path: "rubyPackages.\"http_parser.rb\"".to_string(),
            version: None,
        });

        CatalogPackage::from_str("foo.\"bar.baz.qux@1.2.3")
            .expect_err("missing closing quote should cause failure");
        CatalogPackage::from_str("@1.2.3").expect_err("missing attrpath should cause failure");
        CatalogPackage::from_str("foo@").expect_err("missing version should cause failure");
    }

    proptest! {
        #[test]
        fn manifest_round_trip(manifest in any::<TypedManifestCatalog>()) {
            let toml = toml_edit::ser::to_string(&manifest).unwrap();
            let parsed = toml_edit::de::from_str::<TypedManifestCatalog>(&toml).unwrap();
            prop_assert_eq!(manifest, parsed);
        }
    }

    /// Determines whether to have a branch and/or revision in the URL
    #[derive(Debug, Arbitrary, PartialEq)]
    enum FlakeRefPathAttrs {
        None,
        RevPath,
        RevParam,
        RefParam,
        RefAndRevParams,
    }

    /// The components of an attrpath after `packages.<system>.`
    #[derive(Debug, Arbitrary, PartialEq)]
    enum AttrPathComponent {
        Bare,
        Quoted,
        QuotedWithDots,
    }

    /// The type of URL in the flake reference
    #[derive(Debug, Arbitrary, PartialEq)]
    enum FlakeRefURLType {
        GitHub,
        Https,
        GitHttps,
    }

    /// Flake ref outputs
    #[derive(Debug, Arbitrary, PartialEq)]
    enum FlakeRefOutputs {
        None,
        All,
        Out,
        OutAndMan,
    }

    #[derive(Debug, Arbitrary, PartialEq)]
    enum PkgFragment {
        None,
        Name(AttrPathComponent),
        #[proptest(
            strategy = "proptest::collection::vec(any::<AttrPathComponent>(), 1..=2).prop_map(PkgFragment::AttrPath)"
        )]
        AttrPath(Vec<AttrPathComponent>),
    }

    #[derive(Debug, Arbitrary)]
    struct ArbitraryFlakeRefURL {
        url_type: FlakeRefURLType,
        path_attrs: FlakeRefPathAttrs,
        pkg_fragment: PkgFragment,
        outputs: FlakeRefOutputs,
    }

    fn arbitrary_flake_ref_url() -> impl Strategy<Value = (String, String)> {
        any::<ArbitraryFlakeRefURL>()
            .prop_filter("don't add rev as path segment on arbitrary URLs", |seed| {
                (seed.url_type == FlakeRefURLType::Https)
                    && (seed.path_attrs != FlakeRefPathAttrs::RevPath)
            })
            .prop_map(|url_seed| {
                let stem = match url_seed.url_type {
                    FlakeRefURLType::GitHub => "github:foo/bar",
                    FlakeRefURLType::Https => "https://example.com/foo/bar",
                    FlakeRefURLType::GitHttps => "git+https://example.com/foo/bar",
                };
                let path_attrs = match url_seed.path_attrs {
                    FlakeRefPathAttrs::None => "",
                    FlakeRefPathAttrs::RevPath => "/abc123",
                    FlakeRefPathAttrs::RefParam => "?ref=master",
                    FlakeRefPathAttrs::RevParam => "?rev=abc123",
                    FlakeRefPathAttrs::RefAndRevParams => "?ref=master&rev=abc123",
                };
                let (fragment, expected_install_id) = match url_seed.pkg_fragment {
                    PkgFragment::None => {
                        if url_seed.outputs != FlakeRefOutputs::None {
                            ("#".to_string(), "bar")
                        } else {
                            (String::new(), "bar")
                        }
                    },
                    PkgFragment::Name(attr) => {
                        let id = match attr {
                            AttrPathComponent::Bare => "floxtastic",
                            AttrPathComponent::Quoted => "\"floxtastic\"",
                            AttrPathComponent::QuotedWithDots => "\"flox.tastic\"",
                        };
                        (format!("#{}", id), id)
                    },
                    PkgFragment::AttrPath(attr_path_seeds) => match attr_path_seeds.len() {
                        1 => {
                            let id = match attr_path_seeds[0] {
                                AttrPathComponent::Bare => "floxtastic",
                                AttrPathComponent::Quoted => "\"floxtastic\"",
                                AttrPathComponent::QuotedWithDots => "\"flox.tastic\"",
                            };
                            (format!("#legacyPackges.aarch64-darwin.{}", id), id)
                        },
                        2 => {
                            let namespace = match attr_path_seeds[0] {
                                AttrPathComponent::Bare => "nested",
                                AttrPathComponent::Quoted => "\"nested\"",
                                AttrPathComponent::QuotedWithDots => "\"nest.ed\"",
                            };
                            let id = match attr_path_seeds[1] {
                                AttrPathComponent::Bare => "floxtastic",
                                AttrPathComponent::Quoted => "\"floxtastic\"",
                                AttrPathComponent::QuotedWithDots => "\"flox.tastic\"",
                            };
                            (
                                format!("#legacyPackages.aarch64-darwin.{}.{}", namespace, id),
                                id,
                            )
                        },
                        _ => unreachable!(),
                    },
                };
                let outputs = match url_seed.outputs {
                    FlakeRefOutputs::None => "".to_string(),
                    FlakeRefOutputs::All => "^*".to_string(),
                    FlakeRefOutputs::Out => "^out".to_string(),
                    FlakeRefOutputs::OutAndMan => "^out,man".to_string(),
                };
                let url = format!("{}{}{}{}", stem, path_attrs, fragment, outputs);
                (url, expected_install_id.to_string())
            })
    }

    proptest! {
        #[test]
        fn infers_install_id_from_arbitrary_flake_ref_url((url, expected_id) in arbitrary_flake_ref_url()) {
            let url = Url::parse(&url).unwrap();
            let inferred = infer_flake_install_id(&url).unwrap();
            prop_assert_eq!(inferred, expected_id);
        }
    }

    #[test]
    fn infers_id_from_tarball_flake_ref() {
        // This is one case not covered by the proptest above
        let url = Url::parse("https://github.com/foo/bar/archive/main.tar.gz").unwrap();
        let inferred = infer_flake_install_id(&url).unwrap();
        assert_eq!(inferred.as_str(), "main.tar.gz");
    }
}
