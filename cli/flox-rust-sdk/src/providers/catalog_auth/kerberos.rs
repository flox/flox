//! Kerberos authentication strategy

use base64::Engine as _;
use libgssapi::context::{ClientCtx, CtxFlags};
use libgssapi::credential::{Cred, CredUsage};
use libgssapi::name::Name;
use libgssapi::oid::{GSS_MECH_KRB5, GSS_NT_HOSTBASED_SERVICE, OidSet};
use reqwest::header::{self, HeaderMap, HeaderValue};
use tracing::debug;
use url::Url;

use super::AuthStrategy;

/// Kerberos authentication strategy
///
/// Uses Kerberos tickets via GSSAPI to generate SPNEGO tokens for HTTP Negotiate authentication.
pub struct KerberosAuthStrategy {
    catalog_url: String,
}

impl KerberosAuthStrategy {
    pub fn new(catalog_url: String) -> Self {
        Self { catalog_url }
    }
}

impl AuthStrategy for KerberosAuthStrategy {
    fn add_auth_headers(&self, header_map: &mut HeaderMap) {
        match Self::generate_kerberos_token(&self.catalog_url) {
            Ok(token) => {
                let auth_value = format!("Negotiate {}", token);
                if let Ok(value) = HeaderValue::from_str(&auth_value) {
                    header_map.insert(header::AUTHORIZATION, value);
                    debug!("Added Kerberos Negotiate authorization header");
                } else {
                    tracing::warn!("Failed to create header value from Kerberos token");
                }
            },
            Err(e) => {
                tracing::warn!("Failed to generate Kerberos token: {}", e);
            },
        }
    }
}

impl KerberosAuthStrategy {
    /// Generate a Kerberos token for the given catalog URL
    ///
    /// This uses Kerberos authentication via GSSAPI to generate a SPNEGO token
    /// for HTTP Negotiate authentication.
    fn generate_kerberos_token(catalog_url: &str) -> Result<String, String> {
        // Parse the URL to extract the hostname
        let url = Url::parse(catalog_url).map_err(|e| format!("Invalid URL: {}", e))?;
        let hostname = url
            .host_str()
            .ok_or_else(|| "No hostname in catalog URL".to_string())?;

        // Create the service principal name (SPN) for HTTP service
        // Format: HTTP@hostname
        let service_name = format!("HTTP@{}", hostname);
        debug!("Using Kerberos service principal: {}", service_name);

        // Import the service name as a GSSAPI name
        let target_name = Name::new(service_name.as_bytes(), Some(&GSS_NT_HOSTBASED_SERVICE))
            .map_err(|e| format!("Failed to create GSSAPI name: {:?}", e))?;

        // Acquire default credentials (from Kerberos ticket cache)
        let cred = Cred::acquire(None, None, CredUsage::Initiate, None)
            .map_err(|e| format!("Failed to acquire GSSAPI credentials: {:?}", e))?;

        // Create GSSAPI context flags
        let mut ctx_flags = CtxFlags::empty();
        ctx_flags.insert(CtxFlags::GSS_C_MUTUAL_FLAG);
        ctx_flags.insert(CtxFlags::GSS_C_REPLAY_FLAG);

        // Create a Kerberos-only OID set
        let mut desired_mechs =
            OidSet::new().map_err(|e| format!("Failed to create OID set: {:?}", e))?;
        desired_mechs
            .add(&GSS_MECH_KRB5)
            .map_err(|e| format!("Failed to add Kerberos OID: {:?}", e))?;

        // Initialize the client context
        let mut client_ctx =
            ClientCtx::new(Some(cred), target_name, ctx_flags, Some(&GSS_MECH_KRB5));

        // Perform the initial GSSAPI handshake step
        // First parameter: input token (None for initial step)
        // Second parameter: channel bindings (None for no channel bindings)
        let token = client_ctx
            .step(None, None)
            .map_err(|e| format!("Kerberos context initialization failed: {:?}", e))?;

        // Check if token was generated
        let token_bytes = token.ok_or_else(|| "No token generated by Kerberos".to_string())?;

        // Encode the token as base64 (convert Buf to byte slice)
        let encoded_token = base64::engine::general_purpose::STANDARD.encode(&token_bytes[..]);
        debug!("Generated Kerberos token ({} bytes)", token_bytes.len());

        Ok(encoded_token)
    }
}
