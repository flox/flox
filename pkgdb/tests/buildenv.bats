#! /usr/bin/env bats
# --------------------------------------------------------------------------- #
#
# @file tests/buildenv.bats
#
# @brief Test building environments from lockfiles.
#
# Relies on lockfiles generated by `pkgdb` from flox manifests.
#
# These tests only check the build segment,
# they do not check the resolution of manifests,
# nor the activation of the resulting environments.
# Such tests are found in `pkgdb` and `flox` respectively.
#
#
# --------------------------------------------------------------------------- #
#
# TODO: Allow a path to a file to be passed.
#
#
# --------------------------------------------------------------------------- #

# bats file_tags=build-env

load setup_suite.bash

# --------------------------------------------------------------------------- #

setup_file() {
  : "${CAT:=cat}"
  : "${TEST:=test}"
  : "${MKDIR:=mkdir}"
  export CAT TEST MKDIR
  export LOCKFILES="$BATS_TEST_DIRNAME/data/buildenv/lockfiles"

  # Always use a consistent `nixpkgs' input.
  export _PKGDB_GA_REGISTRY_REF_OR_REV="${NIXPKGS_REV?}"
}

# ---------------------------------------------------------------------------- #

# bats test_tags=single,smoke
@test "Simple environment builds successfully" {
  run "$PKGDB_BIN" buildenv "$LOCKFILES/single-package/manifest.lock"
  assert_success
}

# bats test_tags=single,smoke
@test "Inline JSON builds successfully" {
  run "$PKGDB_BIN" buildenv "$(< "$LOCKFILES/single-package/manifest.lock")"
  assert_success
}

# ---------------------------------------------------------------------------- #


# ---------------------------------------------------------------------------- #

# bats test_tags=single,binaries
@test "Built environment contains binaries for v0 lock" {
  run "$PKGDB_BIN" buildenv \
    "$LOCKFILES/single-package/manifest.lock"
  assert_success
  store_path=$(echo "$output" | jq -er '.store_path')
  assert "$TEST" -x "${store_path}/bin/vim"
}


# ---------------------------------------------------------------------------- #

# bats test_tags=single,binaries
@test "Built environment contains binaries for v1 catalog package" {
  run --separate-stderr "$PKGDB_BIN" buildenv \
    "$GENERATED_DATA/envs/hello/manifest.lock"
  assert_success
  store_path=$(echo "$output" | jq -er '.store_path')
  assert "$TEST" -x "${store_path}/bin/hello"
}


# ---------------------------------------------------------------------------- #

# bats test_tags=single,binaries
@test "Built environment contains binaries for v1 flake package" {
  run --separate-stderr "$PKGDB_BIN" buildenv \
    "${TESTS_DIR?}"/data/buildenv/manual-lockfiles/flake/manifest.lock
  assert_success
  store_path=$(echo "$output" | jq -er '.store_path')
  assert "$TEST" -x "${store_path}/bin/hello"
}


# ---------------------------------------------------------------------------- #

# bats test_tags=single,activate-files
@test "Built environment contains activate files" {
  run "$PKGDB_BIN" buildenv \
    "$LOCKFILES/single-package/manifest.lock"
  assert_success
  store_path=$(echo "$output" | jq -er '.store_path')
  assert "$TEST" -f "${store_path}/activate.d/start.bash"
  assert "$TEST" -f "${store_path}/activate.d/zsh"
  assert "$TEST" -d "${store_path}/etc/profile.d"
}

# --------------------------------------------------------------------------- #

# bats test_tags=hook,script
@test "Built environment includes hook script" {
  run "$PKGDB_BIN" buildenv "$LOCKFILES/hook-script/manifest.lock"
  assert_success
  store_path=$(echo "$output" | jq -er '.store_path')
  assert "$TEST" -f "${store_path}/activate.d/hook-script"
  run "$CAT" "${store_path}/activate.d/hook-script"
  assert_output "script"
}

# ---------------------------------------------------------------------------- #

@test "Built environment includes 'on-activate' script" {
  run "$PKGDB_BIN" buildenv "$LOCKFILES/on-activate/manifest.lock"
  assert_success
  store_path=$(echo "$output" | jq -er '.store_path')
  assert "$TEST" -f "${store_path}/activate.d/hook-on-activate"
}

# --------------------------------------------------------------------------- #

# bats test_tags=conflict,detect
@test "Detects conflicting packages" {
  run "$PKGDB_BIN" buildenv "$LOCKFILES/conflict/manifest.lock"
  assert_failure
  assert_output --regexp "'vim.*' conflicts with 'vim.*'"
}

# bats test_tags=conflict,resolve
@test "Allows to resolve conflicting with priority" {
  run "$PKGDB_BIN" buildenv \
    "$LOCKFILES/conflict-resolved/manifest.lock"
  assert_success
}

# ---------------------------------------------------------------------------- #

# Single quotes in variables should be escaped.
# Similarly accidentally escaped single quotes like
#
# [vars]
# singlequoteescaped = "\\'baz"
#
# should be escaped and printed as  \'baz  (literally)
# bats test_tags=buildenv:vars
@test "Environment escapes variables" {
  run "$PKGDB_BIN" buildenv "$LOCKFILES/vars_escape/manifest.lock"
  assert_success
  store_path=$(echo "$output" | jq -er '.store_path')

  assert "$TEST" -f "${store_path}/activate.d/envrc"
  run "$CAT" "${store_path}/activate.d/envrc"
  assert_line "export singlequotes=''\''bar'\'''"
  assert_line "export singlequoteescaped='\'\''baz'"
}

# bats test_tags=buildenv:build-commands
@test "Built environment contains build scripts" {
  run "$PKGDB_BIN" buildenv "$GENERATED_DATA/envs/build-noop/manifest.lock"
  assert_success
  store_path=$(echo "$output" | jq -er '.store_path')
  assert "$TEST" -f "${store_path}/package-builds.d/hello"
}

# bats test_tags=buildenv:include-lockfile
@test "Built environment contains lockfile" {

  orginalLockfile="$GENERATED_DATA/envs/hello/manifest.lock"
  run "$PKGDB_BIN" buildenv "${orginalLockfile}"
  assert_success
  store_path=$(echo "$output" | jq -er '.store_path')
  assert "$TEST" -f "${store_path}/manifest.lock"

  assert diff \
    <(jq --sort-keys . "${store_path}/manifest.lock" ) \
    <(jq --sort-keys . "${orginalLockfile}")
}


# ---------------------------------------------------------------------------- #

# With '--container' produces a script that can be used to build a container.
# bats test_tags=buildenv:container
@test "Environment builds container" {
  # 2024-10-22: fakeroot used in the creation of layers aborts ion macos with:
  #
  # dyld[25304]: symbol not found in flat namespace '_fstat$INODE64'
  # /nix/store/52g78wj19d5bxal1znqgrgnrifhz6z15-fakeroot-1.32.2/bin/fakeroot: line 178: 25304 Abort trap: 6           FAKEROOTKEY=$FAKEROOTKEY DYLD_INSERT_LIBRARIES="$FAKEROOT_LIB" ${SHELL:-/bin/sh}
  [ "${NIX_SYSTEM#*-}" = "darwin" ] && skip "Container builds are only supported on '*-linux'"

  run --separate-stderr \
    "$PKGDB_BIN" buildenv "$LOCKFILES/single-package/manifest.lock" \
    --container flox-env-container
  assert_success
  store_path=$(echo "$output" | jq -er '.store_path')

  # Run the container builder script.
  export store_path
  run bash -c '"$store_path" > "$BATS_TEST_TMPDIR/container"'
  assert_success

  # Check that the container is a tar archive.
  run tar -tf "$BATS_TEST_TMPDIR/container"
  # Check that the container contains layer(s)
  assert_output --regexp '([a-z0-9]{64}/layer.tar)+'
  # Check that the container contains a config file.
  assert_output --regexp '([a-z0-9]{64}\.json)'
  # Check that the container contains a manifest file.
  assert_line 'manifest.json'
}

# ---------------------------------------------------------------------------- #

# With '--container-tag' produces a script that can be used to build a container
# with a specific tag.
# bats test_tags=buildenv:container-tag
@test "Environment builds container with tag" {
  # 2024-10-22: fakeroot used in the creation of layers aborts ion macos with:
  #
  # dyld[25304]: symbol not found in flat namespace '_fstat$INODE64'
  # /nix/store/52g78wj19d5bxal1znqgrgnrifhz6z15-fakeroot-1.32.2/bin/fakeroot: line 178: 25304 Abort trap: 6           FAKEROOTKEY=$FAKEROOTKEY DYLD_INSERT_LIBRARIES="$FAKEROOT_LIB" ${SHELL:-/bin/sh}
  [ "${NIX_SYSTEM#*-}" = "darwin" ] && skip "Container builds are only supported on '*-linux'"

  container_name='flox-env-container-tag-test'
  container_tag='somereallyhardtoguesstag'

  run --separate-stderr \
    "$PKGDB_BIN" buildenv "$LOCKFILES/single-package/manifest.lock" \
    --container "$container_name" \
    --container-tag "$container_tag"
  assert_success
  store_path=$(echo "$output" | jq -er '.store_path')

  # Run the container builder script.
  export store_path
  run bash -c '"$store_path" > "$BATS_TEST_TMPDIR/container.tar"'
  assert_success

  # Fetch the manifest.json from the tarball.
  tar xf "$BATS_TEST_TMPDIR/container.tar" --wildcards 'manifest.json'
  assert_success

  # Check that the tag is present in the manifest.
  want="$container_name:$container_tag"
  got="$(cat manifest.json | jq -r '.[].RepoTags[0]')"
  assert [ "$want" == "$got" ]
}

# --------------------------------------------------------------------------- #

# bats test_tags=requisites
@test "Verify contents of requisites.txt" {
  run "$PKGDB_BIN" buildenv "$LOCKFILES/single-package/manifest.lock"
  assert_success
  store_path=$(echo "$output" | jq -er '.store_path')
  assert "$TEST" -f "${store_path}/requisites.txt"
  nix-store -qR "${store_path}" | grep -v "${store_path}" | sort > "$BATS_TEST_TMPDIR/verify-requisites"
  run diff "$BATS_TEST_TMPDIR/verify-requisites" "${store_path}/requisites.txt"
  assert_success
}

# ---------------------------------------------------------------------------- #
#
#
#
# ============================================================================ #
