#!/usr/bin/env bash
# shellcheck shell=bash

# Trace levels supported by activation scripts:
#   1. (-v) top-level activate script
#   2. (-vv) language-specific profile scripts
#   3. (-vvv) zsh `autoload -U compinit` (very verbose)
export _flox_activate_tracelevel="${_FLOX_SUBSYSTEM_VERBOSITY:-0}"
[ "$_flox_activate_tracelevel" -eq 0 ] || set -x

# Ensure that $_flox_activate_tracer is defined as an executable.
if [ -z "${FLOX_ACTIVATE_TRACE-}" ]; then
  # If FLOX_ACTIVATE_TRACE is empty or not set, set _flox_activate_tracer to
  # `true` which can always be invoked with any arguments without error.
  export _flox_activate_tracer=true
else
  # If FLOX_ACTIVATE_TRACE is set but does not refer to an executable, then
  # set _flox_activate_tracer to the default trace script.
  if [ -x "${FLOX_ACTIVATE_TRACE:-}" ]; then
    export _flox_activate_tracer="$FLOX_ACTIVATE_TRACE"
  else
    export _flox_activate_tracer="__OUT__/activate.d/trace"
  fi
fi
"$_flox_activate_tracer" "${BASH_SOURCE[0]}" "$@" START

_dirname="@coreutils@/bin/dirname"
_getopt="@getopt@/bin/getopt"
_jq="@jq@/bin/jq"
_flox_activations="@flox_activations@"

set -euo pipefail

# These all derive from the `flox-interpreter` package.
# FIXME This is wrong; the profile.d scripts in particular should be
#       sourced from the environment itself so that users can add pkgs
#       which add additional scripts to the etc/profile.d directory.
export _activate_d="__OUT__/activate.d"
_profile_d="__OUT__/etc/profile.d"

# shellcheck source-path=SCRIPTDIR/activate.d
source "${_activate_d}/helpers.bash"

# Top-level Flox environment activation script.

# Parse command-line arguments.
OPTIONS="e:c:m:"
LONGOPTS="command:,\
env:,\
env-cache:,\
env-project:,\
env-description:,\
mode:,\
start-state-dir:,\
skip-hook-on-activate"
USAGE="Usage: $0 [-c \"<cmd> <args>\"] \
[(-e|--env) <env>] \
[--env-cache <path>] \
[--env-project <path>] \
[--env-description <name>] \
[(-m|--mode) (dev|run|build)] \
[--start-state-dir <path>] \
[--skip-hook-on-activate]"

if ! PARSED=$("$_getopt" --options="$OPTIONS" --longoptions="$LONGOPTS" --name "$0" -- "$@"); then
  echo "Failed to parse options." >&2
  echo "$USAGE" >&2
  exit 1
fi

# Use eval to remove quotes and replace them with spaces.
eval set -- "$PARSED"

# Set default values for options.
FLOX_CMD=""
_FLOX_ENV="$($_dirname -- "${BASH_SOURCE[0]}")"
_FLOX_ENV_ACTIVATION_MODE="dev"
_skip_hook_on_activate="false"
while true; do
  case "$1" in
    -c | --command)
      shift
      if [ -z "${1:-}" ]; then
        echo "Option -c requires an argument." >&2
        echo "$USAGE" >&2
        exit 1
      fi
      FLOX_CMD="$1"
      shift
      ;;
    -e | --env)
      shift
      if [ -z "${1:-}" ] || [ ! -d "$1" ]; then
        echo "Option --env requires a valid environment path as an argument." >&2
        echo "$USAGE" >&2
        exit 1
      fi
      _FLOX_ENV="$1"
      shift
      ;;
    --env-cache)
      shift
      if [ -z "${1:-}" ] || [ ! -d "$1" ]; then
        echo "Option --env-cache requires a valid path as an argument." >&2
        echo "$USAGE" >&2
        exit 1
      fi
      _FLOX_ENV_CACHE="$1"
      shift
      ;;
    --env-project)
      shift
      if [ -z "${1:-}" ] || [ ! -d "$1" ]; then
        echo "Option --env-project requires a valid path as an argument." >&2
        echo "$USAGE" >&2
        exit 1
      fi
      _FLOX_ENV_PROJECT="$1"
      shift
      ;;
    --env-description)
      shift
      if [ -z "${1:-}" ]; then
        echo "Option --env-description requires a name as an argument." >&2
        echo "$USAGE" >&2
        exit 1
      fi
      _FLOX_ENV_DESCRIPTION="$1"
      shift
      ;;
    -m | --mode)
      shift
      if [ -z "${1:-}" ] || ! { [ "$1" == "run" ] || [ "$1" == "dev" ] || [ "$1" == "build" ]; }; then
        echo "Option --mode requires 'dev', 'run', or 'build' as an argument." >&2
        echo "$USAGE" >&2
        exit 1
      fi
      _FLOX_ENV_ACTIVATION_MODE="$1"
      shift
      ;;
    --start-state-dir)
      shift
      if [ -z "${1:-}" ]; then
        echo "Option --start-state-dir requires a path as an argument." >&2
        echo "$USAGE" >&2
        exit 1
      fi
      _start_state_dir="$1"
      shift
      ;;
    --skip-hook-on-activate)
      _skip_hook_on_activate="true"
      shift
      ;;
    --)
      shift
      break
      ;;
    -*)
      echo "Invalid option: $1" >&2
      echo "$USAGE" >&2
      exit 1
      ;;
  esac
done

# Convert the provided command string into an array of arguments in "$@".
# Henceforth in the script it is assumed that these are the arguments to be
# invoked either by this shell (when in build mode) or with the chosen userShell.
if [ -n "$FLOX_CMD" ]; then
  # Throw an error if passed additional arguments along with the -c arg.
  if [ $# -gt 0 ]; then
    echo "Unexpected arguments provided with -c argument: $*" >&2
    echo "$USAGE" >&2
    exit 1
  fi

  # Set $@ to reflect the command to be invoked.
  set -- "$FLOX_CMD"
fi

if [ $# -gt 0 ]; then
  _command_mode="true"
else
  _command_mode="false"
fi

if [ "$_command_mode" = "true" ]; then
  # Propagate required variables that are documented as exposed.
  export FLOX_ENV="${_FLOX_ENV}"

  # Propagate optional variables that are documented as exposed.
  # NB: `generate_*_start_commands()` performs the same logic except for zsh.
  for var_key in FLOX_ENV_CACHE FLOX_ENV_PROJECT FLOX_ENV_DESCRIPTION; do
    eval "var_val=\${_$var_key-}"
    if [ -n "$var_val" ]; then
      export $var_key="${var_val}"
    else
      unset $var_key
    fi
  done

  # shellcheck disable=SC1090
  source <("$_flox_activations" set-env-dirs --shell bash --flox-env "$FLOX_ENV" --env-dirs "${FLOX_ENV_DIRS:-}")
  # shellcheck disable=SC1090
  source <("$_flox_activations" fix-paths --shell bash --env-dirs "$FLOX_ENV_DIRS" --path "$PATH" --manpath "${MANPATH:-}")
fi

if [ "$_command_mode" = "false" ]; then
  # Set umask to ensure files are created with 0600 (may contain secrets)
  umask 077
  # First activation of this environment. Snapshot environment to start.
  _start_env_json="$_start_state_dir/start.env.json"
  $_jq -nS env > "$_start_env_json"
fi

case "$_FLOX_ENV_ACTIVATION_MODE" in
  dev)
    # shellcheck disable=SC1090 # from rendered environment
    source_profile_d "$_profile_d" "prepend" "$FLOX_ENV_DIRS"
    ;;
  run)
    # shellcheck disable=SC1091 # from rendered environment
    source "$_profile_d/0100_common-run-mode-paths.sh"
    ;;
  build)
    # shellcheck disable=SC1090 # from rendered environment
    source_profile_d "$_profile_d" "set" "$FLOX_ENV_DIRS"
    ;;
  *)
    echo "Invalid activation mode: $_FLOX_ENV_ACTIVATION_MODE" >&2
    exit 1
    ;;
esac

# Set static environment variables from the manifest.
set_manifest_vars "$FLOX_ENV"

if [ "$_skip_hook_on_activate" = "false" ]; then
  # Source the hook-on-activate script if it exists.
  if [ -e "$FLOX_ENV/activate.d/hook-on-activate" ]; then
    # Nothing good can come from output printed to stdout in the
    # user-provided hook scripts because these can get interpreted
    # as configuration statements by the "in-place" activation
    # mode. So, we'll redirect stdout to stderr.
    set +euo pipefail
    "$_flox_activate_tracer" "$FLOX_ENV/activate.d/hook-on-activate" START
    # shellcheck disable=SC1091 # from rendered environment
    source "$FLOX_ENV/activate.d/hook-on-activate" 1>&2
    "$_flox_activate_tracer" "$FLOX_ENV/activate.d/hook-on-activate" END
    set -euo pipefail
  else
    "$_flox_activate_tracer" "$FLOX_ENV/activate.d/hook-on-activate" NOT FOUND
  fi
fi

if [ "$_command_mode" = "true" ]; then
  if [ -n "$FLOX_CMD" ]; then
    exec bash -c "$FLOX_CMD"
  else
    exec "$@"
  fi
fi

if [ "$_command_mode" = "false" ]; then
  # Capture ending environment.
  _end_env_json="$_start_state_dir/end.env.json"
  $_jq -nS env > "$_end_env_json"
fi

"$_flox_activate_tracer" "${BASH_SOURCE[0]}" "$@" END
