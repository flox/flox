#!/usr/bin/env bash
# shellcheck shell=bash

# Trace levels supported by activation scripts:
#   1. (-v) top-level activate script
#   2. (-vv) language-specific profile scripts
#   3. (-vvv) zsh `autoload -U compinit` (very verbose)
export _flox_activate_tracelevel="${_FLOX_PKGDB_VERBOSITY:-0}"
[ "$_flox_activate_tracelevel" -eq 0 ] || set -x

# Ensure that $_flox_activate_tracer is defined as an executable.
if [ -z "${FLOX_ACTIVATE_TRACE-}" ]; then
  # If FLOX_ACTIVATE_TRACE is empty or not set, set _flox_activate_tracer to
  # `true` which can always be invoked with any arguments without error.
  export _flox_activate_tracer=true
else
  # If FLOX_ACTIVATE_TRACE is set but does not refer to an executable, then
  # set _flox_activate_tracer to the default trace script.
  if [ -x "${FLOX_ACTIVATE_TRACE:-}" ]; then
    export _flox_activate_tracer="$FLOX_ACTIVATE_TRACE"
  else
    export _flox_activate_tracer="__OUT__/activate.d/trace"
  fi
fi
"$_flox_activate_tracer" "${BASH_SOURCE[0]}" "$@" START

_bash="@bash@/bin/bash"
_dirname="@coreutils@/bin/dirname"
_getopt="@getopt@/bin/getopt"
_jq="@jq@/bin/jq"
_readlink="@coreutils@/bin/readlink"
_flox_activations="@flox_activations@"

set -euo pipefail

# These all derive from the `flox-interpreter` package.
# FIXME This is wrong; the profile.d scripts in particular should be
#       sourced from the environment itself so that users can add pkgs
#       which add additional scripts to the etc/profile.d directory.
export _activate_d="__OUT__/activate.d"
export _profile_d="__OUT__/etc/profile.d"
export _tcsh_home="__OUT__/activate.d/tcsh_home"
export _zdotdir="__OUT__/activate.d/zdotdir"

# shellcheck source-path=SCRIPTDIR/activate.d
source "${_activate_d}/helpers.bash"

# Top-level Flox environment activation script.
#
# The activate script is called in one of two "modes":
# - dev: (default) sources the entire set of etc/profile.d scripts,
#   setting "dangerous" environment variables such as PYTHONPATH as
#   a result, then sources hook.on-activate script
# - run: sources "$_profile_d/0100_common-run-mode-paths.sh" only;
#   does NOT source hook.on-activate script
#
# Thereafter, it behaves differently in two distinct ways:
# - if passed a command in the form of "-c 'command string'" or by
#   way of args to be directly invoked with "-- command args", then
#   will exec() into that command by way of "bash -c"
# - else it will record environment snapshots in the path denoted by
#   the --activation-state-dir arg, both before and after sourcing
#   activation scripts

# Parse command-line arguments.
OPTIONS="c:e:m:s:"
LONGOPTS="activation-state-dir:,\
command-string:,\
env:,\
mode:,\
shell:"
USAGE="Usage: $0 [(-c|--command-string) \"<cmd> <args>\"] \
[(-s|--shell) <shell>] \
[(-e|--env) <env>] \
[(-m|--mode) (dev|run)]"

if ! PARSED=$("$_getopt" --options="$OPTIONS" --longoptions="$LONGOPTS" --name "$0" -- "$@"); then
  echo "Failed to parse options." >&2
  echo "$USAGE" >&2
  exit 1
fi

# Use eval to remove quotes and replace them with spaces.
eval set -- "$PARSED"

# Set default values for options.
FLOX_CMD=""
# The rust CLI contains sophisticated logic to detect the shell based on
# $FLOX_SHELL or the process listening on STDOUT, but that won't happen when
# activating from the top-level activation script, so fall back to $SHELL as a
# default.
_FLOX_SHELL="$SHELL"
_FLOX_ENV="$($_dirname -- "${BASH_SOURCE[0]}")"
_FLOX_ENV_ACTIVATION_MODE="dev"
_flox_activation_state_dir=""
while true; do
  case "$1" in
    --activation-state-dir)
      shift
      if [ -z "${1:-}" ]; then
        echo "Option --activation-state-dir requires a path as an argument." >&2
        echo "$USAGE" >&2
        exit 1
      fi
      _flox_activation_state_dir="$1"
      shift
      ;;
    -c | --command-string)
      shift
      if [ -z "${1:-}" ]; then
        echo "Option -c requires an argument." >&2
        echo "$USAGE" >&2
        exit 1
      fi
      FLOX_CMD="$1"
      shift
      ;;
    -e | --env)
      shift
      if [ -z "${1:-}" ] || [ ! -d "$1" ]; then
        echo "Option --env requires a valid environment path as an argument." >&2
        echo "$USAGE" >&2
        exit 1
      fi
      _FLOX_ENV="$1"
      shift
      ;;
    -m | --mode)
      shift
      if [ -z "${1:-}" ] || ! { [ "$1" == "run" ] || [ "$1" == "dev" ]; }; then
        echo "Option --mode requires 'dev' or 'run' as an argument." >&2
        echo "$USAGE" >&2
        exit 1
      fi
      _FLOX_ENV_ACTIVATION_MODE="$1"
      shift
      ;;
    -s | --shell)
      shift
      if [ -z "${1:-}" ]; then
        echo "Option --shell requires a command as an argument." >&2
        echo "$USAGE" >&2
        exit 1
      fi
      _FLOX_SHELL="$1"
      shift
      ;;
    --)
      shift
      break
      ;;
    -*)
      echo "Invalid option: $1" >&2
      echo "$USAGE" >&2
      exit 1
      ;;
  esac
done

# Propagate required variables that are documented as exposed.
export FLOX_ENV="${_FLOX_ENV}"

# Propagate optional variables that are documented as exposed.
# NB: `generate_*_start_commands()` performs the same logic except for zsh.
for var_key in FLOX_ENV_CACHE FLOX_ENV_PROJECT FLOX_ENV_DESCRIPTION; do
  eval "var_val=\${_$var_key-}"
  if [ -n "$var_val" ]; then
    export $var_key="${var_val}"
  else
    unset $var_key
  fi
done

# shellcheck disable=SC1090
source <("$_flox_activations" set-env-dirs --shell bash --flox-env "$FLOX_ENV" --env-dirs "${FLOX_ENV_DIRS:-}")
# shellcheck disable=SC1090
source <("$_flox_activations" fix-paths --shell bash --env-dirs "$FLOX_ENV_DIRS" --path "$PATH" --manpath "${MANPATH:-}")

# Set a default for _FLOX_ACTIVATE_STORE_PATH for container and build
# invocations
if [ -z "${_FLOX_ACTIVATE_STORE_PATH:-}" ]; then
  _FLOX_ACTIVATE_STORE_PATH="$("$_readlink" -f "$FLOX_ENV")"
fi

# Respect _FLOX_SHELL_FORCE if set.
declare -r _flox_shell="${_FLOX_SHELL_FORCE:-${_FLOX_SHELL}}"
# Unset FLOX_SHELL to detect the parent shell anew with each flox invocation.
unset FLOX_SHELL

# Bail if the shell is unsupported.
case "$_flox_shell" in
  *bash) ;;
  *fish) ;;
  *tcsh) ;;
  *zsh) ;;
  *)
    echo "Unsupported shell: $_flox_shell" >&2
    exit 1
    ;;
esac

# Identify if exec()ing a command.
if [ -n "$FLOX_CMD" ] || [ $# -gt 0 ]; then
  # Throw an error if passed additional arguments along with the -c arg.
  if [ -n "$FLOX_CMD" ] && [ $# -gt 0 ]; then
    echo "Unexpected arguments provided with -c argument: $*" >&2
    echo "$USAGE" >&2
    exit 1
  fi

  # We don't ever need to attach,
  # and we don't want to run hook.on-activate, (?)
  # so just set the variables we need.
  source_profile_d "$_profile_d" "set" "$FLOX_ENV_DIRS"
  # Set static environment variables from the manifest
  set_manifest_vars "$FLOX_ENV"

  if [ -n "$FLOX_CMD" ]; then
    exec $_bash --noprofile --norc -c "$FLOX_CMD"
  else
    exec "$@"
  fi
fi

# Confirm that $_flox_activation_state_dir is defined.
if [ -z "${_flox_activation_state_dir:-}" ]; then
  echo "--activation-state-dir arg not provided; cannot proceed." >&2
  exit 1
fi

# First activation of this environment. Snapshot environment to start.
# Use jq to capture environment as properly-escaped JSON
_start_env="$_flox_activation_state_dir/start.env.json"
$_jq -nS env > "$_start_env"

# Process the flox environment customizations, which includes (amongst
# other things) prepending this environment's bin directory to the PATH.
# shellcheck disable=SC2154 # set in the main `activate` script
if [ "$_FLOX_ENV_ACTIVATION_MODE" = "dev" ]; then
  # shellcheck disable=SC1090 # from rendered environment
  source_profile_d "$_profile_d" "prepend" "$FLOX_ENV_DIRS"
else
  # shellcheck disable=SC1091 # from rendered environment
  source "$_profile_d/0100_common-run-mode-paths.sh"
fi

# Capture post-etc-profiles.env.
# This is currently unused but could be useful for runtime only environment in
# the future.
$_jq -nS env > "$_flox_activation_state_dir/post-etc-profiles.env.json"

# Set static environment variables from the manifest.
set_manifest_vars "$FLOX_ENV"

# Source the hook-on-activate script if it exists.
if [ -e "$FLOX_ENV/activate.d/hook-on-activate" ]; then
  # Nothing good can come from output printed to stdout in the
  # user-provided hook scripts because these can get interpreted
  # as configuration statements by the "in-place" activation
  # mode. So, we'll redirect stdout to stderr.
  set +euo pipefail
  "$_flox_activate_tracer" "$FLOX_ENV/activate.d/hook-on-activate" START
  # shellcheck disable=SC1091 # from rendered environment
  source "$FLOX_ENV/activate.d/hook-on-activate" 1>&2
  "$_flox_activate_tracer" "$FLOX_ENV/activate.d/hook-on-activate" END
  set -euo pipefail
else
  "$_flox_activate_tracer" "$FLOX_ENV/activate.d/hook-on-activate" NOT FOUND
fi

# Capture _end_env and generate _add_env and _del_env.
# Mark the environment as ready to use for attachments.
# Capture ending environment as JSON.
_end_env="$_flox_activation_state_dir/end.env.json"
$_jq -nS env > "$_end_env"

# XXX everything in the following block is no longer necessary; remove as final step in the refactor
{
  # The userShell initialization scripts that follow have the potential to undo
  # the environment modifications performed above, so we must first calculate
  # all changes made to the environment so far so that we can restore them after
  # the userShell initialization scripts have run. We use jq to diff the two
  # JSON environment snapshots.
  _add_env="$_flox_activation_state_dir/add.env"
  _del_env="$_flox_activation_state_dir/del.env"

  # Capture environment variables to _set_ as "key=value" pairs with proper JSON escaping.
  # This finds keys that are new or changed in $_end_env compared to $_start_env.
  # shellcheck disable=SC2016
  $_jq -rS --slurpfile start "$_start_env" '
    to_entries |
    map(select(
      ($start[0][.key] // null) != .value
    )) |
    map("\(.key)=\(.value | @sh)") |
    .[]
  ' "$_end_env" > "$_add_env"

  # Capture environment variables to _unset_ as a list of keys.
  # This finds keys that exist in $_start_env but not in $_end_env.
  # shellcheck disable=SC2016
  $_jq -rS --slurpfile end "$_end_env" '
    to_entries |
    map(select(
      ($end[0][.key] // null) == null
    )) |
    map(.key) |
    .[]
  ' "$_start_env" > "$_del_env"
}

"$_flox_activate_tracer" "${BASH_SOURCE[0]}" "$@" END
