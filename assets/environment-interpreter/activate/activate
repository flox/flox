#!/usr/bin/env bash
# shellcheck shell=bash

# Trace levels supported by activation scripts:
#   1. (-v) top-level activate script
#   2. (-vv) language-specific profile scripts
#   3. (-vvv) zsh `autoload -U compinit` (very verbose)
export _flox_activate_tracelevel="${_FLOX_PKGDB_VERBOSITY:-0}"
[ "$_flox_activate_tracelevel" -eq 0 ] || set -x

# Ensure that $_flox_activate_tracer is defined as an executable.
if [ -z "${FLOX_ACTIVATE_TRACE-}" ]; then
  # If FLOX_ACTIVATE_TRACE is empty or not set, set _flox_activate_tracer to
  # `true` which can always be invoked with any arguments without error.
  export _flox_activate_tracer=true
else
  # If FLOX_ACTIVATE_TRACE is set but does not refer to an executable, then
  # set _flox_activate_tracer to the default trace script.
  if [ -x "${FLOX_ACTIVATE_TRACE:-}" ]; then
    export _flox_activate_tracer="$FLOX_ACTIVATE_TRACE"
  else
    export _flox_activate_tracer="__OUT__/activate.d/trace"
  fi
fi
"$_flox_activate_tracer" "${BASH_SOURCE[0]}" "$@" START

_bash="@bash@/bin/bash"
_dirname="@coreutils@/bin/dirname"
_getopt="@getopt@/bin/getopt"
_jq="@jq@/bin/jq"
_readlink="@coreutils@/bin/readlink"
_flox_activations="@flox_activations@"

set -euo pipefail

# These all derive from the `flox-interpreter` package.
# FIXME This is wrong; the profile.d scripts in particular should be
#       sourced from the environment itself so that users can add pkgs
#       which add additional scripts to the etc/profile.d directory.
export _activate_d="__OUT__/activate.d"
export _profile_d="__OUT__/etc/profile.d"
export _tcsh_home="__OUT__/activate.d/tcsh_home"
export _zdotdir="__OUT__/activate.d/zdotdir"

# shellcheck source-path=SCRIPTDIR/activate.d
source "${_activate_d}/helpers.bash"

# Top-level Flox environment activation script.
#
# The activate script is called in one of two "modes":
# - dev: (default) sources the entire set of etc/profile.d scripts,
#   setting "dangerous" environment variables such as PYTHONPATH as
#   a result, then sources hook.on-activate script
# - run: sources "$_profile_d/0100_common-run-mode-paths.sh" only;
#   does NOT source hook.on-activate script
#
# Thereafter, it behaves differently in two distinct ways:
# - if passed a command in the form of "-c 'command string'" or by
#   way of args to be directly invoked with "-- command args", then
#   will exec() into that command by way of "bash -c"
# - else it will record environment snapshots in the path denoted by
#   the --activation-state-dir arg, both before and after sourcing
#   activation scripts

# Parse command-line arguments.
OPTIONS="c:e:m:ns:v"
LONGOPTS="activation-state-dir:,\
command-string:,\
env:,\
mode:,\
no-run-hook-on-activate,\
shell:,\
verbose"
USAGE="Usage: $0 [(-c|--command-string) \"<cmd> <args>\"] \
[(-e|--env) <env>] \
[(-m|--mode) (dev|run)] \
[(-n|--no-run-hook-on-activate)] \
[(-s|--shell) <shell>] \
[(-v|--verbose)]"
if ! PARSED=$("$_getopt" --options="$OPTIONS" --longoptions="$LONGOPTS" --name "$0" -- "$@"); then
  echo "Failed to parse options." >&2
  echo "$USAGE" >&2
  exit 1
fi

# Use eval to remove quotes and replace them with spaces.
eval set -- "$PARSED"

# Set default values for options.
FLOX_CMD=""
# The rust CLI contains sophisticated logic to detect the shell based on
# $FLOX_SHELL or the process listening on STDOUT, but that won't happen when
# activating from the top-level activation script, so fall back to $SHELL as a
# default.
_FLOX_SHELL="$SHELL"
_FLOX_ENV="$($_dirname -- "${BASH_SOURCE[0]}")"
_flox_env_activation_mode="dev"
_flox_activation_state_dir=""
_no_run_hook_on_activate=""
while true; do
  case "$1" in
    --activation-state-dir)
      shift
      if [ -z "${1:-}" ]; then
        echo "Option --activation-state-dir requires a path as an argument." >&2
        echo "$USAGE" >&2
        exit 1
      fi
      _flox_activation_state_dir="$1"
      shift
      ;;
    -c | --command-string)
      shift
      if [ -z "${1:-}" ]; then
        echo "Option -c requires an argument." >&2
        echo "$USAGE" >&2
        exit 1
      fi
      FLOX_CMD="$1"
      shift
      ;;
    -e | --env)
      shift
      if [ -z "${1:-}" ] || [ ! -d "$1" ]; then
        echo "Option --env requires a valid environment path as an argument." >&2
        echo "$USAGE" >&2
        exit 1
      fi
      _FLOX_ENV="$1"
      shift
      ;;
    -m | --mode)
      shift
      if [ -z "${1:-}" ] || ! { [ "$1" == "run" ] || [ "$1" == "dev" ]; }; then
        echo "Option --mode requires 'dev' or 'run' as an argument." >&2
        echo "$USAGE" >&2
        exit 1
      fi
      _flox_env_activation_mode="$1"
      shift
      ;;
    -n | --no-run-hook-on-activate)
      shift
      _no_run_hook_on_activate=true
      ;;
    -s | --shell)
      shift
      if [ -z "${1:-}" ]; then
        echo "Option --shell requires a command as an argument." >&2
        echo "$USAGE" >&2
        exit 1
      fi
      _FLOX_SHELL="$1"
      shift
      ;;
    -v | --verbose)
      shift
      set -x
      ;;
    --)
      shift
      break
      ;;
    -*)
      echo "Invalid option: $1" >&2
      echo "$USAGE" >&2
      exit 1
      ;;
  esac
done

# Propagate required variables that are documented as exposed.
export FLOX_ENV="${_FLOX_ENV}"

# Propagate optional variables that are documented as exposed.
# NB: `generate_*_start_commands()` performs the same logic except for zsh.
for var_key in FLOX_ENV_CACHE FLOX_ENV_PROJECT FLOX_ENV_DESCRIPTION; do
  eval "var_val=\${_$var_key-}"
  if [ -n "$var_val" ]; then
    export $var_key="${var_val}"
  else
    unset $var_key
  fi
done

# shellcheck disable=SC1090
source <("$_flox_activations" set-env-dirs --shell bash --flox-env "$FLOX_ENV" --env-dirs "${FLOX_ENV_DIRS:-}")
# shellcheck disable=SC1090
source <("$_flox_activations" fix-paths --shell bash --env-dirs "$FLOX_ENV_DIRS" --path "$PATH" --manpath "${MANPATH:-}")

# Set a default for _FLOX_ACTIVATE_STORE_PATH for container and build
# invocations
if [ -z "${_FLOX_ACTIVATE_STORE_PATH:-}" ]; then
  _FLOX_ACTIVATE_STORE_PATH="$("$_readlink" -f "$FLOX_ENV")"
fi

# Respect _FLOX_SHELL_FORCE if set.
declare -r _flox_shell="${_FLOX_SHELL_FORCE:-${_FLOX_SHELL}}"
# Unset FLOX_SHELL to detect the parent shell anew with each flox invocation.
unset FLOX_SHELL

# Bail if the shell is unsupported.
case "$_flox_shell" in
  *bash) ;;
  *fish) ;;
  *tcsh) ;;
  *zsh) ;;
  *)
    echo "Unsupported shell: $_flox_shell" >&2
    exit 1
    ;;
esac

###
### Main logic
###

if [ -n "$FLOX_CMD" ] || [ $# -gt 0 ]; then
  # Command mode.

  if [ -n "$FLOX_CMD" ]; then
    # "command string" mode: invoke with `bash -c "$FLOX_CMD"`

    # Throw an error if passed additional arguments along with the -c arg.
    if [ $# -gt 0 ]; then
      echo "Unexpected arguments provided with -c argument: $*" >&2
      echo "$USAGE" >&2
      exit 1
    fi

    # We don't ever need to attach,
    # and we don't want to run hook.on-activate, (?)
    # so just set the variables we need.
    source_profile_d "$_profile_d" "set" "$FLOX_ENV_DIRS"
    # Set static environment variables from the manifest
    set_manifest_vars "$FLOX_ENV"

    # Source the hook-on-activate script (if it exists).
    if [ -z "${_no_run_hook_on_activate:-}" ]; then
      set +euo pipefail
      source_script "$FLOX_ENV/activate.d/hook-on-activate" 1>&2
      set -euo pipefail
    fi

    # Exec bash to run the command string. Note that bash will exec()
    # the final command found in the string so there will be just one
    # PID and no issues with signal handling.
    exec $_bash --noprofile --norc -c "$FLOX_CMD"

  else
    # exec() mode: invoke with `exec "$@"`

    # We don't ever need to attach,
    # and we don't want to run hook.on-activate, (?)
    # so just set the variables we need.
    source_profile_d "$_profile_d" "set" "$FLOX_ENV_DIRS"
    # Set static environment variables from the manifest
    set_manifest_vars "$FLOX_ENV"

    # Exec the provided command and args.
    exec "$@"
  fi

else

  # Executive activation mode.

  # First confirm that $_flox_activation_state_dir is defined.
  if [ -z "${_flox_activation_state_dir:-}" ]; then
    echo "--activation-state-dir arg not provided; cannot proceed." >&2
    exit 1
  fi

  # Use jq to capture environment as properly-escaped JSON
  _start_env="$_flox_activation_state_dir/start.env.json"
  $_jq -nS env > "$_start_env"

  # Process etc-profiles scripts differently based on activation mode.
  if [ "$_flox_env_activation_mode" = "dev" ]; then
    # shellcheck disable=SC1090 # from rendered environment
    source_profile_d "$_profile_d" "prepend" "$FLOX_ENV_DIRS"
  else
    # shellcheck disable=SC1091 # from rendered environment
    source "$_profile_d/0100_common-run-mode-paths.sh"
  fi

  # Set static environment variables from the manifest.
  set_manifest_vars "$FLOX_ENV"

  # Source the hook-on-activate script (if it exists).
  if [ -z "${_no_run_hook_on_activate:-}" ]; then
    set +euo pipefail
    source_script "$FLOX_ENV/activate.d/hook-on-activate" 1>&2
    set -euo pipefail
  fi

  # Capture ending environment as JSON.
  _end_env="$_flox_activation_state_dir/end.env.json"
  $_jq -nS env > "$_end_env"

  # XXX everything in the following block is no longer necessary; remove as final step in the refactor
  {
    # Generate _add_env and _del_env.
    # The userShell initialization scripts that follow have the potential to undo
    # the environment modifications performed above, so we must first calculate
    # all changes made to the environment so far so that we can restore them after
    # the userShell initialization scripts have run. We use jq to diff the two
    # JSON environment snapshots.
    _add_env="$_flox_activation_state_dir/add.env"
    _del_env="$_flox_activation_state_dir/del.env"
    # Capture environment variables to _set_ as "key=value" pairs with proper JSON escaping.
    # This finds keys that are new or changed in $_end_env compared to $_start_env.
    # shellcheck disable=SC2016
    $_jq -rS --slurpfile start "$_start_env" '
      to_entries |
      map(select(
        ($start[0][.key] // null) != .value
      )) |
      map("\(.key)=\(.value | @sh)") |
      .[]
    ' "$_end_env" > "$_add_env"
    # Capture environment variables to _unset_ as a list of keys.
    # This finds keys that exist in $_start_env but not in $_end_env.
    # shellcheck disable=SC2016
    $_jq -rS --slurpfile end "$_end_env" '
      to_entries |
      map(select(
        ($end[0][.key] // null) == null
      )) |
      map(.key) |
      .[]
    ' "$_start_env" > "$_del_env"
  }

fi

"$_flox_activate_tracer" "${BASH_SOURCE[0]}" "$@" END
