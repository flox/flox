{ lib, nef }:
{
  /*
    Create an overlay function

         final: prev: { ... }

    for an attrset of extensions as generated by `lib.nef.dirToAttrs <pkgsDir>`

    ```
    {
        type = "directory";
        path = "...";
        entries = {
            baz = { type = "nix"; path = "..." }
            foo = {
                type = "directory";
                path = "...";
                entries = {
                    bar = { type = "nix"; path = "..." };
                };
            }
        }
    }
    ```

    "nix" values become direct attributes in the overlay.
    On "directory" entries extend the respective sub-attrset
    co-recursively via `extendAttrSet`.
    If an attrset does not exist we create a new empty "scope"d attrset
    with `makeScope` which we then override in `extendAttrSet`.

    ### Type

    ```
    mkOverlay :: [String] -> Attrs -> Attrs -> (Attrs -> Attrs -> Attrs)
    ```
  */
  mkOverlay =
    # current attr path for messaging
    attrPath:
    # Current scope, i.e. the union of all parent attr sets
    # Used to create a `callPackage` function when nixpkgs does not
    # via either `makeScope` or a custom `callPackage`.
    currentScope:
    # A set of extensions, typically the result of `lib.nef.dirToAttrs`
    extensions:
    # overlay
    (
      final: prev:
      builtins.mapAttrs (
        name: value:
        let
          attrPath' = attrPath ++ [ name ];
          attrPathStr = lib.showAttrPath attrPath';
        in

        {
          "nix" =
            let
              recursionGuardError = throw ''
                Circular dependency detected.
                The package '${attrPathStr}' defined in ${value.path} directly or transitively imports itself.
                For example by requesting a dependency '${name}'.
                An expression can only access its own attribute path to override its existing value.
              '';

              # Find or build a `callPackage` function that replaces infinite recursion erros with an error
              callPackage =

                # Examples of such sets are:
                # - agdaPackages
                if final ? newScope then
                  final.newScope {
                    ${name} = prev.${name} or recursionGuardError;
                  }
                # probably equivalent to the above but struturally more similar to the `extend` case below
                # else if final ? overrideScope then
                #   (final.overrideScope (
                #     _: _: { ${name} = prev.${name} or recursionGuardError; }
                #   )).callPackage

                # Some package sets are using `makeExtensible` instead of `makeScope`
                # which provides them with an `extend` function to apply an overlay.
                # We still want a `callPackage` function to confidently call the function,
                # with the overlay applied.
                #
                # Examples of such sets are:
                # - beamPackages
                #
                # Todo: If a set can be extended but does not provide a `callPackage`,
                # we should still try to use the `extend` it and build our own `callPackge` as below.
                else if final ? callPackage && final ? extend then
                  (final.extend (_: _: { ${name} = prev.${name} or recursionGuardError; })).callPackage
                else
                  # attrset that is not defined with `makeScope`
                  # and neither with `makeExtensible` and `callPackage`.
                  # In this case we can only build our own `callPackage`
                  # from the current scope hierarchy.
                  #
                  # Examples of such sets are:
                  # - nodePackages (as node packages are individually shrinkwrapped via a node2nix tool)
                  lib.callPackageWith (
                    currentScope
                    // final
                    // {
                      ${name} = prev.${name} or recursionGuardError;
                    }
                  );

              errorContext =
                let
                  replacingOrDefining = if builtins.hasAttr name prev then "replacing" else "defining";
                in
                "while ${replacingOrDefining} '${attrPathStr}' by evaluating '${value.path}'";
            in
            builtins.addErrorContext errorContext (callPackage value.path { });

          "directory" =
            # Try extend an existing attrset or create a new scope
            let
              attrSet =
                if builtins.hasAttr name prev then prev.${name} else lib.makeScope final.newScope (_: { });
            in
            nef.extendAttrSet attrPath' (currentScope // final) attrSet value;
        }
        .${value.type}
      ) extensions.entries
    );
}
