{ lib }:

let

  /**
    This function collects all package attr paths
    from the recursive structure generated by `lib.nef.dirToAttrs`
    via a conditional fold operation.

    The result is a list of lists.

    # Example

    ```nix
    collectAttrPaths [] { path = "", type = "directory"; entries = {
      foo = { path = ""; type = "nix"; };
      bar = { path = "", type = "directory"; entries = {
          baz = { path = ""; type = "nix"; };
          bam = { path = ""; type = "nix"; };
      }; };
    };}
    =>
    [
      ["foo"]
      ["bar" "baz"]
      ["bar" "bam"]
    ]
    ```

    # Type

    ```
    collectAttrPaths :: [String] -> Attrs -> [ [ String ] ]
    ```

    # Arguments

    prefix
    : The initial attr path (usually `[]`, but can be used to set a custom prefix)

    attrsFromDir
    : An attribute set created from `lib.nef.dirToAttrs`
      It is expected that the top level is of `type = "directory"`

    :::
  */
  collectAttrPaths =
    prefix: attrsFromDir:
    {

      "nix" = [ prefix ];
      "directory" = lib.concatLists (
        lib.mapAttrsToList (name: set: collectAttrPaths (prefix ++ [ name ]) set) (attrsFromDir.entries)
      );
    }
    .${attrsFromDir.type};

  /**
    This function converts a list of attrPaths to a space separated string,
    for use as makeTargets.

    ```
    makeTargets :: [ [String] ] -> [String]
    ```
  */
  attrPathStrings =
    # list of attrpaths e.g. result from `lib.nef.reflect.collectAttrPaths
    # collectAttrPaths: map (lib.showAttrPath) collectAttrPaths;
    collectAttrPaths: map (x: (lib.showAttrPath x)) collectAttrPaths;

  /*
    This function produces `make` targets from a list of attrPaths.
    The result is a single string with _space separated_ targets,
    where each target contains the string formatted attrPath _and the outputps_
    that are defiend by the derivation, i.e.: `<attrPath>:<output>(,<output>)*`.

    :::Note
    Todo: tricky attrs, e.g. containing spaces, although renaming is not possible at this point
    :::

    :::Note
    This function _evaluates_ the package set, and requires the attrPaths to both exist,
    and point to a derivation.
    :::

    # Type

    ```
    makeTargetsWithOutputs :: [ [String] ] -> String
    ```
  */
  makeTargetsWithOutputs =
    # list of attrpaths e.g. result from `lib.nef.reflect.collectAttrPaths
    collectedAttrPaths:
    # extended package set, containing **derivation** attrsets at the collected attrPaths
    pkgs:
    let
      mkAttrPathsWithOutputs = map (
        attrPath:
        let
          derivation = lib.getAttrFromPath attrPath pkgs;
          # derivations have a guaranteed outputs field
          outputs = lib.concatStringsSep "," derivation.outputs;
          attrPathString = lib.showAttrPath attrPath;
        in
        assert lib.assertMsg (
          lib.isAttrs derivation && derivation ? type && derivation.type == "derivation"
        ) "${attrPathString} is not a derivation";
        # TODO: use "^" as a separator in symmetry with nix?
        "${attrPathString}:${outputs}"
      );
    in
    lib.concatStringsSep " " (mkAttrPathsWithOutputs collectedAttrPaths);

in
{

  inherit
    collectAttrPaths
    attrPathStrings
    makeTargetsWithOutputs
    ;

}
