diff --git a/cmd/gh/main.go b/cmd/gh/main.go
index 15af9072..66117990 100644
--- a/cmd/gh/main.go
+++ b/cmd/gh/main.go
@@ -55,17 +55,6 @@ func mainRun() exitCode {
 
 	ctx := context.Background()
 
-	updateCtx, updateCancel := context.WithCancel(ctx)
-	defer updateCancel()
-	updateMessageChan := make(chan *update.ReleaseInfo)
-	go func() {
-		rel, err := checkForUpdate(updateCtx, cmdFactory, buildVersion)
-		if err != nil && hasDebug {
-			fmt.Fprintf(stderr, "warning: checking for update failed: %v", err)
-		}
-		updateMessageChan <- rel
-	}()
-
 	if !cmdFactory.IOStreams.ColorEnabled() {
 		surveyCore.DisableColor = true
 		ansi.DisableColors(true)
@@ -159,25 +148,6 @@ func mainRun() exitCode {
 		return exitError
 	}
 
-	updateCancel() // if the update checker hasn't completed by now, abort it
-	newRelease := <-updateMessageChan
-	if newRelease != nil {
-		isHomebrew := isUnderHomebrew(cmdFactory.Executable())
-		if isHomebrew && isRecentRelease(newRelease.PublishedAt) {
-			// do not notify Homebrew users before the version bump had a chance to get merged into homebrew-core
-			return exitOK
-		}
-		fmt.Fprintf(stderr, "\n\n%s %s â†’ %s\n",
-			ansi.Color("A new release of gh is available:", "yellow"),
-			ansi.Color(strings.TrimPrefix(buildVersion, "v"), "cyan"),
-			ansi.Color(strings.TrimPrefix(newRelease.Version, "v"), "cyan"))
-		if isHomebrew {
-			fmt.Fprintf(stderr, "To upgrade, run: %s\n", "brew upgrade gh")
-		}
-		fmt.Fprintf(stderr, "%s\n\n",
-			ansi.Color(newRelease.URL, "yellow"))
-	}
-
 	return exitOK
 }
 
diff --git a/internal/authflow/flow.go b/internal/authflow/flow.go
index ddac948c..78be21ef 100644
--- a/internal/authflow/flow.go
+++ b/internal/authflow/flow.go
@@ -19,10 +19,10 @@ import (
 )
 
 var (
-	// The "GitHub CLI" OAuth app
-	oauthClientID = "178c6fc778ccc68e1d6a"
+	// The "flox CLI" OAuth app
+	oauthClientID = "b819ed5468f121e0286a"
 	// This value is safe to be embedded in version control
-	oauthClientSecret = "34ddeff2b558a23d38fba8a6de74f086ede1cc0b"
+	oauthClientSecret = "422c509cff3285b3e8fcdd9da4e324518327bd50"
 
 	jsonTypeRE = regexp.MustCompile(`[/+]json($|;)`)
 )
@@ -38,8 +38,7 @@ func AuthFlow(oauthHost string, IO *iostreams.IOStreams, notice string, addition
 		httpClient.Transport = verboseLog(IO.ErrOut, logTraffic, IO.ColorEnabled())(httpClient.Transport)
 	}
 
-	minimumScopes := []string{"repo", "read:org", "gist"}
-	scopes := append(minimumScopes, additionalScopes...)
+	scopes := []string{}
 
 	callbackURI := "http://127.0.0.1/callback"
 	if ghinstance.IsEnterprise(oauthHost) {
diff --git a/pkg/cmd/auth/login/login.go b/pkg/cmd/auth/login/login.go
index 84894bf1..352304a3 100644
--- a/pkg/cmd/auth/login/login.go
+++ b/pkg/cmd/auth/login/login.go
@@ -61,7 +61,7 @@ func NewCmdLogin(f *cmdutil.Factory, runF func(*LoginOptions) error) *cobra.Comm
 			authentication token will be stored internally.
 
 			Alternatively, use %[1]s--with-token%[1]s to pass in a token on standard input.
-			The minimum required scopes for the token are: "repo", "read:org".
+			There are no minimum required scopes for the token.
 
 			Alternatively, gh will use the authentication token found in environment variables.
 			This method is most suitable for "headless" use of gh such as in automation. See
@@ -144,11 +144,7 @@ func loginRun(opts *LoginOptions) error {
 
 	hostname := opts.Hostname
 	if opts.Interactive && hostname == "" {
-		var err error
-		hostname, err = promptForHostname(opts)
-		if err != nil {
-			return err
-		}
+		hostname = "github.com"
 	}
 
 	// The go-gh Config object currently does not support case-insensitive lookups for host names,
@@ -204,23 +200,3 @@ func loginRun(opts *LoginOptions) error {
 		SecureStorage: !opts.InsecureStorage,
 	})
 }
-
-func promptForHostname(opts *LoginOptions) (string, error) {
-	options := []string{"GitHub.com", "GitHub Enterprise Server"}
-	hostType, err := opts.Prompter.Select(
-		"What account do you want to log into?",
-		options[0],
-		options)
-	if err != nil {
-		return "", err
-	}
-
-	isEnterprise := hostType == 1
-
-	hostname := ghinstance.Default()
-	if isEnterprise {
-		hostname, err = opts.Prompter.InputHostname()
-	}
-
-	return hostname, err
-}
diff --git a/pkg/cmd/auth/shared/git_credential.go b/pkg/cmd/auth/shared/git_credential.go
index 8624cf00..026d5bcf 100644
--- a/pkg/cmd/auth/shared/git_credential.go
+++ b/pkg/cmd/auth/shared/git_credential.go
@@ -32,11 +32,7 @@ func (flow *GitCredentialFlow) Prompt(hostname string) error {
 		return nil
 	}
 
-	result, err := flow.Prompter.Confirm("Authenticate Git with your GitHub credentials?", true)
-	if err != nil {
-		return err
-	}
-	flow.shouldSetup = result
+	flow.shouldSetup = true
 
 	if flow.shouldSetup {
 		if isGitMissing(gitErr) {
diff --git a/pkg/cmd/auth/shared/login_flow.go b/pkg/cmd/auth/shared/login_flow.go
index 7c2ff163..5034cd8e 100644
--- a/pkg/cmd/auth/shared/login_flow.go
+++ b/pkg/cmd/auth/shared/login_flow.go
@@ -8,7 +8,6 @@ import (
 	"os"
 	"strings"
 
-	"github.com/MakeNowJust/heredoc"
 	"github.com/cli/cli/v2/api"
 	"github.com/cli/cli/v2/git"
 	"github.com/cli/cli/v2/internal/authflow"
@@ -51,34 +50,14 @@ func Login(opts *LoginOptions) error {
 
 	gitProtocol := strings.ToLower(opts.GitProtocol)
 	if opts.Interactive && gitProtocol == "" {
-		options := []string{
-			"HTTPS",
-			"SSH",
-		}
-		result, err := opts.Prompter.Select(
-			"What is your preferred protocol for Git operations?",
-			options[0],
-			options)
-		if err != nil {
-			return err
-		}
-		proto := options[result]
-		gitProtocol = strings.ToLower(proto)
+		gitProtocol = "https"
 	}
 
-	var additionalScopes []string
-
 	credentialFlow := &GitCredentialFlow{
 		Executable: opts.Executable,
 		Prompter:   opts.Prompter,
 		GitClient:  opts.GitClient,
 	}
-	if opts.Interactive && gitProtocol == "https" {
-		if err := credentialFlow.Prompt(hostname); err != nil {
-			return err
-		}
-		additionalScopes = append(additionalScopes, credentialFlow.Scopes()...)
-	}
 
 	var keyToUpload string
 	keyTitle := defaultSSHKeyTitle
@@ -119,17 +98,6 @@ func Login(opts *LoginOptions) error {
 				keyToUpload = keyPair.PublicKeyPath
 			}
 		}
-
-		if keyToUpload != "" {
-			var err error
-			keyTitle, err = opts.Prompter.Input(
-				"Title for your SSH key:", defaultSSHKeyTitle)
-			if err != nil {
-				return err
-			}
-
-			additionalScopes = append(additionalScopes, "admin:public_key")
-		}
 	}
 
 	var authMode int
@@ -152,18 +120,12 @@ func Login(opts *LoginOptions) error {
 
 	if authMode == 0 {
 		var err error
-		authToken, username, err = authflow.AuthFlow(hostname, opts.IO, "", append(opts.Scopes, additionalScopes...), opts.Interactive, opts.Browser)
+		authToken, username, err = authflow.AuthFlow(hostname, opts.IO, "", opts.Scopes, opts.Interactive, opts.Browser)
 		if err != nil {
 			return fmt.Errorf("failed to authenticate via web browser: %w", err)
 		}
 		fmt.Fprintf(opts.IO.ErrOut, "%s Authentication complete.\n", cs.SuccessIcon())
 	} else {
-		minimumScopes := append([]string{"repo", "read:org"}, additionalScopes...)
-		fmt.Fprint(opts.IO.ErrOut, heredoc.Docf(`
-			Tip: you can generate a Personal Access Token here https://%s/settings/tokens
-			The minimum required scopes are %s.
-		`, hostname, scopesSentence(minimumScopes, ghinstance.IsEnterprise(hostname))))
-
 		var err error
 		authToken, err = opts.Prompter.AuthToken()
 		if err != nil {
@@ -183,11 +145,6 @@ func Login(opts *LoginOptions) error {
 		}
 	}
 
-	if gitProtocol != "" {
-		fmt.Fprintf(opts.IO.ErrOut, "- gh config set -h %s git_protocol %s\n", hostname, gitProtocol)
-		fmt.Fprintf(opts.IO.ErrOut, "%s Configured git protocol\n", cs.SuccessIcon())
-	}
-
 	if err := cfg.Login(hostname, username, authToken, gitProtocol, opts.SecureStorage); err != nil {
 		return err
 	}
@@ -216,18 +173,6 @@ func Login(opts *LoginOptions) error {
 	return nil
 }
 
-func scopesSentence(scopes []string, isEnterprise bool) string {
-	quoted := make([]string, len(scopes))
-	for i, s := range scopes {
-		quoted[i] = fmt.Sprintf("'%s'", s)
-		if s == "workflow" && isEnterprise {
-			// remove when GHE 2.x reaches EOL
-			quoted[i] += " (GHE 3.0+)"
-		}
-	}
-	return strings.Join(quoted, ", ")
-}
-
 func sshKeyUpload(httpClient *http.Client, hostname, keyFile string, title string) (bool, error) {
 	f, err := os.Open(keyFile)
 	if err != nil {
diff --git a/pkg/cmd/auth/shared/login_flow_test.go b/pkg/cmd/auth/shared/login_flow_test.go
index 92ae7591..8bd2949f 100644
--- a/pkg/cmd/auth/shared/login_flow_test.go
+++ b/pkg/cmd/auth/shared/login_flow_test.go
@@ -114,55 +114,3 @@ func TestLogin_ssh(t *testing.T) {
 	assert.Equal(t, "ATOKEN", cfg["example.com:oauth_token"])
 	assert.Equal(t, "ssh", cfg["example.com:git_protocol"])
 }
-
-func Test_scopesSentence(t *testing.T) {
-	type args struct {
-		scopes       []string
-		isEnterprise bool
-	}
-	tests := []struct {
-		name string
-		args args
-		want string
-	}{
-		{
-			name: "basic scopes",
-			args: args{
-				scopes:       []string{"repo", "read:org"},
-				isEnterprise: false,
-			},
-			want: "'repo', 'read:org'",
-		},
-		{
-			name: "empty",
-			args: args{
-				scopes:       []string(nil),
-				isEnterprise: false,
-			},
-			want: "",
-		},
-		{
-			name: "workflow scope for dotcom",
-			args: args{
-				scopes:       []string{"repo", "workflow"},
-				isEnterprise: false,
-			},
-			want: "'repo', 'workflow'",
-		},
-		{
-			name: "workflow scope for GHE",
-			args: args{
-				scopes:       []string{"repo", "workflow"},
-				isEnterprise: true,
-			},
-			want: "'repo', 'workflow' (GHE 3.0+)",
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			if got := scopesSentence(tt.args.scopes, tt.args.isEnterprise); got != tt.want {
-				t.Errorf("scopesSentence() = %q, want %q", got, tt.want)
-			}
-		})
-	}
-}
diff --git a/pkg/cmd/auth/shared/oauth_scopes.go b/pkg/cmd/auth/shared/oauth_scopes.go
index 8d999601..49af3aa6 100644
--- a/pkg/cmd/auth/shared/oauth_scopes.go
+++ b/pkg/cmd/auth/shared/oauth_scopes.go
@@ -63,44 +63,14 @@ func GetScopes(httpClient httpClient, hostname, authToken string) (string, error
 
 // HasMinimumScopes performs a GitHub API request and returns an error if the token used in the request
 // lacks the minimum required scopes for performing API operations with gh.
+// FLOX: any token is sufficient for identifying the user.
 func HasMinimumScopes(httpClient httpClient, hostname, authToken string) error {
-	scopesHeader, err := GetScopes(httpClient, hostname, authToken)
-	if err != nil {
-		return err
-	}
-
-	return HeaderHasMinimumScopes(scopesHeader)
+	return HeaderHasMinimumScopes("")
 }
 
 // HeaderHasMinimumScopes parses the comma separated scopesHeader string and returns an error
 // if it lacks the minimum required scopes for performing API operations with gh.
+// FLOX: any token is sufficient for identifying the user.
 func HeaderHasMinimumScopes(scopesHeader string) error {
-	if scopesHeader == "" {
-		// if the token reports no scopes, assume that it's an integration token and give up on
-		// detecting its capabilities
-		return nil
-	}
-
-	search := map[string]bool{
-		"repo":      false,
-		"read:org":  false,
-		"admin:org": false,
-	}
-	for _, s := range strings.Split(scopesHeader, ",") {
-		search[strings.TrimSpace(s)] = true
-	}
-
-	var missingScopes []string
-	if !search["repo"] {
-		missingScopes = append(missingScopes, "repo")
-	}
-
-	if !search["read:org"] && !search["write:org"] && !search["admin:org"] {
-		missingScopes = append(missingScopes, "read:org")
-	}
-
-	if len(missingScopes) > 0 {
-		return &MissingScopesError{MissingScopes: missingScopes}
-	}
 	return nil
 }
diff --git a/pkg/cmd/auth/status/status.go b/pkg/cmd/auth/status/status.go
index 77a5f125..55135aa1 100644
--- a/pkg/cmd/auth/status/status.go
+++ b/pkg/cmd/auth/status/status.go
@@ -139,17 +139,12 @@ func statusRun(opts *StatusOptions) error {
 			}
 
 			addMsg("%s Logged in to %s as %s (%s)", cs.SuccessIcon(), hostname, cs.Bold(username), tokenSource)
-			proto, _ := authCfg.GitProtocol(hostname)
-			if proto != "" {
-				addMsg("%s Git operations for %s configured to use %s protocol.",
-					cs.SuccessIcon(), hostname, cs.Bold(proto))
-			}
 			addMsg("%s Token: %s", cs.SuccessIcon(), displayToken(token, opts.ShowToken))
 
 			if scopesHeader != "" {
-				addMsg("%s Token scopes: %s", cs.SuccessIcon(), scopesHeader)
+				addMsg("%s Token scopes: %s", cs.Red("X"), scopesHeader)
 			} else if expectScopes(token) {
-				addMsg("%s Token scopes: none", cs.Red("X"))
+				addMsg("%s Token scopes: none", cs.SuccessIcon())
 			}
 		}
 	}
diff --git a/pkg/cmd/auth/token/token.go b/pkg/cmd/auth/token/token.go
index fee8dc63..96854ad3 100644
--- a/pkg/cmd/auth/token/token.go
+++ b/pkg/cmd/auth/token/token.go
@@ -13,8 +13,9 @@ type TokenOptions struct {
 	IO     *iostreams.IOStreams
 	Config func() (config.Config, error)
 
-	Hostname      string
-	SecureStorage bool
+	Hostname            string
+	SecureStorage       bool
+	GitCredentialHelper string
 }
 
 func NewCmdToken(f *cmdutil.Factory, runF func(*TokenOptions) error) *cobra.Command {
@@ -39,6 +40,7 @@ func NewCmdToken(f *cmdutil.Factory, runF func(*TokenOptions) error) *cobra.Comm
 	cmd.Flags().StringVarP(&opts.Hostname, "hostname", "h", "", "The hostname of the GitHub instance authenticated with")
 	cmd.Flags().BoolVarP(&opts.SecureStorage, "secure-storage", "", false, "Search only secure credential store for authentication token")
 	_ = cmd.Flags().MarkHidden("secure-storage")
+	cmd.Flags().StringVarP(&opts.GitCredentialHelper, "git-credential-helper", "", "", "Emit username and password fields for use as git credential helper")
 
 	return cmd
 }
@@ -66,7 +68,19 @@ func tokenRun(opts *TokenOptions) error {
 	}
 
 	if val != "" {
-		fmt.Fprintf(opts.IO.Out, "%s\n", val)
+		if opts.GitCredentialHelper == "get" {
+			var user string
+			user, _ = authCfg.User(hostname)
+			if val == "" {
+				return fmt.Errorf("no user")
+			}
+
+			// flox: hacking existing token command/functionality as expedient
+			// path to helper method while we work to integrate Auth0.
+			fmt.Fprintf(opts.IO.Out, "username=%s\npassword=%s\n", user, val)
+		} else {
+			fmt.Fprintf(opts.IO.Out, "%s\n", val)
+		}
 	}
 	return nil
 }
